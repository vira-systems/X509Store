<?xml version="1.0"?>
<doc>
    <assembly>
        <name>bctls-fips-1.0.2</name>
    </assembly>
    <members>
        <member name="T:Org.BouncyCastle.Tls.AbstractTlsClient">
            <summary>Base class for a TLS client.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.AbstractTlsClient.AllowUnexpectedServerExtension(System.Int32,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.AbstractTlsClient.CheckForUnexpectedServerExtension(System.Collections.IDictionary,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.AbstractTlsClient.GetPskIdentity">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.AbstractTlsClient.GetMultiCertStatusRequest">
            <returns>an <see cref="T:System.Collections.IList"/> of <see cref="T:Org.BouncyCastle.Tls.CertificateStatusRequestItemV2"/> (or null).</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.AbstractTlsClient.GetSupportedGroups(System.Collections.IList)">
            <summary>The default <see cref="M:Org.BouncyCastle.Tls.AbstractTlsClient.GetClientExtensions"/> implementation calls this to determine which named
            groups to include in the supported_groups extension for the ClientHello.</summary>
            <param name="namedGroupRoles">The <see cref="T:Org.BouncyCastle.Tls.NamedGroupRole">named group roles</see> for which there should
            be at least one supported group. By default this is inferred from the offered cipher suites and signature
            algorithms.</param>
            <returns>an <see cref="T:System.Collections.IList"/> of <see cref="T:System.Int32"/>. See <see cref="T:Org.BouncyCastle.Tls.NamedGroup"/> for group constants.
            </returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.AbstractTlsClient.NotifyHandshakeBeginning">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.AbstractTlsClient.GetClientExtensions">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.AbstractTlsClient.NotifyServerVersion(Org.BouncyCastle.Tls.ProtocolVersion)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.AbstractTlsClient.NotifySelectedPsk(Org.BouncyCastle.Tls.TlsPsk)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.AbstractTlsClient.ProcessServerExtensions(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.AbstractTlsClient.ProcessServerSupplementalData(System.Collections.IList)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.AbstractTlsClient.GetClientSupplementalData">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.AbstractTlsClient.NotifyNewSessionTicket(Org.BouncyCastle.Tls.NewSessionTicket)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.AbstractTlsContext.HandshakeBeginning(Org.BouncyCastle.Tls.TlsPeer)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.AbstractTlsContext.HandshakeComplete(Org.BouncyCastle.Tls.TlsPeer,Org.BouncyCastle.Tls.TlsSession)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.AbstractTlsKeyExchange">
            <summary>Base class for supporting a TLS key exchange implementation.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.AbstractTlsKeyExchangeFactory">
            <summary>Base class for supporting a TLS key exchange factory implementation.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.AbstractTlsPeer">
            <summary>Base class for a TLS client or server.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.AbstractTlsPeer.GetSupportedVersions">
            <summary>Get the <see cref="T:Org.BouncyCastle.Tls.ProtocolVersion"/> values that are supported by this peer.</summary>
            <remarks>
            WARNING: Mixing DTLS and TLS versions in the returned array is currently NOT supported. Use a separate
            (sub-)class for each case.
            </remarks>
            <returns>an array of supported <see cref="T:Org.BouncyCastle.Tls.ProtocolVersion"/> values.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.AbstractTlsPeer.Cancel">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.AbstractTlsPeer.NotifyHandshakeBeginning">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.AbstractTlsPeer.NotifySecureRenegotiation(System.Boolean)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.AbstractTlsPeer.GetKeyExchangeFactory">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.AbstractTlsPeer.NotifyHandshakeComplete">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.AbstractTlsServer">
            <summary>Base class for a TLS server.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.AbstractTlsServer.SelectCipherSuite(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.AlertDescription">
            <summary>RFC 5246 7.2.</summary>
        </member>
        <member name="F:Org.BouncyCastle.Tls.AlertDescription.close_notify">
            <summary>This message notifies the recipient that the sender will not send any more messages on this
            connection.</summary>
            <remarks>
            Note that as of TLS 1.1, failure to properly close a connection no longer requires that a session not be
            resumed. This is a change from TLS 1.0 ("The session becomes unresumable if any connection is terminated
            without proper close_notify messages with level equal to warning.") to conform with widespread
            implementation practice.
            </remarks>
        </member>
        <member name="F:Org.BouncyCastle.Tls.AlertDescription.unexpected_message">
            <summary>An inappropriate message was received.</summary>
            <remarks>
            This alert is always fatal and should never be observed in communication between proper implementations.
            </remarks>
        </member>
        <member name="F:Org.BouncyCastle.Tls.AlertDescription.bad_record_mac">
            <summary>This alert is returned if a record is received with an incorrect MAC.</summary>
            <remarks>
            This alert also MUST be returned if an alert is sent because a TLSCiphertext decrypted in an invalid way:
            either it wasn't an even multiple of the block length, or its padding values, when checked, weren't
            correct. This message is always fatal and should never be observed in communication between proper
            implementations (except when messages were corrupted in the network).
            </remarks>
        </member>
        <member name="F:Org.BouncyCastle.Tls.AlertDescription.decryption_failed">
            <remarks>
            This alert was used in some earlier versions of TLS, and may have permitted certain attacks against the CBC
            mode [CBCATT]. It MUST NOT be sent by compliant implementations.
            </remarks>
        </member>
        <member name="F:Org.BouncyCastle.Tls.AlertDescription.record_overflow">
            <summary>A TLSCiphertext record was received that had a length more than 2^14+2048 bytes, or a record
            decrypted to a TLSCompressed record with more than 2^14+1024 bytes.</summary>
            <remarks>
            This message is always fatal and should never be observed in communication between proper implementations
            (except when messages were corrupted in the network).
            </remarks>
        </member>
        <member name="F:Org.BouncyCastle.Tls.AlertDescription.decompression_failure">
            <summary>The decompression function received improper input (e.g., data that would expand to excessive
            length).</summary>
            <remarks>
            This message is always fatal and should never be observed in communication between proper implementations.
            </remarks>
        </member>
        <member name="F:Org.BouncyCastle.Tls.AlertDescription.handshake_failure">
            <summary>Reception of a handshake_failure alert message indicates that the sender was unable to negotiate
            an acceptable set of security parameters given the options available.</summary>
            <remarks>
            This is a fatal error.
            </remarks>
        </member>
        <member name="F:Org.BouncyCastle.Tls.AlertDescription.no_certificate">
            <remarks>
            This alert was used in SSLv3 but not any version of TLS. It MUST NOT be sent by compliant implementations.
            </remarks>
        </member>
        <member name="F:Org.BouncyCastle.Tls.AlertDescription.bad_certificate">
            <summary>A certificate was corrupt, contained signatures that did not verify correctly, etc.</summary>
        </member>
        <member name="F:Org.BouncyCastle.Tls.AlertDescription.unsupported_certificate">
            <summary>A certificate was of an unsupported type.</summary>
        </member>
        <member name="F:Org.BouncyCastle.Tls.AlertDescription.certificate_revoked">
            <summary>A certificate was revoked by its signer.</summary>
        </member>
        <member name="F:Org.BouncyCastle.Tls.AlertDescription.certificate_expired">
            <summary>A certificate has expired or is not currently valid.</summary>
        </member>
        <member name="F:Org.BouncyCastle.Tls.AlertDescription.certificate_unknown">
            <summary>Some other (unspecified) issue arose in processing the certificate, rendering it unacceptable.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Tls.AlertDescription.illegal_parameter">
            <summary>A field in the handshake was out of range or inconsistent with other fields.</summary>
            <remarks>
            This message is always fatal.
            </remarks>
        </member>
        <member name="F:Org.BouncyCastle.Tls.AlertDescription.unknown_ca">
            <summary>A valid certificate chain or partial chain was received, but the certificate was not accepted
            because the CA certificate could not be located or couldn't be matched with a known, trusted CA.</summary>
            <remarks>
            This message is always fatal.
            </remarks>
        </member>
        <member name="F:Org.BouncyCastle.Tls.AlertDescription.access_denied">
            <summary>A valid certificate was received, but when access control was applied, the sender decided not to
            proceed with negotiation.</summary>
            <remarks>
            This message is always fatal.
            </remarks>
        </member>
        <member name="F:Org.BouncyCastle.Tls.AlertDescription.decode_error">
            <summary>A message could not be decoded because some field was out of the specified range or the length of
            the message was incorrect.</summary>
            <remarks>
            This message is always fatal and should never be observed in communication between proper
            implementations (except when messages were corrupted in the network).
            </remarks>
        </member>
        <member name="F:Org.BouncyCastle.Tls.AlertDescription.decrypt_error">
            <summary>A handshake cryptographic operation failed, including being unable to correctly verify a signature
            or validate a Finished message.</summary>
            <remarks>
            This message is always fatal.
            </remarks>
        </member>
        <member name="F:Org.BouncyCastle.Tls.AlertDescription.export_restriction">
            <remarks>
            This alert was used in some earlier versions of TLS. It MUST NOT be sent by compliant implementations.
            </remarks>
        </member>
        <member name="F:Org.BouncyCastle.Tls.AlertDescription.protocol_version">
            <summary>The protocol version the client has attempted to negotiate is recognized but not supported.
            </summary>
            <remarks>
            (For example, old protocol versions might be avoided for security reasons.) This message is always fatal.
            </remarks>
        </member>
        <member name="F:Org.BouncyCastle.Tls.AlertDescription.insufficient_security">
            <summary>Returned instead of handshake_failure when a negotiation has failed specifically because the
            server requires ciphers more secure than those supported by the client.</summary>
            <remarks>
            This message is always fatal.
            </remarks>
        </member>
        <member name="F:Org.BouncyCastle.Tls.AlertDescription.internal_error">
            <summary>An internal error unrelated to the peer or the correctness of the protocol (such as a memory
            allocation failure) makes it impossible to continue.</summary>
            <remarks>
            This message is always fatal.
            </remarks>
        </member>
        <member name="F:Org.BouncyCastle.Tls.AlertDescription.user_canceled">
            <summary>This handshake is being canceled for some reason unrelated to a protocol failure.</summary>
            <remarks>
            If the user cancels an operation after the handshake is complete, just closing the connection by sending a
            close_notify is more appropriate. This alert should be followed by a close_notify. This message is
            generally a warning.
            </remarks>
        </member>
        <member name="F:Org.BouncyCastle.Tls.AlertDescription.no_renegotiation">
            <summary>Sent by the client in response to a hello request or by the server in response to a client hello
            after initial handshaking.</summary>
            <remarks>
            Either of these would normally lead to renegotiation; when that is not appropriate, the recipient should
            respond with this alert. At that point, the original requester can decide whether to proceed with the
            connection. One case where this would be appropriate is where a server has spawned a process to satisfy a
            request; the process might receive security parameters (key length, authentication, etc.) at startup, and
            it might be difficult to communicate changes to these parameters after that point. This message is always a
            warning.
            </remarks>
        </member>
        <member name="F:Org.BouncyCastle.Tls.AlertDescription.unsupported_extension">
            <summary>Sent by clients that receive an extended server hello containing an extension that they did not
            put in the corresponding client hello.</summary>
            <remarks>
            This message is always fatal.
            </remarks>
        </member>
        <member name="F:Org.BouncyCastle.Tls.AlertDescription.certificate_unobtainable">
            <summary>This alert is sent by servers who are unable to retrieve a certificate chain from the URL supplied
            by the client(see Section 3.3).</summary>
            <remarks>
            This message MAY be fatal - for example if client authentication is required by the server for the
            handshake to continue and the server is unable to retrieve the certificate chain, it may send a fatal
            alert.
            </remarks>
        </member>
        <member name="F:Org.BouncyCastle.Tls.AlertDescription.unrecognized_name">
            <summary>This alert is sent by servers that receive a server_name extension request, but do not recognize
            the server name.</summary>
            <remarks>
            This message MAY be fatal.
            </remarks>
        </member>
        <member name="F:Org.BouncyCastle.Tls.AlertDescription.bad_certificate_status_response">
            <summary>This alert is sent by clients that receive an invalid certificate status response (see Section 3.6
            ).</summary>
            <remarks>
            This message is always fatal.
            </remarks>
        </member>
        <member name="F:Org.BouncyCastle.Tls.AlertDescription.bad_certificate_hash_value">
            <summary>This alert is sent by servers when a certificate hash does not match a client provided
            certificate_hash.</summary>
            <remarks>
            This message is always fatal.
            </remarks>
        </member>
        <member name="F:Org.BouncyCastle.Tls.AlertDescription.unknown_psk_identity">
            <summary>If the server does not recognize the PSK identity, it MAY respond with an "unknown_psk_identity"
            alert message.</summary>
        </member>
        <member name="F:Org.BouncyCastle.Tls.AlertDescription.no_application_protocol">
            <summary>In the event that the server supports no protocols that the client advertises, then the server
            SHALL respond with a fatal "no_application_protocol" alert.</summary>
        </member>
        <member name="F:Org.BouncyCastle.Tls.AlertDescription.inappropriate_fallback">
            <summary>If TLS_FALLBACK_SCSV appears in ClientHello.cipher_suites and the highest protocol version
            supported by the server is higher than the version indicated in ClientHello.client_version, the server MUST
            respond with a fatal inappropriate_fallback alert[..].</summary>
        </member>
        <member name="F:Org.BouncyCastle.Tls.AlertDescription.missing_extension">
            <summary>Sent by endpoints that receive a handshake message not containing an extension that is mandatory
            to send for the offered TLS version or other negotiated parameters.</summary>
        </member>
        <member name="F:Org.BouncyCastle.Tls.AlertDescription.certificate_required">
            <summary>Sent by servers when a client certificate is desired but none was provided by the client.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.AlertLevel">
            <summary>RFC 5246 7.2</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.BasicTlsPskIdentity">
            <summary>A basic PSK Identity holder.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.ByteQueue">
            <summary>A queue for bytes. This file could be more optimized.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.ByteQueue.NextTwoPow(System.Int32)">
            <returns>The smallest number which can be written as 2^x which is bigger than i.</returns>
        </member>
        <member name="F:Org.BouncyCastle.Tls.ByteQueue.m_databuf">
            <summary>The buffer where we store our data.</summary>
        </member>
        <member name="F:Org.BouncyCastle.Tls.ByteQueue.m_skipped">
            <summary>How many bytes at the beginning of the buffer are skipped.</summary>
        </member>
        <member name="F:Org.BouncyCastle.Tls.ByteQueue.m_available">
            <summary>How many bytes in the buffer are valid data.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.ByteQueue.AddData(System.Byte[],System.Int32,System.Int32)">
            <summary>Add some data to our buffer.</summary>
            <param name="buf">A byte-array to read data from.</param>
            <param name="off">How many bytes to skip at the beginning of the array.</param>
            <param name="len">How many bytes to read from the array.</param>
        </member>
        <member name="P:Org.BouncyCastle.Tls.ByteQueue.Available">
            <returns>The number of bytes which are available in this buffer.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.ByteQueue.CopyTo(System.IO.Stream,System.Int32)">
            <summary>Copy some bytes from the beginning of the data to the provided <see cref="T:System.IO.Stream"/>.</summary>
            <param name="output">The <see cref="T:System.IO.Stream"/> to copy the bytes to.</param>
            <param name="length">How many bytes to copy.</param>
        </member>
        <member name="M:Org.BouncyCastle.Tls.ByteQueue.Read(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>Read data from the buffer.</summary>
            <param name="buf">The buffer where the read data will be copied to.</param>
            <param name="offset">How many bytes to skip at the beginning of buf.</param>
            <param name="len">How many bytes to read at all.</param>
            <param name="skip">How many bytes from our data to skip.</param>
        </member>
        <member name="M:Org.BouncyCastle.Tls.ByteQueue.ReadHandshakeMessage(System.Int32)">
            <summary>Return a <see cref="T:Org.BouncyCastle.Tls.HandshakeMessageInput"/> over some bytes at the beginning of the data.
            </summary>
            <param name="length">How many bytes will be readable.</param>
            <returns>A <see cref="T:Org.BouncyCastle.Tls.HandshakeMessageInput"/> over the data.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.ByteQueue.RemoveData(System.Int32)">
            <summary>Remove some bytes from our data from the beginning.</summary>
            <param name="i">How many bytes to remove.</param>
        </member>
        <member name="M:Org.BouncyCastle.Tls.ByteQueue.RemoveData(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>Remove data from the buffer.</summary>
            <param name="buf">The buffer where the removed data will be copied to.</param>
            <param name="off">How many bytes to skip at the beginning of buf.</param>
            <param name="len">How many bytes to read at all.</param>
            <param name="skip">How many bytes from our data to skip.</param>
        </member>
        <member name="T:Org.BouncyCastle.Tls.ByteQueueOutputStream">
            <summary>OutputStream based on a ByteQueue implementation.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.CertChainType">
            <summary>Implementation of the RFC 3546 3.3. CertChainType.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Certificate">
            <summary>Parsing and encoding of a <i>Certificate</i> struct from RFC 4346.</summary>
            <remarks>
            <pre>
            opaque ASN.1Cert&lt;2^24-1&gt;;
            struct {
              ASN.1Cert certificate_list&lt;0..2^24-1&gt;;
            } Certificate;
            </pre>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Certificate.GetCertificateList">
            <returns>an array of <see cref="T:Org.BouncyCastle.Tls.Crypto.TlsCertificate"/> representing a certificate chain.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Tls.Certificate.IsEmpty">
            <returns><c>true</c> if this certificate chain contains no certificates, or <c>false</c> otherwise.
            </returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Certificate.Encode(Org.BouncyCastle.Tls.TlsContext,System.IO.Stream,System.IO.Stream)">
            <summary>Encode this <see cref="T:Org.BouncyCastle.Tls.Certificate"/> to a <see cref="T:System.IO.Stream"/>, and optionally calculate the
            "end point hash" (per RFC 5929's tls-server-end-point binding).</summary>
            <param name="context">the <see cref="T:Org.BouncyCastle.Tls.TlsContext"/> of the current connection.</param>
            <param name="messageOutput">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <param name="endPointHashOutput">the <see cref="T:System.IO.Stream"/> to write the "end point hash" to (or null).
            </param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Certificate.Parse(Org.BouncyCastle.Tls.Certificate.ParseOptions,Org.BouncyCastle.Tls.TlsContext,System.IO.Stream,System.IO.Stream)">
            <summary>Parse a <see cref="T:Org.BouncyCastle.Tls.Certificate"/> from a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="options">the <see cref="T:Org.BouncyCastle.Tls.Certificate.ParseOptions"/> to apply during parsing.</param>
            <param name="context">the <see cref="T:Org.BouncyCastle.Tls.TlsContext"/> of the current connection.</param>
            <param name="messageInput">the <see cref="T:System.IO.Stream"/> to parse from.</param>
            <param name="endPointHashOutput">the <see cref="T:System.IO.Stream"/> to write the "end point hash" to (or null).
            </param>
            <returns>a <see cref="T:Org.BouncyCastle.Tls.Certificate"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.CertificateCompressionAlgorithm">
            RFC 8879
        </member>
        <member name="T:Org.BouncyCastle.Tls.CertificateRequest">
            <summary>Parsing and encoding of a <i>CertificateRequest</i> struct from RFC 4346.</summary>
            <remarks>
            <pre>
            struct {
              ClientCertificateType certificate_types&lt;1..2^8-1&gt;;
              DistinguishedName certificate_authorities&lt;3..2^16-1&gt;;
            } CertificateRequest;
            </pre>
            Updated for RFC 5246:
            <pre>
            struct {
              ClientCertificateType certificate_types &lt;1..2 ^ 8 - 1&gt;;
              SignatureAndHashAlgorithm supported_signature_algorithms &lt;2 ^ 16 - 1&gt;;
              DistinguishedName certificate_authorities &lt;0..2 ^ 16 - 1&gt;;
            } CertificateRequest;
            </pre>
            Revised for RFC 8446:
            <pre>
            struct {
              opaque certificate_request_context &lt;0..2 ^ 8 - 1&gt;;
              Extension extensions &lt;2..2 ^ 16 - 1&gt;;
            } CertificateRequest;
            </pre>
            </remarks>
            <seealso cref="T:Org.BouncyCastle.Tls.ClientCertificateType"/>
            <seealso cref="T:Org.BouncyCastle.Asn1.X500.X500Name"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.CertificateRequest.CheckSupportedSignatureAlgorithms(System.Collections.IList,System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.CertificateRequest.#ctor(System.Int16[],System.Collections.IList,System.Collections.IList)">
            <param name="certificateTypes">see <see cref="T:Org.BouncyCastle.Tls.ClientCertificateType"/> for valid constants.</param>
            <param name="supportedSignatureAlgorithms"></param>
            <param name="certificateAuthorities">an <see cref="T:System.Collections.IList"/> of <see cref="T:Org.BouncyCastle.Asn1.X500.X500Name"/>.</param>
        </member>
        <member name="M:Org.BouncyCastle.Tls.CertificateRequest.#ctor(System.Byte[],System.Collections.IList,System.Collections.IList,System.Collections.IList)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="P:Org.BouncyCastle.Tls.CertificateRequest.CertificateTypes">
            <returns>an array of certificate types</returns>
            <seealso cref="T:Org.BouncyCastle.Tls.ClientCertificateType"/>
        </member>
        <member name="P:Org.BouncyCastle.Tls.CertificateRequest.SupportedSignatureAlgorithms">
            <returns>an <see cref="T:System.Collections.IList"/> of <see cref="T:Org.BouncyCastle.Tls.SignatureAndHashAlgorithm"/> (or null before TLS 1.2).
            </returns>
        </member>
        <member name="P:Org.BouncyCastle.Tls.CertificateRequest.SupportedSignatureAlgorithmsCert">
            <returns>an optional <see cref="T:System.Collections.IList"/> of <see cref="T:Org.BouncyCastle.Tls.SignatureAndHashAlgorithm"/>. May be non-null from
            TLS 1.3 onwards.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Tls.CertificateRequest.CertificateAuthorities">
            <returns>an <see cref="T:System.Collections.IList"/> of <see cref="T:Org.BouncyCastle.Asn1.X500.X500Name"/>.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.CertificateRequest.Encode(Org.BouncyCastle.Tls.TlsContext,System.IO.Stream)">
            <summary>Encode this <see cref="T:Org.BouncyCastle.Tls.CertificateRequest"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="context">the <see cref="T:Org.BouncyCastle.Tls.TlsContext"/> of the current connection.</param>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.CertificateRequest.Parse(Org.BouncyCastle.Tls.TlsContext,System.IO.Stream)">
            <summary>Parse a <see cref="T:Org.BouncyCastle.Tls.CertificateRequest"/> from a <see cref="T:System.IO.Stream"/></summary>
            <param name="context">the <see cref="T:Org.BouncyCastle.Tls.TlsContext"/> of the current connection.</param>
            <param name="input">the <see cref="T:System.IO.Stream"/> to parse from.</param>
            <returns>a <see cref="T:Org.BouncyCastle.Tls.CertificateRequest"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="P:Org.BouncyCastle.Tls.CertificateStatus.OcspResponseList">
            <summary>an <see cref="T:System.Collections.IList"/> of (possibly null) <see cref="T:Org.BouncyCastle.Asn1.Ocsp.OcspResponse"/>.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.CertificateStatus.Encode(System.IO.Stream)">
            <summary>Encode this <see cref="T:Org.BouncyCastle.Tls.CertificateStatus"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.CertificateStatus.Parse(Org.BouncyCastle.Tls.TlsContext,System.IO.Stream)">
            <summary>Parse a <see cref="T:Org.BouncyCastle.Tls.CertificateStatus"/> from a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="context">the <see cref="T:Org.BouncyCastle.Tls.TlsContext"/> of the current connection.</param>
            <param name="input">the <see cref="T:System.IO.Stream"/> to parse from.</param>
            <returns>a <see cref="T:Org.BouncyCastle.Tls.CertificateStatus"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.CertificateStatus.ParseOcspResponse(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.CertificateStatus.RequireStatusRequestVersion(System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.CertificateStatusRequest">
            <summary>Implementation of the RFC 3546 3.6. CertificateStatusRequest.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.CertificateStatusRequest.Encode(System.IO.Stream)">
            <summary>Encode this <see cref="T:Org.BouncyCastle.Tls.CertificateStatusRequest"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.CertificateStatusRequest.Parse(System.IO.Stream)">
            <summary>Parse a <see cref="T:Org.BouncyCastle.Tls.CertificateStatusRequest"/> from a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="input">the <see cref="T:System.IO.Stream"/> to parse from.</param>
            <returns>a <see cref="T:Org.BouncyCastle.Tls.CertificateStatusRequest"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.CertificateStatusRequestItemV2">
            <summary>Implementation of the RFC 6961 2.2. CertificateStatusRequestItemV2.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.CertificateStatusRequestItemV2.Encode(System.IO.Stream)">
            <summary>Encode this <see cref="T:Org.BouncyCastle.Tls.CertificateStatusRequestItemV2"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.CertificateStatusRequestItemV2.Parse(System.IO.Stream)">
            <summary>Parse a <see cref="T:Org.BouncyCastle.Tls.CertificateStatusRequestItemV2"/> from a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="input">the <see cref="T:System.IO.Stream"/> to parse from.</param>
            <returns>a <see cref="T:Org.BouncyCastle.Tls.CertificateStatusRequestItemV2"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.CertificateType">
            <summary>RFC 6091</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.CertificateUrl">
            <summary>RFC 3546 3.3</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.CertificateUrl.#ctor(System.Int16,System.Collections.IList)">
            <param name="type">see <see cref="T:Org.BouncyCastle.Tls.CertChainType"/> for valid constants.</param>
            <param name="urlAndHashList">an <see cref="T:System.Collections.IList"/> of <see cref="T:Org.BouncyCastle.Tls.UrlAndHash"/>.</param>
        </member>
        <member name="P:Org.BouncyCastle.Tls.CertificateUrl.Type">
            <returns><see cref="T:Org.BouncyCastle.Tls.CertChainType"/></returns>
        </member>
        <member name="P:Org.BouncyCastle.Tls.CertificateUrl.UrlAndHashList">
            <returns>an <see cref="T:System.Collections.IList"/> of <see cref="T:Org.BouncyCastle.Tls.UrlAndHash"/>.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.CertificateUrl.Encode(System.IO.Stream)">
            <summary>Encode this <see cref="T:Org.BouncyCastle.Tls.CertificateUrl"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.CertificateUrl.Parse(Org.BouncyCastle.Tls.TlsContext,System.IO.Stream)">
            <summary>Parse a <see cref="T:Org.BouncyCastle.Tls.CertificateUrl"/> from a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="context">the <see cref="T:Org.BouncyCastle.Tls.TlsContext"/> of the current connection.</param>
            <param name="input">the <see cref="T:System.IO.Stream"/> to parse from.</param>
            <returns>a <see cref="T:Org.BouncyCastle.Tls.CertificateUrl"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="P:Org.BouncyCastle.Tls.CertificateVerify.Algorithm">
            <returns>a <see cref="T:Org.BouncyCastle.Tls.SignatureScheme"/> value.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.CertificateVerify.Encode(System.IO.Stream)">
            <summary>Encode this <see cref="T:Org.BouncyCastle.Tls.CertificateVerify"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.CertificateVerify.Parse(Org.BouncyCastle.Tls.TlsContext,System.IO.Stream)">
            <summary>Parse a <see cref="T:Org.BouncyCastle.Tls.CertificateVerify"/> from a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="context">the <see cref="T:Org.BouncyCastle.Tls.TlsContext"/> of the current connection.</param>
            <param name="input">the <see cref="T:System.IO.Stream"/> to parse from.</param>
            <returns>a <see cref="T:Org.BouncyCastle.Tls.CertificateVerify"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.ChannelBinding">
            <summary>RFC 5056</summary>
            <remarks>
            Note that the values here are implementation-specific and arbitrary. It is recommended not to depend on the
            particular values (e.g.serialization).
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Tls.CipherSuite">
            <summary>RFC 2246 A.5</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.CipherType">
            <summary>RFC 2246</summary>
            <remarks>
            Note that the values here are implementation-specific and arbitrary. It is recommended not to depend on the
            particular values (e.g. serialization).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Tls.ClientHello.Encode(Org.BouncyCastle.Tls.TlsContext,System.IO.Stream)">
            <summary>Encode this <see cref="T:Org.BouncyCastle.Tls.ClientHello"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="context">the <see cref="T:Org.BouncyCastle.Tls.TlsContext"/> of the current connection.</param>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.ClientHello.Parse(System.IO.MemoryStream,System.IO.Stream)">
            <summary>Parse a <see cref="T:Org.BouncyCastle.Tls.ClientHello"/> from a <see cref="T:System.IO.MemoryStream"/>.</summary>
            <param name="messageInput">the <see cref="T:System.IO.MemoryStream"/> to parse from.</param>
            <param name="dtlsOutput">for DTLS this should be non-null; the input is copied to this
            <see cref="T:System.IO.Stream"/>, minus the cookie field.</param>
            <returns>a <see cref="T:Org.BouncyCastle.Tls.ClientHello"/> object.</returns>
            <exception cref="T:Org.BouncyCastle.Tls.TlsFatalAlert"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.ClientHello.ImplParse(System.IO.MemoryStream,System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.CombinedHash">
            <summary>A combined hash, which implements md5(m) || sha1(m).</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.CompressionMethod">
            <summary>RFC 2246 6.1</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.ConnectionEnd">
            <summary>RFC 2246</summary>
            <remarks>
            Note that the values here are implementation-specific and arbitrary. It is recommended not to depend on the
            particular values(e.g.serialization).
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Tls.ContentType">
            <summary>RFC 2246 6.2.1</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Core.Streams.WriteBufTo(System.IO.MemoryStream,System.IO.Stream)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.DHGroup">
            <summary>Carrier class for Diffie-Hellman group parameters.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.DHGroup.#ctor(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,System.Int32)">
            <summary>Base constructor with the prime factor of (p - 1).</summary>
            <param name="p">the prime modulus.</param>
            <param name="q">specifies the prime factor of (p - 1).</param>
            <param name="g">the base generator.</param>
            <param name="l"></param>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.DHStandardGroups">
            <summary>Standard Diffie-Hellman groups from various IETF specifications.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.Impl.AbstractTlsCrypto">
            <summary>Base class for a TlsCrypto implementation that provides some needed methods from elsewhere in the impl
            package.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.Impl.AbstractTlsSecret">
            <summary>Base class for a TlsSecret implementation which captures common code and fields.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.AbstractTlsSecret.#ctor(System.Byte[])">
            <summary>Base constructor.</summary>
            <param name="data">the byte[] making up the secret value.</param>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.AbstractTlsSecret.Encrypt(Org.BouncyCastle.Tls.Crypto.TlsEncryptor)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.Impl.BC.BcDefaultTlsCredentialedAgreement">
            <summay>Credentialed class generating agreed secrets from a peer's public key for our end of the TLS connection
            using the BC light-weight API.</summay>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.Impl.BC.BcDefaultTlsCredentialedDecryptor">
            <summary>Credentialed class decrypting RSA encrypted secrets sent from a peer for our end of the TLS connection
            using the BC light-weight API.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.Impl.BC.BcDefaultTlsCredentialedSigner">
            <summary>Credentialed class for generating signatures based on the use of primitives from the BC light-weight API.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCertificate">
            <summary>Implementation class for a single X.509 certificate based on the BC light-weight API.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCertificate.Convert(Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCrypto,Org.BouncyCastle.Tls.Crypto.TlsCertificate)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCertificate.ParseCertificate(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCertificate.#ctor(Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCrypto,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCertificate.CreateEncryptor(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCertificate.CreateVerifier(System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCertificate.CreateVerifier(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCertificate.GetEncoded">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCertificate.GetExtension(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCertificate.GetLegacySignatureAlgorithm">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCertificate.GetPubKeyDH">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCertificate.GetPubKeyDss">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCertificate.GetPubKeyEC">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCertificate.GetPubKeyEd25519">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCertificate.GetPubKeyEd448">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCertificate.GetPubKeyRsa">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCertificate.SupportsSignatureAlgorithm(System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCertificate.SupportsSignatureAlgorithmCA(System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCertificate.CheckUsageInRole(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCertificate.GetPublicKey">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCertificate.SupportsSignatureAlgorithm(System.Int16,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCertificate.ValidateKeyUsage(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCertificate.ValidateRsa_Pkcs1">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCertificate.ValidateRsa_Pss_Pss(System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCertificate.ValidateRsa_Pss_Rsae">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCrypto">
            Class for providing cryptographic services for TLS based on implementations in the BC light-weight API.
            <p>
                This class provides default implementations for everything. If you need to customise it, extend the class
                and override the appropriate methods.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCrypto.CollectResult(Org.BouncyCastle.Crypto.IStreamCalculator{Org.BouncyCastle.Crypto.IBlockResult})">
            <exception cref="!:IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsCrypto.IsVerifiedResult(Org.BouncyCastle.Crypto.IStreamCalculator{Org.BouncyCastle.Crypto.IVerifier},System.Byte[])">
            <exception cref="!:IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsDH">
            <summary>Support class for ephemeral Diffie-Hellman using the BC light-weight library.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsDHDomain">
            <summary>BC light-weight support class for Diffie-Hellman key pair generation and key agreement over a
            specified Diffie-Hellman configuration.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsDHDomain.DecodeParameter(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsDHDomain.DecodePublicKey(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsECDH">
            <summary>Support class for ephemeral Elliptic Curve Diffie-Hellman using the BC light-weight library.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsECDomain">
            EC domain class for generating key pairs and performing key agreement.
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsECDomain.DecodePublicKey(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.Impl.BC.BcTlsSecret">
            <summary>BC light-weight support class for handling TLS secrets and deriving key material and other secrets
            from them.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.Impl.TlsAeadCipher">
            <summary>A generic TLS 1.2 AEAD cipher.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.TlsAeadCipher.#ctor(Org.BouncyCastle.Tls.Crypto.TlsCryptoParameters,Org.BouncyCastle.Tls.Crypto.Impl.TlsAeadCipherImpl,Org.BouncyCastle.Tls.Crypto.Impl.TlsAeadCipherImpl,System.Int32,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.Impl.TlsAeadCipherImpl">
            <summary>Base interface for services supporting AEAD encryption/decryption.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.TlsAeadCipherImpl.SetKey(System.Byte[],System.Int32,System.Int32)">
            <summary>Set the key to be used by the AEAD cipher implementation supporting this service.</summary>
            <param name="key">array holding the AEAD cipher key.</param>
            <param name="keyOff">offset into the array the key starts at.</param>
            <param name="keyLen">length of the key in the array.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.TlsAeadCipherImpl.Init(System.Byte[],System.Int32,System.Byte[])">
            <summary>Initialise the parameters for the AEAD operator.</summary>
            <param name="nonce">the nonce.</param>
            <param name="macSize">MAC size in bytes.</param>
            <param name="additionalData">any additional data to be included in the MAC calculation.</param>
            <exception cref="T:System.IO.IOException">if the parameters are inappropriate.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.TlsAeadCipherImpl.GetOutputSize(System.Int32)">
            <summary>Return the maximum size of the output for input of inputLength bytes.</summary>
            <param name="inputLength">the length (in bytes) of the proposed input.</param>
            <returns>the maximum size of the output.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.TlsAeadCipherImpl.DoFinal(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>Perform the cipher encryption/decryption returning the output in output.</summary>
            <remarks>
            Note: we have to use DoFinal() here as it is the only way to guarantee output from the underlying cipher.
            </remarks>
            <param name="input">array holding input data to the cipher.</param>
            <param name="inputOffset">offset into input array data starts at.</param>
            <param name="inputLength">length of the input data in the array.</param>
            <param name="output">array to hold the cipher output.</param>
            <param name="outputOffset">offset into output array to start saving output.</param>
            <returns>the amount of data written to output.</returns>
            <exception cref="T:System.IO.IOException">in case of failure.</exception>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.Impl.TlsBlockCipher">
            <summary>A generic TLS 1.0-1.2 block cipher. This can be used for AES or 3DES for example.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.TlsBlockCipher.#ctor(Org.BouncyCastle.Tls.Crypto.TlsCryptoParameters,Org.BouncyCastle.Tls.Crypto.Impl.TlsBlockCipherImpl,Org.BouncyCastle.Tls.Crypto.Impl.TlsBlockCipherImpl,Org.BouncyCastle.Tls.Crypto.TlsHmac,Org.BouncyCastle.Tls.Crypto.TlsHmac,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.Impl.TlsBlockCipherImpl">
            <summary>Interface for block cipher services.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.TlsBlockCipherImpl.SetKey(System.Byte[],System.Int32,System.Int32)">
            <summary>Set the key to be used by the block cipher implementation supporting this service.</summary>
            <param name="key">array holding the block cipher key.</param>
            <param name="keyOff">offset into the array the key starts at.</param>
            <param name="keyLen">length of the key in the array.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.TlsBlockCipherImpl.Init(System.Byte[],System.Int32,System.Int32)">
            <summary>Initialise the parameters for operator.</summary>
            <param name="iv">array holding the initialization vector (IV).</param>
            <param name="ivOff">offset into the array the IV starts at.</param>
            <param name="ivLen">length of the IV in the array.</param>
            <exception cref="T:System.IO.IOException">if the parameters are inappropriate.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.TlsBlockCipherImpl.DoFinal(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>Perform the cipher encryption/decryption returning the output in output.</summary>
            <remarks>
            Note: we have to use DoFinal() here as it is the only way to guarantee output from the underlying cipher.
            </remarks>
            <param name="input">array holding input data to the cipher.</param>
            <param name="inputOffset">offset into input array data starts at.</param>
            <param name="inputLength">length of the input data in the array.</param>
            <param name="output">array to hold the cipher output.</param>
            <param name="outputOffset">offset into output array to start saving output.</param>
            <returns>the amount of data written to output.</returns>
            <exception cref="T:System.IO.IOException">in case of failure.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.TlsBlockCipherImpl.GetBlockSize">
            <summary>Return the blocksize (in bytes) of the underlying block cipher.</summary>
            <returns>the cipher's blocksize.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.Impl.TlsImplUtilities">
            <summary>Useful utility methods.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.Impl.TlsNullCipher">
            <summary>The NULL cipher.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.TlsNullCipher.#ctor(Org.BouncyCastle.Tls.Crypto.TlsCryptoParameters,Org.BouncyCastle.Tls.Crypto.TlsHmac,Org.BouncyCastle.Tls.Crypto.TlsHmac)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.Impl.TlsSuiteHmac">
            <summary>A generic TLS MAC implementation, acting as an HMAC based on some underlying Digest.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.TlsSuiteHmac.#ctor(Org.BouncyCastle.Tls.Crypto.TlsCryptoParameters,Org.BouncyCastle.Tls.Crypto.TlsHmac)">
            <summary>Generate a new instance of a TlsMac.</summary>
            <param name="cryptoParams">the TLS client context specific crypto parameters.</param>
            <param name="mac">The MAC to use.</param>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.Impl.TlsSuiteMac">
            <summary>Base interface for a generic TLS MAC implementation for use with a bulk cipher.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Tls.Crypto.Impl.TlsSuiteMac.Size">
            <summary>Return the output length (in bytes) of this MAC.</summary>
            <returns>The output length of this MAC.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.TlsSuiteMac.CalculateMac(System.Int64,System.Int16,System.Byte[],System.Int32,System.Int32)">
            <summary>Calculate the MAC for some given data.</summary>
            <param name="seqNo">The sequence number of the record.</param>
            <param name="type">The content type of the message.</param>
            <param name="message">A byte array containing the message.</param>
            <param name="offset">The number of bytes to skip, before the message starts.</param>
            <param name="length">The length of the message.</param>
            <returns>A new byte array containing the MAC value.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Impl.TlsSuiteMac.CalculateMacConstantTime(System.Int64,System.Int16,System.Byte[],System.Int32,System.Int32,System.Int32,System.Byte[])">
            <summary>Constant time calculation of the MAC for some given data with a given expected length.</summary>
            <param name="seqNo">The sequence number of the record.</param>
            <param name="type">The content type of the message.</param>
            <param name="message">A byte array containing the message.</param>
            <param name="offset">The number of bytes to skip, before the message starts.</param>
            <param name="length">The length of the message.</param>
            <param name="expectedLength">The expected length of the full message.</param>
            <param name="randomData">Random data for padding out the MAC calculation if required.</param>
            <returns>A new byte array containing the MAC value.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Tls.Crypto.Tls13Verifier.Stream">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.Tls13Verifier.VerifySignature(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.TlsAgreement">
            <summary>Base interface for ephemeral key agreement calculator.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsAgreement.GenerateEphemeral">
            <summary>Generate an ephemeral key pair, returning the encoding of the public key.</summary>
            <returns>a byte encoding of the public key.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsAgreement.ReceivePeerValue(System.Byte[])">
            <summary>Pass in the public key for the peer to the agreement calculator.</summary>
            <param name="peerValue">a byte encoding of the peer public key.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsAgreement.CalculateSecret">
            <summary>Calculate the agreed secret based on the calculator's current state.</summary>
            <returns>the calculated secret.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.TlsCertificate">
            <summary>Interface providing the functional representation of a single X.509 certificate.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCertificate.CreateEncryptor(System.Int32)">
            <summary>Return an encryptor based on the public key in this certificate.</summary>
            <param name="tlsCertificateRole"><see cref="T:Org.BouncyCastle.Tls.Crypto.TlsCertificateRole"/></param>
            <returns>a <see cref="T:Org.BouncyCastle.Tls.Crypto.TlsEncryptor"/> based on this certificate's public key.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCertificate.CreateVerifier(System.Int16)">
            <param name="signatureAlgorithm"><see cref="T:Org.BouncyCastle.Tls.SignatureAlgorithm"/></param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCertificate.CreateVerifier(System.Int32)">
            <param name="signatureScheme"><see cref="T:Org.BouncyCastle.Tls.SignatureScheme"/></param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCertificate.GetEncoded">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCertificate.GetExtension(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="P:Org.BouncyCastle.Tls.Crypto.TlsCertificate.SigAlgOid">
            <returns>the OID of this certificate's 'signatureAlgorithm', as a string.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCertificate.GetSigAlgParams">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCertificate.GetLegacySignatureAlgorithm">
            <returns><see cref="T:Org.BouncyCastle.Tls.SignatureAlgorithm"/></returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCertificate.SupportsSignatureAlgorithm(System.Int16)">
            <param name="signatureAlgorithm"><see cref="T:Org.BouncyCastle.Tls.SignatureAlgorithm"/></param>
            <returns>true if (and only if) this certificate can be used to verify the given signature algorithm.
            </returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCertificate.SupportsSignatureAlgorithmCA(System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCertificate.CheckUsageInRole(System.Int32)">
            <param name="tlsCertificateRole"><see cref="T:Org.BouncyCastle.Tls.Crypto.TlsCertificateRole"/></param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.TlsCipher">
            <summary>Base interface for a TLS bulk cipher.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCipher.GetCiphertextDecodeLimit(System.Int32)">
            <summary>Return the maximum input size for a ciphertext given a maximum output size for the plaintext of
            plaintextLimit bytes.</summary>
            <param name="plaintextLimit">the maximum output size for the plaintext.</param>
            <returns>the maximum input size of the ciphertext for plaintextlimit bytes of output.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCipher.GetCiphertextEncodeLimit(System.Int32,System.Int32)">
            <summary>Return the maximum output size for a ciphertext given an actual input plaintext size of
            plaintextLength bytes and a maximum input plaintext size of plaintextLimit bytes.</summary>
            <param name="plaintextLength">the actual input size for the plaintext.</param>
            <param name="plaintextLimit">the maximum input size for the plaintext.</param>
            <returns>the maximum output size of the ciphertext for plaintextlimit bytes of input.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCipher.GetPlaintextLimit(System.Int32)">
            <summary>Return the maximum size for the plaintext given ciphertextlimit bytes of ciphertext.</summary>
            <param name="ciphertextLimit">the maximum number of bytes of ciphertext.</param>
            <returns>the maximum size of the plaintext for ciphertextlimit bytes of input.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCipher.EncodePlaintext(System.Int64,System.Int16,Org.BouncyCastle.Tls.ProtocolVersion,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>Encode the passed in plaintext using the current bulk cipher.</summary>
            <param name="seqNo">sequence number of the message represented by plaintext.</param>
            <param name="contentType">content type of the message represented by plaintext.</param>
            <param name="recordVersion"><see cref="T:Org.BouncyCastle.Tls.ProtocolVersion"/> used for the record.</param>
            <param name="headerAllocation">extra bytes to allocate at start of returned byte array.</param>
            <param name="plaintext">array holding input plaintext to the cipher.</param>
            <param name="offset">offset into input array the plaintext starts at.</param>
            <param name="len">length of the plaintext in the array.</param>
            <returns>A <see cref="T:Org.BouncyCastle.Tls.Crypto.TlsEncodeResult"/> containing the result of encoding (after 'headerAllocation' unused
            bytes).</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCipher.DecodeCiphertext(System.Int64,System.Int16,Org.BouncyCastle.Tls.ProtocolVersion,System.Byte[],System.Int32,System.Int32)">
            <summary>Decode the passed in ciphertext using the current bulk cipher.</summary>
            <param name="seqNo">sequence number of the message represented by ciphertext.</param>
            <param name="recordType">content type used in the record for this message.</param>
            <param name="recordVersion"><see cref="T:Org.BouncyCastle.Tls.ProtocolVersion"/> used for the record.</param>
            <param name="ciphertext">array holding input ciphertext to the cipher.</param>
            <param name="offset">offset into input array the ciphertext starts at.</param>
            <param name="len">length of the ciphertext in the array.</param>
            <returns>A <see cref="T:Org.BouncyCastle.Tls.Crypto.TlsDecodeResult"/> containing the result of decoding.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCipher.RekeyDecoder">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCipher.RekeyEncoder">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.TlsCrypto">
            <summary>Service and object creation interface for the primitive types and services that are associated with
            cryptography in the API.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCrypto.HasAnyStreamVerifiers(System.Collections.IList)">
            <summary>Return true if this TlsCrypto would use a stream verifier for any of the passed in algorithms.
            </summary>
            <remarks>This method is only relevant to handshakes negotiating (D)TLS 1.2.</remarks>
            <param name="signatureAndHashAlgorithms">A <see cref="T:System.Collections.IList">list</see> of
            <see cref="T:Org.BouncyCastle.Tls.SignatureAndHashAlgorithm"/> values.</param>
            <returns>true if this instance would use a stream verifier for any of the passed in algorithms, otherwise
            false.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCrypto.HasAnyStreamVerifiersLegacy(System.Int16[])">
            <summary>Return true if this TlsCrypto would use a stream verifier for any of the passed in algorithms.
            </summary>
            <remarks>This method is only relevant to handshakes negotiating (D)TLS versions older than 1.2.</remarks>
            <param name="clientCertificateTypes">An array of <see cref="T:Org.BouncyCastle.Tls.ClientCertificateType"/> values.</param>
            <returns>true if this instance would use a stream verifier for any of the passed in algorithms, otherwise
            false.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCrypto.HasCryptoHashAlgorithm(System.Int32)">
            <summary>Return true if this TlsCrypto can support the passed in hash algorithm.</summary>
            <param name="cryptoHashAlgorithm">the algorithm of interest.</param>
            <returns>true if cryptoHashAlgorithm is supported, false otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCrypto.HasCryptoSignatureAlgorithm(System.Int32)">
            <summary>Return true if this TlsCrypto can support the passed in signature algorithm (not necessarily in
            combination with EVERY hash algorithm).</summary>
            <param name="cryptoSignatureAlgorithm">the algorithm of interest.</param>
            <returns>true if cryptoSignatureAlgorithm is supported, false otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCrypto.HasDHAgreement">
            <summary>Return true if this TlsCrypto can support DH key agreement.</summary>
            <returns>true if this instance can support DH key agreement, false otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCrypto.HasECDHAgreement">
            <summary>Return true if this TlsCrypto can support ECDH key agreement.</summary>
            <returns>true if this instance can support ECDH key agreement, false otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCrypto.HasEncryptionAlgorithm(System.Int32)">
            <summary>Return true if this TlsCrypto can support the passed in block/stream encryption algorithm.
            </summary>
            <param name="encryptionAlgorithm">the algorithm of interest.</param>
            <returns>true if encryptionAlgorithm is supported, false otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCrypto.HasHkdfAlgorithm(System.Int32)">
            <summary>Return true if this TlsCrypto can support HKDF with the passed in hash algorithm.</summary>
            <param name="cryptoHashAlgorithm">the algorithm of interest.</param>
            <returns>true if HKDF is supported with cryptoHashAlgorithm, false otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCrypto.HasMacAlgorithm(System.Int32)">
            <summary>Return true if this TlsCrypto can support the passed in MAC algorithm.</summary>
            <param name="macAlgorithm">the algorithm of interest.</param>
            <returns>true if macAlgorithm is supported, false otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCrypto.HasNamedGroup(System.Int32)">
            <summary>Return true if this TlsCrypto supports the passed in <see cref="T:Org.BouncyCastle.Tls.NamedGroup">named group</see>
            value.</summary>
            <returns>true if this instance supports the passed in <see cref="T:Org.BouncyCastle.Tls.NamedGroup">named group</see> value.
            </returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCrypto.HasRsaEncryption">
            <summary>Return true if this TlsCrypto can support RSA encryption/decryption.</summary>
            <returns>true if this instance can support RSA encryption/decryption, false otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCrypto.HasSignatureAlgorithm(System.Int16)">
            <summary>Return true if this TlsCrypto can support the passed in signature algorithm (not necessarily in
            combination with EVERY hash algorithm).</summary>
            <returns>true if signatureAlgorithm is supported, false otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCrypto.HasSignatureAndHashAlgorithm(Org.BouncyCastle.Tls.SignatureAndHashAlgorithm)">
            <summary>Return true if this TlsCrypto can support the passed in signature algorithm.</summary>
            <param name="sigAndHashAlgorithm">the algorithm of interest.</param>
            <returns>true if sigAndHashAlgorithm is supported, false otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCrypto.HasSignatureScheme(System.Int32)">
            <summary>Return true if this TlsCrypto can support the passed in signature scheme.</summary>
            <param name="signatureScheme">the scheme of interest.</param>
            <returns>true if signatureScheme is supported, false otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCrypto.CreateSecret(System.Byte[])">
            <summary>Create a TlsSecret object based on provided data.</summary>
            <param name="data">the data to base the TlsSecret on.</param>
            <returns>a TlsSecret based on the provided data.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCrypto.GenerateRsaPreMasterSecret(Org.BouncyCastle.Tls.ProtocolVersion)">
            <summary>Create a TlsSecret object containing a randomly-generated RSA PreMasterSecret</summary>
            <param name="clientVersion">the client version to place in the first 2 bytes</param>
            <returns>a TlsSecret containing the PreMasterSecret.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Tls.Crypto.TlsCrypto.SecureRandom">
            <summary>Return the primary (safest) SecureRandom for this crypto.</summary>
            <returns>a SecureRandom suitable for key generation.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCrypto.CreateCertificate(System.Byte[])">
            <summary>Create a TlsCertificate from an ASN.1 binary encoding of an X.509 certificate.</summary>
            <param name="encoding">DER/BER encoding of the certificate of interest.</param>
            <returns>a TlsCertificate.</returns>
            <exception cref="T:System.IO.IOException">if there is an issue on decoding or constructing the certificate.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCrypto.CreateCipher(Org.BouncyCastle.Tls.Crypto.TlsCryptoParameters,System.Int32,System.Int32)">
            <summary>Create a cipher for the specified encryption and MAC algorithms.</summary>
            <remarks>
            See enumeration classes <see cref="T:Org.BouncyCastle.Tls.EncryptionAlgorithm"/>, <see cref="T:Org.BouncyCastle.Tls.MacAlgorithm"/> for appropriate
            argument values.
            </remarks>
            <param name="cryptoParams">context specific parameters.</param>
            <param name="encryptionAlgorithm">the encryption algorithm to be employed by the cipher.</param>
            <param name="macAlgorithm">the MAC algorithm to be employed by the cipher.</param>
            <returns>a <see cref="T:Org.BouncyCastle.Tls.Crypto.TlsCipher"/> implementing the encryption and MAC algorithms.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCrypto.CreateDHDomain(Org.BouncyCastle.Tls.Crypto.TlsDHConfig)">
            <summary>Create a domain object supporting the domain parameters described in dhConfig.</summary>
            <param name="dhConfig">the config describing the DH parameters to use.</param>
            <returns>a TlsDHDomain supporting the parameters in dhConfig.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCrypto.CreateECDomain(Org.BouncyCastle.Tls.Crypto.TlsECConfig)">
            <summary>Create a domain object supporting the domain parameters described in ecConfig.</summary>
            <param name="ecConfig">the config describing the EC parameters to use.</param>
            <returns>a TlsECDomain supporting the parameters in ecConfig.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCrypto.AdoptSecret(Org.BouncyCastle.Tls.Crypto.TlsSecret)">
            <summary>Adopt the passed in secret, creating a new copy of it.</summary>
            <param name="secret">the secret to make a copy of.</param>
            <returns>a TlsSecret based on the original secret.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCrypto.CreateHash(System.Int32)">
            <summary>Create a suitable hash for the hash algorithm identifier passed in.</summary>
            <remarks>
            See enumeration class <see cref="T:Org.BouncyCastle.Tls.Crypto.CryptoHashAlgorithm"/> for appropriate argument values.
            </remarks>
            <param name="cryptoHashAlgorithm">the hash algorithm the hash needs to implement.</param>
            <returns>a <see cref="T:Org.BouncyCastle.Tls.Crypto.TlsHash"/>.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCrypto.CreateHmac(System.Int32)">
            <summary>Create a suitable HMAC for the MAC algorithm identifier passed in.</summary>
            <remarks>
            See enumeration class <see cref="T:Org.BouncyCastle.Tls.MacAlgorithm"/> for appropriate argument values.
            </remarks>
            <param name="macAlgorithm">the MAC algorithm the HMAC needs to match.</param>
            <returns>a <see cref="T:Org.BouncyCastle.Tls.Crypto.TlsHmac"/>.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCrypto.CreateHmacForHash(System.Int32)">
            <summary>Create a suitable HMAC using the hash algorithm identifier passed in.</summary>
            <remarks>
            See enumeration class <see cref="T:Org.BouncyCastle.Tls.Crypto.CryptoHashAlgorithm"/> for appropriate argument values.
            </remarks>
            <param name="cryptoHashAlgorithm">the hash algorithm the HMAC should use.</param>
            <returns>a <see cref="T:Org.BouncyCastle.Tls.Crypto.TlsHmac"/>.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCrypto.CreateNonceGenerator(System.Byte[])">
            <summary>Create a nonce generator.</summary>
            <remarks>
            Each call should construct a new generator, and the generator should be returned from this call only after
            automatically seeding from this <see cref="T:Org.BouncyCastle.Tls.Crypto.TlsCrypto"/>'s entropy source, and from the provided additional
            seed material. The output of each returned generator must be completely independent of the others.
            </remarks>
            <param name="additionalSeedMaterial">context-specific seed material</param>
            <returns>a <see cref="T:Org.BouncyCastle.Tls.Crypto.TlsNonceGenerator"/>.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCrypto.HkdfInit(System.Int32)">
            <summary>Setup an initial "secret" for a chain of HKDF calls (RFC 5869), containing a string of HashLen
            zeroes.</summary>
            <param name="cryptoHashAlgorithm">the hash algorithm to instantiate HMAC with. See
            <see cref="T:Org.BouncyCastle.Tls.Crypto.CryptoHashAlgorithm"/> for values.</param>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.TlsCryptoException">
            <summary>Basic exception class for crypto services to pass back a cause.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.TlsCryptoParameters">
            <summary>Carrier class for context-related parameters needed for creating secrets and ciphers.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCryptoParameters.#ctor(Org.BouncyCastle.Tls.TlsContext)">
            <summary>Base constructor.</summary>
            <param name="context">the context for this parameters object.</param>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsCryptoUtilities.HkdfExpandLabel(Org.BouncyCastle.Tls.Crypto.TlsSecret,System.Int32,System.String,System.Byte[],System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.TlsDHConfig">
            <summary>Basic config for Diffie-Hellman.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.TlsDHDomain">
            <summary>Domain interface to service factory for creating Diffie-Hellman operators.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsDHDomain.CreateDH">
            <summary>Return an agreement operator suitable for ephemeral Diffie-Hellman.</summary>
            <returns>a key agreement operator.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.TlsECConfig">
            <summary>Carrier class for Elliptic Curve parameter configuration.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Tls.Crypto.TlsECConfig.NamedGroup">
            <summary>Return the group used.</summary>
            <returns>the <see cref="P:Org.BouncyCastle.Tls.Crypto.TlsECConfig.NamedGroup">named group</see> used.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.TlsECDomain">
            <summary>Domain interface to service factory for creating Elliptic-Curve (EC) based operators.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsECDomain.CreateECDH">
            <summary>Return an agreement operator suitable for ephemeral EC Diffie-Hellman.</summary>
            <returns>a key agreement operator.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.TlsEncryptor">
            <summary>Base interface for an encryptor.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsEncryptor.Encrypt(System.Byte[])">
            <summary>Encrypt data from the passed in input array.</summary>
            <param name="input">byte array containing the input data.</param>
            <returns>the encrypted data.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.TlsHash">
            <summary>Interface for message digest, or hash, services.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsHash.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>Update the hash with the passed in input.</summary>
            <param name="input">input array containing the data.</param>
            <param name="inOff">offset into the input array the input starts at.</param>
            <param name="length">the length of the input data.</param>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsHash.CalculateHash">
            <summary>Return calculated hash for any input passed in.</summary>
            <returns>the hash value.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsHash.Reset">
            <summary>Reset the hash underlying this service.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.TlsHmac">
            <summary>Interface for MAC services based on HMAC.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Tls.Crypto.TlsHmac.InternalBlockSize">
            <summary>Return the internal block size for the message digest underlying this HMAC service.</summary>
            <returns>the internal block size for the digest (in bytes).</returns>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.TlsMac">
            <summary>Interface for MAC services.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsMac.SetKey(System.Byte[],System.Int32,System.Int32)">
            <summary>Set the key to be used by the MAC implementation supporting this service.</summary>
            <param name="key">array holding the MAC key.</param>
            <param name="keyOff">offset into the array the key starts at.</param>
            <param name="keyLen">length of the key in the array.</param>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsMac.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>Update the MAC with the passed in input.</summary>
            <param name="input">input array containing the data.</param>
            <param name="inOff">offset into the input array the input starts at.</param>
            <param name="length">the length of the input data.</param>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsMac.CalculateMac">
            <summary>Return calculated MAC for any input passed in.</summary>
            <returns>the MAC value.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsMac.CalculateMac(System.Byte[],System.Int32)">
            <summary>Write the calculated MAC to an output buffer.</summary>
            <param name="output">output array to write the MAC to.</param>
            <param name="outOff">offset into the output array to write the MAC to.</param>
        </member>
        <member name="P:Org.BouncyCastle.Tls.Crypto.TlsMac.MacLength">
            <summary>Return the length of the MAC generated by this service.</summary>
            <returns>the MAC length.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsMac.Reset">
            <summary>Reset the MAC underlying this service.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsNonceGenerator.GenerateNonce(System.Int32)">
            <summary>Generate a nonce byte[] string.</summary>
            <param name="size">the length, in bytes, of the nonce to generate.</param>
            <returns>the nonce value.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.TlsNullNullCipher">
            <summary>The cipher for TLS_NULL_WITH_NULL_NULL.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.TlsSecret">
            <summary>Interface supporting the generation of key material and other TLS secret values from PRFs.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsSecret.CalculateHmac(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>Calculate an HMAC with this secret's data as the key.</summary>
            <param name="cryptoHashAlgorithm">the hash algorithm to instantiate HMAC with. See
            <see cref="T:Org.BouncyCastle.Tls.Crypto.CryptoHashAlgorithm"/> for values.</param>
            <param name="buf">array containing the input data.</param>
            <param name="off">offset into the input array the input starts at.</param>
            <param name="len">the length of the input data.</param>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsSecret.DeriveUsingPrf(System.Int32,System.String,System.Byte[],System.Int32)">
            <summary>Return a new secret based on applying a PRF to this one.</summary>
            <param name="prfAlgorithm">PRF algorithm to use.</param>
            <param name="label">the label details.</param>
            <param name="seed">the seed details.</param>
            <param name="length">the size (in bytes) of the secret to generate.</param>
            <returns>the new secret.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsSecret.Destroy">
            <summary>Destroy the internal state of the secret.</summary>
            <remarks>
            After this call, any attempt to use the <see cref="T:Org.BouncyCastle.Tls.Crypto.TlsSecret"/> will result in an
            <see cref="T:System.InvalidOperationException"/> being thrown.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsSecret.Encrypt(Org.BouncyCastle.Tls.Crypto.TlsEncryptor)">
            <summary>Return an encrypted copy of the data this secret is based on.</summary>
            <param name="encryptor">the encryptor to use for protecting the internal data.</param>
            <returns>an encrypted copy of this secret's internal data.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsSecret.Extract">
            <summary>Return the internal data from this secret.</summary>
            <remarks>
            The <see cref="T:Org.BouncyCastle.Tls.Crypto.TlsSecret"/> does not keep a copy of the data. After this call, any attempt to use the
            <see cref="T:Org.BouncyCastle.Tls.Crypto.TlsSecret"/> will result in an <see cref="T:System.InvalidOperationException"/> being thrown.
            </remarks>
            <returns>the secret's internal data.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsSecret.HkdfExpand(System.Int32,System.Byte[],System.Int32)">
            <summary>RFC 5869 HKDF-Expand function, with this secret's data as the pseudo-random key ('prk').</summary>
            <param name="cryptoHashAlgorithm">the hash algorithm to instantiate HMAC with. See
            <see cref="T:Org.BouncyCastle.Tls.Crypto.CryptoHashAlgorithm"/> for values.</param>
            <param name="info">optional context and application specific information (can be zero-length).</param>
            <param name="length">length of output keying material in octets.</param>
            <returns> output keying material (of 'length' octets).</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsSecret.HkdfExtract(System.Int32,Org.BouncyCastle.Tls.Crypto.TlsSecret)">
            <summary>RFC 5869 HKDF-Extract function, with this secret's data as the 'salt'.</summary>
            <remarks>
            The <see cref="T:Org.BouncyCastle.Tls.Crypto.TlsSecret"/> does not keep a copy of the data. After this call, any attempt to use
            the <see cref="T:Org.BouncyCastle.Tls.Crypto.TlsSecret"/> will result in an <see cref="T:System.InvalidOperationException"/> being thrown.
            </remarks>
            <param name="cryptoHashAlgorithm">the hash algorithm to instantiate HMAC with. See
            <see cref="T:Org.BouncyCastle.Tls.Crypto.CryptoHashAlgorithm"/> for values.</param>
            <param name="ikm">input keying material.</param>
            <returns>a pseudo-random key (of HashLen octets).</returns>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.TlsSigner">
            <summary>Base interface for a TLS signer that works on raw message digests.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsSigner.GenerateRawSignature(Org.BouncyCastle.Tls.SignatureAndHashAlgorithm,System.Byte[])">
            <summary>Generate an encoded signature based on the passed in hash.</summary>
            <param name="algorithm">the signature algorithm to use.</param>
            <param name="hash">the hash calculated for the signature.</param>
            <returns>an encoded signature.</returns>
            <exception cref="T:System.IO.IOException">in case of an exception processing the hash.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsSigner.GetStreamSigner(Org.BouncyCastle.Tls.SignatureAndHashAlgorithm)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="P:Org.BouncyCastle.Tls.Crypto.TlsStreamSigner.Stream">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsStreamSigner.GetSignature">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="P:Org.BouncyCastle.Tls.Crypto.TlsStreamVerifier.Stream">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsStreamVerifier.IsVerified">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.Crypto.TlsVerifier">
            <summary>Base interface for a TLS verifier that works with signatures and either raw message digests, or entire
            messages.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsVerifier.GetStreamVerifier(Org.BouncyCastle.Tls.DigitallySigned)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.Crypto.TlsVerifier.VerifyRawSignature(Org.BouncyCastle.Tls.DigitallySigned,System.Byte[])">
            <summary>Return true if the passed in signature and hash represent a real signature.</summary>
            <param name="digitallySigned">the signature object containing the signature to be verified.</param>
            <param name="hash">the hash calculated for the signature.</param>
            <returns>true if signature verifies, false otherwise.</returns>
            <exception cref="T:System.IO.IOException">in case of an exception verifying signature.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DatagramReceiver.GetReceiveLimit">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DatagramReceiver.Receive(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DatagramSender.GetSendLimit">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DatagramSender.Send(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.DatagramTransport">
            <summary>Base interface for an object sending and receiving DTLS data.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.DefaultTlsCredentialedSigner">
            <summary>Container class for generating signatures that carries the signature type, parameters, public key
            certificate and public key's associated signer object.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DefaultTlsDHGroupVerifier.#ctor">
            <summary>Accept named groups and various standard DH groups with 'P' at least
            <see cref="F:Org.BouncyCastle.Tls.DefaultTlsDHGroupVerifier.DefaultMinimumPrimeBits"/> bits.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DefaultTlsDHGroupVerifier.#ctor(System.Int32)">
            <summary>Accept named groups and various standard DH groups with 'P' at least the specified number of bits.
            </summary>
            <param name="minimumPrimeBits">the minimum bitlength of 'P'.</param>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DefaultTlsDHGroupVerifier.#ctor(System.Collections.IList,System.Int32)">
            <summary>Accept named groups and a custom set of group parameters, subject to a minimum bitlength for 'P'.
            </summary>
            <param name="groups">a <see cref="T:System.Collections.IList">list</see> of acceptable <see cref="T:Org.BouncyCastle.Tls.Crypto.DHGroup"/>s.</param>
            <param name="minimumPrimeBits">the minimum bitlength of 'P'.</param>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DefaultTlsServer.GetDsaSignerCredentials">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DefaultTlsServer.GetECDsaSignerCredentials">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DefaultTlsServer.GetRsaEncryptionCredentials">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DefaultTlsServer.GetRsaSignerCredentials">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.DeferredHash">
            <summary>Buffers input until the hash algorithm is determined.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DeferredHash.CopyBufferTo(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DigestInputBuffer.CopyInputTo(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="P:Org.BouncyCastle.Tls.DigitallySigned.Algorithm">
            <returns>a <see cref="T:Org.BouncyCastle.Tls.SignatureAndHashAlgorithm"/> (or null before TLS 1.2).</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DigitallySigned.Encode(System.IO.Stream)">
            <summary>Encode this <see cref="T:Org.BouncyCastle.Tls.DigitallySigned"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DigitallySigned.Parse(Org.BouncyCastle.Tls.TlsContext,System.IO.Stream)">
            <summary>Parse a <see cref="T:Org.BouncyCastle.Tls.DigitallySigned"/> from a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="context">the <see cref="T:Org.BouncyCastle.Tls.TlsContext"/> of the current connection.</param>
            <param name="input">the <see cref="T:System.IO.Stream"/> to parse from.</param>
            <returns>a <see cref="T:Org.BouncyCastle.Tls.DigitallySigned"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsClientProtocol.Connect(Org.BouncyCastle.Tls.TlsClient,Org.BouncyCastle.Tls.DatagramTransport)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsClientProtocol.ClientHandshake(Org.BouncyCastle.Tls.DtlsClientProtocol.ClientHandshakeState,Org.BouncyCastle.Tls.DtlsRecordLayer)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsClientProtocol.GenerateCertificateVerify(Org.BouncyCastle.Tls.DtlsClientProtocol.ClientHandshakeState,Org.BouncyCastle.Tls.DigitallySigned)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsClientProtocol.GenerateClientHello(Org.BouncyCastle.Tls.DtlsClientProtocol.ClientHandshakeState)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsClientProtocol.GenerateClientKeyExchange(Org.BouncyCastle.Tls.DtlsClientProtocol.ClientHandshakeState)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsClientProtocol.ProcessCertificateRequest(Org.BouncyCastle.Tls.DtlsClientProtocol.ClientHandshakeState,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsClientProtocol.ProcessCertificateStatus(Org.BouncyCastle.Tls.DtlsClientProtocol.ClientHandshakeState,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsClientProtocol.ProcessHelloVerifyRequest(Org.BouncyCastle.Tls.DtlsClientProtocol.ClientHandshakeState,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsClientProtocol.ProcessNewSessionTicket(Org.BouncyCastle.Tls.DtlsClientProtocol.ClientHandshakeState,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsClientProtocol.ProcessServerCertificate(Org.BouncyCastle.Tls.DtlsClientProtocol.ClientHandshakeState,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsClientProtocol.ProcessServerHello(Org.BouncyCastle.Tls.DtlsClientProtocol.ClientHandshakeState,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsClientProtocol.ProcessServerKeyExchange(Org.BouncyCastle.Tls.DtlsClientProtocol.ClientHandshakeState,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsClientProtocol.ProcessServerSupplementalData(Org.BouncyCastle.Tls.DtlsClientProtocol.ClientHandshakeState,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsClientProtocol.ReportServerVersion(Org.BouncyCastle.Tls.DtlsClientProtocol.ClientHandshakeState,Org.BouncyCastle.Tls.ProtocolVersion)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsClientProtocol.PatchClientHelloWithCookie(System.Byte[],System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsEpoch.AllocateSequenceNumber">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsHandshakeRetransmit.ReceivedHandshakeRecord(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsProtocol.ProcessFinished(System.Byte[],System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsProtocol.ApplyMaxFragmentLengthExtension(Org.BouncyCastle.Tls.DtlsRecordLayer,System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsProtocol.EvaluateMaxFragmentLengthExtension(System.Boolean,System.Collections.IDictionary,System.Collections.IDictionary,System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsProtocol.GenerateCertificate(Org.BouncyCastle.Tls.TlsContext,Org.BouncyCastle.Tls.Certificate,System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsProtocol.GenerateSupplementalData(System.Collections.IList)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsProtocol.SendCertificateMessage(Org.BouncyCastle.Tls.TlsContext,Org.BouncyCastle.Tls.DtlsReliableHandshake,Org.BouncyCastle.Tls.Certificate,System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsProtocol.ValidateSelectedCipherSuite(System.Int32,System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsRecordLayer.ReceiveClientHelloRecord(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsRecordLayer.SendHelloVerifyRequestRecord(Org.BouncyCastle.Tls.DatagramSender,System.Int64,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsRecordLayer.SendDatagram(Org.BouncyCastle.Tls.DatagramSender,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsRecordLayer.GetReceiveLimit">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsRecordLayer.GetSendLimit">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsRecordLayer.Receive(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsRecordLayer.Send(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsRecordLayer.Close">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsRecordLayer.Warn(System.Int16,System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsRecordLayer.RaiseAlert(System.Int16,System.Int16,System.String,System.Exception)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsRecordLayer.ReceiveDatagram(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsRecordLayer.ProcessRecord(System.Int32,System.Byte[],System.Byte[],System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsRecordLayer.ReceiveRecord(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsRecordLayer.SendHeartbeatMessage(Org.BouncyCastle.Tls.HeartbeatMessage)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsRecordLayer.SendRecord(System.Int16,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsReliableHandshake.ReadClientRequest(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsReliableHandshake.SendHelloVerifyRequest(Org.BouncyCastle.Tls.DatagramSender,System.Int64,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsReliableHandshake.SendMessage(System.Int16,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsReliableHandshake.ReceiveMessage">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsReliableHandshake.ReceiveMessageBody(System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsReliableHandshake.ReceiveMessageDelayedDigest(System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsReliableHandshake.UpdateHandshakeMessagesDigest(Org.BouncyCastle.Tls.DtlsReliableHandshake.Message)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsReliableHandshake.CheckInboundFlight">
            Check that there are no "extra" messages left in the current inbound flight
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsReliableHandshake.GetPendingMessage">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsReliableHandshake.ImplReceiveMessage">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsReliableHandshake.ProcessRecord(System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsReliableHandshake.ResendOutboundFlight">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsReliableHandshake.WriteMessage(Org.BouncyCastle.Tls.DtlsReliableHandshake.Message)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsReliableHandshake.WriteHandshakeFragment(Org.BouncyCastle.Tls.DtlsReliableHandshake.Message,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.DtlsReplayWindow">
            RFC 4347 4.1.2.5 Anti-replay
            <p>
            Support fast rejection of duplicate records by maintaining a sliding receive window
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsReplayWindow.ShouldDiscard(System.Int64)">
            <summary>Check whether a received record with the given sequence number should be rejected as a duplicate.
            </summary>
            <param name="seq">the 48-bit DTLSPlainText.sequence_number field of a received record.</param>
            <returns>true if the record should be discarded without further processing.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsReplayWindow.ReportAuthenticated(System.Int64)">
            <summary>Report that a received record with the given sequence number passed authentication checks.
            </summary>
            <param name="seq">the 48-bit DTLSPlainText.sequence_number field of an authenticated record.</param>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsServerProtocol.Accept(Org.BouncyCastle.Tls.TlsServer,Org.BouncyCastle.Tls.DatagramTransport)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsServerProtocol.Accept(Org.BouncyCastle.Tls.TlsServer,Org.BouncyCastle.Tls.DatagramTransport,Org.BouncyCastle.Tls.DtlsRequest)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsServerProtocol.ServerHandshake(Org.BouncyCastle.Tls.DtlsServerProtocol.ServerHandshakeState,Org.BouncyCastle.Tls.DtlsRecordLayer,Org.BouncyCastle.Tls.DtlsRequest)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsServerProtocol.GenerateCertificateRequest(Org.BouncyCastle.Tls.DtlsServerProtocol.ServerHandshakeState,Org.BouncyCastle.Tls.CertificateRequest)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsServerProtocol.GenerateCertificateStatus(Org.BouncyCastle.Tls.DtlsServerProtocol.ServerHandshakeState,Org.BouncyCastle.Tls.CertificateStatus)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsServerProtocol.GenerateNewSessionTicket(Org.BouncyCastle.Tls.DtlsServerProtocol.ServerHandshakeState,Org.BouncyCastle.Tls.NewSessionTicket)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsServerProtocol.GenerateServerHello(Org.BouncyCastle.Tls.DtlsServerProtocol.ServerHandshakeState,Org.BouncyCastle.Tls.DtlsRecordLayer)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsServerProtocol.NotifyClientCertificate(Org.BouncyCastle.Tls.DtlsServerProtocol.ServerHandshakeState,Org.BouncyCastle.Tls.Certificate)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsServerProtocol.ProcessClientCertificate(Org.BouncyCastle.Tls.DtlsServerProtocol.ServerHandshakeState,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsServerProtocol.ProcessCertificateVerify(Org.BouncyCastle.Tls.DtlsServerProtocol.ServerHandshakeState,System.Byte[],Org.BouncyCastle.Tls.TlsHandshakeHash)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsServerProtocol.ProcessClientHello(Org.BouncyCastle.Tls.DtlsServerProtocol.ServerHandshakeState,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsServerProtocol.ProcessClientHello(Org.BouncyCastle.Tls.DtlsServerProtocol.ServerHandshakeState,Org.BouncyCastle.Tls.ClientHello)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsServerProtocol.ProcessClientKeyExchange(Org.BouncyCastle.Tls.DtlsServerProtocol.ServerHandshakeState,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsServerProtocol.ProcessClientSupplementalData(Org.BouncyCastle.Tls.DtlsServerProtocol.ServerHandshakeState,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsTransport.GetReceiveLimit">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsTransport.GetSendLimit">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsTransport.Receive(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsTransport.Send(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.DtlsTransport.Close">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.ECCurveType">
            <summary>RFC 4492 5.4</summary>
        </member>
        <member name="F:Org.BouncyCastle.Tls.ECCurveType.explicit_prime">
            Indicates the elliptic curve domain parameters are conveyed verbosely, and the
            underlying finite field is a prime field.
        </member>
        <member name="F:Org.BouncyCastle.Tls.ECCurveType.explicit_char2">
            Indicates the elliptic curve domain parameters are conveyed verbosely, and the
            underlying finite field is a characteristic-2 field.
        </member>
        <member name="F:Org.BouncyCastle.Tls.ECCurveType.named_curve">
            Indicates that a named curve is used. This option SHOULD be used when applicable.
        </member>
        <member name="T:Org.BouncyCastle.Tls.ECPointFormat">
            <summary>RFC 4492 5.1.2</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.EncryptionAlgorithm">
            <summary>RFC 2246</summary>
            <remarks>
            Note that the values here are implementation-specific and arbitrary. It is recommended not to depend on the
            particular values (e.g. serialization).
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Tls.ExporterLabel">
            <summary>RFC 5705</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.HandshakeMessageOutput.Send(Org.BouncyCastle.Tls.TlsProtocol,System.Int16,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.HandshakeMessageOutput.#ctor(System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.HandshakeMessageOutput.#ctor(System.Int16,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.HandshakeMessageOutput.Send(Org.BouncyCastle.Tls.TlsProtocol)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.HashAlgorithm">
            <summary>RFC 5246 7.4.1.4.1</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.HeartbeatExtension.Encode(System.IO.Stream)">
            <summary>Encode this <see cref="T:Org.BouncyCastle.Tls.HeartbeatExtension"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.HeartbeatExtension.Parse(System.IO.Stream)">
            <summary>Parse a <see cref="T:Org.BouncyCastle.Tls.HeartbeatExtension"/> from a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="input">the <see cref="T:System.IO.Stream"/> to parse from.</param>
            <returns>a <see cref="T:Org.BouncyCastle.Tls.HeartbeatExtension"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.HeartbeatMessage.Encode(System.IO.Stream)">
            <summary>Encode this <see cref="T:Org.BouncyCastle.Tls.HeartbeatMessage"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.HeartbeatMessage.Parse(System.IO.Stream)">
            <summary>Parse a <see cref="T:Org.BouncyCastle.Tls.HeartbeatMessage"/> from a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="input">the <see cref="T:System.IO.Stream"/> to parse from.</param>
            <returns>a <see cref="T:Org.BouncyCastle.Tls.HeartbeatMessage"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.HeartbeatMessageType">
            <summary>RFC 6520 3.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.IdentifierType">
            <summary>RFC 6066</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.KeyExchangeAlgorithm">
            <summary>RFC 2246</summary>
            <remarks>
            Note that the values here are implementation-specific and arbitrary. It is recommended not to depend on the
            particular values (e.g. serialization).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Tls.KeyShareEntry.#ctor(System.Int32,System.Byte[])">
            <param name="namedGroup"><see cref="P:Org.BouncyCastle.Tls.KeyShareEntry.NamedGroup"/></param>
            <param name="keyExchange"></param>
        </member>
        <member name="P:Org.BouncyCastle.Tls.KeyShareEntry.NamedGroup">
            <returns><see cref="P:Org.BouncyCastle.Tls.KeyShareEntry.NamedGroup"/></returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.KeyShareEntry.Encode(System.IO.Stream)">
            <summary>Encode this <see cref="T:Org.BouncyCastle.Tls.KeyShareEntry"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.KeyShareEntry.Parse(System.IO.Stream)">
            <summary>Parse a <see cref="T:Org.BouncyCastle.Tls.KeyShareEntry"/> from a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="input">the <see cref="T:System.IO.Stream"/> to parse from.</param>
            <returns>a <see cref="T:Org.BouncyCastle.Tls.KeyShareEntry"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.KeyUpdateRequest">
            <summary>RFC 8446 4.6.3</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.MacAlgorithm">
            <summary>RFC 2246</summary>
            <remarks>
            Note that the values here are implementation-specific and arbitrary. It is recommended not to depend on the
            particular values (e.g. serialization).
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Tls.NamedGroup">
            <summary>RFC 7919</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.NamedGroupRole">
            <remarks>
            Note that the values here are implementation-specific and arbitrary. It is recommended not to depend on the
            particular values (e.g. serialization).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Tls.NewSessionTicket.Encode(System.IO.Stream)">
            <summary>Encode this <see cref="T:Org.BouncyCastle.Tls.NewSessionTicket"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.NewSessionTicket.Parse(System.IO.Stream)">
            <summary>Parse a <see cref="T:Org.BouncyCastle.Tls.NewSessionTicket"/> from a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="input">the <see cref="T:System.IO.Stream"/> to parse from.</param>
            <returns>a <see cref="T:Org.BouncyCastle.Tls.NewSessionTicket"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.OcspStatusRequest">
            <summary>RFC 3546 3.6</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.OcspStatusRequest.#ctor(System.Collections.IList,Org.BouncyCastle.Asn1.X509.X509Extensions)">
            <param name="responderIDList">an <see cref="T:System.Collections.IList"/> of <see cref="T:Org.BouncyCastle.Asn1.Ocsp.ResponderID"/>, specifying the list of
            trusted OCSP responders. An empty list has the special meaning that the responders are implicitly known to
            the server - e.g., by prior arrangement.</param>
            <param name="requestExtensions">OCSP request extensions. A null value means that there are no extensions.
            </param>
        </member>
        <member name="P:Org.BouncyCastle.Tls.OcspStatusRequest.ResponderIDList">
            <returns>an <see cref="T:System.Collections.IList"/> of <see cref="T:Org.BouncyCastle.Asn1.Ocsp.ResponderID"/>.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Tls.OcspStatusRequest.RequestExtensions">
            <returns>OCSP request extensions.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.OcspStatusRequest.Encode(System.IO.Stream)">
            <summary>Encode this <see cref="T:Org.BouncyCastle.Tls.OcspStatusRequest"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.OcspStatusRequest.Parse(System.IO.Stream)">
            <summary>Parse an <see cref="T:Org.BouncyCastle.Tls.OcspStatusRequest"/> from a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="input">the <see cref="T:System.IO.Stream"/> to parse from.</param>
            <returns>an <see cref="T:Org.BouncyCastle.Tls.OcspStatusRequest"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.OfferedPsks.Encode(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.OfferedPsks.EncodeBinders(System.IO.Stream,Org.BouncyCastle.Tls.Crypto.TlsCrypto,Org.BouncyCastle.Tls.TlsHandshakeHash,Org.BouncyCastle.Tls.OfferedPsks.BindersConfig)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.OfferedPsks.GetBindersSize(Org.BouncyCastle.Tls.TlsPsk[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.OfferedPsks.Parse(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.PrfAlgorithm">
            <summary>RFC 5246</summary>
            <remarks>
            Note that the values here are implementation-specific and arbitrary. It is recommended not to depend on the
            particular values (e.g. serialization).
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Tls.ProtocolName">
            <summary>RFC 7301 Represents a protocol name for use with ALPN.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.ProtocolName.Encode(System.IO.Stream)">
            <summary>Encode this <see cref="T:Org.BouncyCastle.Tls.ProtocolName"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.ProtocolName.Parse(System.IO.Stream)">
            <summary>Parse a <see cref="T:Org.BouncyCastle.Tls.ProtocolName"/> from a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="input">the <see cref="T:System.IO.Stream"/> to parse from.</param>
            <returns>a <see cref="T:Org.BouncyCastle.Tls.ProtocolName"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.PskTlsClient.GetAuthentication">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.PskTlsServer.GetRsaEncryptionCredentials">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.RecordStream">
            <summary>An implementation of the TLS 1.0/1.1/1.2 record layer.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.RecordStream.NotifyChangeCipherSpecReceived">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.RecordStream.EnablePendingCipherRead(System.Boolean)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.RecordStream.EnablePendingCipherWrite">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.RecordStream.FinaliseHandshake">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.RecordStream.NotifyKeyUpdateReceived">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.RecordStream.NotifyKeyUpdateSent">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.RecordStream.PreviewRecordHeader(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.RecordStream.ReadFullRecord(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.RecordStream.ReadRecord">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.RecordStream.DecodeAndVerify(System.Int16,Org.BouncyCastle.Tls.ProtocolVersion,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.RecordStream.WriteRecord(System.Int16,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.RecordStream.Close">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.RecordStream.CheckChangeCipherSpec(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.RecordStream.CheckRecordType(System.Byte[],System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.RecordStream.CheckLength(System.Int32,System.Int32,System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.RecordStream.Record.FillTo(System.IO.Stream,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.RecordStream.Record.ReadFragment(System.IO.Stream,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.RecordStream.Record.ReadHeader(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.RecordStream.SequenceNumber.NextValue(System.Int16)">
            <exception cref="T:Org.BouncyCastle.Tls.TlsFatalAlert"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.ServerHello.Encode(Org.BouncyCastle.Tls.TlsContext,System.IO.Stream)">
            <summary>Encode this <see cref="T:Org.BouncyCastle.Tls.ServerHello"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="context">the <see cref="T:Org.BouncyCastle.Tls.TlsContext"/> of the current connection.</param>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.ServerHello.Parse(System.IO.MemoryStream)">
            <summary>Parse a <see cref="T:Org.BouncyCastle.Tls.ServerHello"/> from a <see cref="T:System.IO.MemoryStream"/>.</summary>
            <param name="input">the <see cref="T:System.IO.MemoryStream"/> to parse from.</param>
            <returns>a <see cref="T:Org.BouncyCastle.Tls.ServerHello"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.ServerName">
            <summary>RFC 6066 3. Server Name Indication</summary>
            <remarks>
            Current implementation uses this guidance: "For backward compatibility, all future data structures associated
            with new NameTypes MUST begin with a 16-bit length field. TLS MAY treat provided server names as opaque data
            and pass the names and types to the application.". RFC 6066 specifies ASCII encoding for host_name (possibly
            using A-labels for IDNs), but note that the previous version (RFC 4366) specified UTF-8 encoding (see RFC 6066
            Appendix A). For maximum compatibility, it is recommended that client code tolerate receiving UTF-8 from the
            peer, but only generate ASCII itself.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Tls.ServerName.Encode(System.IO.Stream)">
            <summary>Encode this <see cref="T:Org.BouncyCastle.Tls.ServerName"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.ServerName.Parse(System.IO.Stream)">
            <summary>Parse a <see cref="T:Org.BouncyCastle.Tls.ServerName"/> from a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="input">the <see cref="T:System.IO.Stream"/> to parse from.</param>
            <returns>a <see cref="T:Org.BouncyCastle.Tls.ServerName"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.ServerNameList.#ctor(System.Collections.IList)">
            <param name="serverNameList">an <see cref="T:System.Collections.IList"/> of <see cref="T:Org.BouncyCastle.Tls.ServerName"/>.</param>
        </member>
        <member name="P:Org.BouncyCastle.Tls.ServerNameList.ServerNames">
            <returns>an <see cref="T:System.Collections.IList"/> of <see cref="T:Org.BouncyCastle.Tls.ServerName"/>.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.ServerNameList.Encode(System.IO.Stream)">
            <summary>Encode this <see cref="T:Org.BouncyCastle.Tls.ServerNameList"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to .</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.ServerNameList.Parse(System.IO.Stream)">
            <summary>Parse a <see cref="T:Org.BouncyCastle.Tls.ServerNameList"/> from a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="input">the <see cref="T:System.IO.Stream"/> to parse from.</param>
            <returns>a <see cref="T:Org.BouncyCastle.Tls.ServerNameList"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.SessionParameters.Builder.SetServerExtensions(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.SessionParameters.ReadServerExtensions">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.SignatureAlgorithm">
            RFC 5246 7.4.1.4.1 (in RFC 2246, there were no specific values assigned)
        </member>
        <member name="T:Org.BouncyCastle.Tls.SignatureAndHashAlgorithm">
            <summary>RFC 5246 7.4.1.4.1</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.SignatureAndHashAlgorithm.#ctor(System.Int16,System.Int16)">
            <param name="hash"><see cref="T:Org.BouncyCastle.Tls.HashAlgorithm"/></param>
            <param name="signature"><see cref="T:Org.BouncyCastle.Tls.SignatureAlgorithm"/></param>
        </member>
        <member name="P:Org.BouncyCastle.Tls.SignatureAndHashAlgorithm.Hash">
            <returns><see cref="T:Org.BouncyCastle.Tls.HashAlgorithm"/></returns>
        </member>
        <member name="P:Org.BouncyCastle.Tls.SignatureAndHashAlgorithm.Signature">
            <returns><see cref="T:Org.BouncyCastle.Tls.SignatureAlgorithm"/></returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.SignatureAndHashAlgorithm.Encode(System.IO.Stream)">
            <summary>Encode this <see cref="T:Org.BouncyCastle.Tls.SignatureAndHashAlgorithm"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.SignatureAndHashAlgorithm.Parse(System.IO.Stream)">
            <summary>Parse a <see cref="T:Org.BouncyCastle.Tls.SignatureAndHashAlgorithm"/> from a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="input">the <see cref="T:System.IO.Stream"/> to parse from.</param>
            <returns>a <see cref="T:Org.BouncyCastle.Tls.SignatureAndHashAlgorithm"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.SignatureScheme.GetNamedGroup(System.Int32)">
            For TLS 1.3+ usage, some signature schemes are constrained to use a particular
            ({@link NamedGroup}. Not relevant for TLS 1.2 and below.
        </member>
        <member name="T:Org.BouncyCastle.Tls.SupplementalDataType">
            <summary>RFC 4680</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.TlsAuthentication">
            <summary>Base interface to provide TLS authentication credentials.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsAuthentication.NotifyServerCertificate(Org.BouncyCastle.Tls.TlsServerCertificate)">
            <summary>Called by the protocol handler to report the server certificate.</summary>
            <remarks>
            Note: this method is responsible for certificate verification and validation.
            </remarks>
            <param name="serverCertificate">the server certificate received.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsAuthentication.GetClientCredentials(Org.BouncyCastle.Tls.CertificateRequest)">
            <summary>Return client credentials in response to server's certificate request.</summary>
            <remarks>
            The returned value may be null, or else it MUST implement <em>exactly one</em> of
            <see cref="T:Org.BouncyCastle.Tls.TlsCredentialedAgreement"/>, <see cref="T:Org.BouncyCastle.Tls.TlsCredentialedDecryptor"/>, or
            <see cref="T:Org.BouncyCastle.Tls.TlsCredentialedSigner"/>, depending on the key exchange that was negotiated and the details of
            the <see cref="T:Org.BouncyCastle.Tls.CertificateRequest"/>.
            </remarks>
            <param name="certificateRequest">details of the certificate request.</param>
            <returns>a <see cref="T:Org.BouncyCastle.Tls.TlsCredentials"/> object or null for no client authentication.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClient.GetSessionToResume">
            <summary>Return the session this client wants to resume, if any.</summary>
            <remarks>
            Note that the peer's certificate chain for the session (if any) may need to be periodically revalidated.
            </remarks>
            <returns>A <see cref="T:Org.BouncyCastle.Tls.TlsSession"/> representing the resumable session to be used for this connection, or
            null to use a new session.</returns>
            <seealso cref="P:Org.BouncyCastle.Tls.SessionParameters.PeerCertificate"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClient.GetExternalPsks">
            <summary>Return the <see cref="T:Org.BouncyCastle.Tls.TlsPskExternal">external PSKs</see> to offer in the ClientHello.</summary>
            <remarks>This will only be called when TLS 1.3 or higher is amongst the offered protocol versions.</remarks>
            <returns>an <see cref="T:System.Collections.IList"/> of <see cref="T:Org.BouncyCastle.Tls.TlsPskExternal"/> instances, or null if none should be
            offered.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClient.GetClientExtensions">
            <returns>(Int32 -> byte[])</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClient.GetEarlyKeyShareGroups">
            <summary>If this client is offering TLS 1.3 or higher, this method may be called to determine for which
            groups a key share should be included in the initial ClientHello.</summary>
            <remarks>
            Groups that were not included in the supported_groups extension (by <see cref="M:Org.BouncyCastle.Tls.TlsClient.GetClientExtensions"/> will
            be ignored. The protocol will then add a suitable key_share extension to the ClientHello extensions.
            </remarks>
            <returns>an <see cref="T:System.Collections.IList"/> of <see cref="T:Org.BouncyCastle.Tls.NamedGroup">named group</see> values, possibly empty or null.
            </returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClient.NotifyServerVersion(Org.BouncyCastle.Tls.ProtocolVersion)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClient.NotifySessionToResume(Org.BouncyCastle.Tls.TlsSession)">
            <summary>Notifies the client of the session that will be offered in ClientHello for resumption, if any.
            </summary>
            <remarks>
            This will be either the session returned from {@link #getSessionToResume()} or null if that session was
            unusable. NOTE: the actual negotiated session_id is notified by <see cref="M:Org.BouncyCastle.Tls.TlsClient.NotifySessionID(System.Byte[])"/>.
            </remarks>
            <param name="session">The <see cref="T:Org.BouncyCastle.Tls.TlsSession"/> representing the resumable session to be offered for
            this connection, or null if there is none.</param>
            <seealso cref="M:Org.BouncyCastle.Tls.TlsClient.NotifySessionID(System.Byte[])"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClient.NotifySessionID(System.Byte[])">
            <summary>Notifies the client of the session_id sent in the ServerHello.</summary>
            <param name="sessionID"/>
            <seealso cref="P:Org.BouncyCastle.Tls.TlsContext.Session"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClient.NotifySelectedPsk(Org.BouncyCastle.Tls.TlsPsk)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClient.ProcessServerExtensions(System.Collections.IDictionary)">
            <summary>The protocol implementation validates that any server extensions received correspond to client
            extensions sent.</summary>
            <remarks>
            If further processing of the server extensions is needed, it can be done in this callback. NOTE: This is
            not called for session resumption handshakes.
            </remarks>
            <param name="serverExtensions">(Int32 -> byte[])</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClient.ProcessServerSupplementalData(System.Collections.IList)">
            <param name="serverSupplementalData">(SupplementalDataEntry)</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClient.GetPskIdentity">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClient.GetDHGroupVerifier">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClient.GetAuthentication">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClient.GetClientSupplementalData">
            <returns>(SupplementalDataEntry)</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClient.NotifyNewSessionTicket(Org.BouncyCastle.Tls.NewSessionTicket)">
            <summary>RFC 5077 3.3. NewSessionTicket Handshake Message</summary>
            <remarks>
            This method will be called (only) when a NewSessionTicket handshake message is received. The ticket is
            opaque to the client and clients MUST NOT examine the ticket under the assumption that it complies with e.g.
            RFC 5077 4. "Recommended Ticket Construction".
            </remarks>
            <param name="newSessionTicket">The ticket.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.TlsClientContext">
            <summary>Marker interface to distinguish a TLS client context.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClientProtocol.#ctor">
            <summary>Constructor for non-blocking mode.</summary>
            <remarks>
            When data is received, use <see cref="M:Org.BouncyCastle.Tls.TlsProtocol.OfferInput(System.Byte[])"/> to provide the received ciphertext,
            then use <see cref="M:Org.BouncyCastle.Tls.TlsProtocol.ReadInput(System.Byte[],System.Int32,System.Int32)"/> to read the corresponding cleartext.<br/><br/>
            Similarly, when data needs to be sent, use <see cref="M:Org.BouncyCastle.Tls.TlsProtocol.WriteApplicationData(System.Byte[],System.Int32,System.Int32)"/>
            to provide the cleartext, then use <see cref="M:Org.BouncyCastle.Tls.TlsProtocol.ReadOutput(System.Byte[],System.Int32,System.Int32)"/> to get the
            corresponding ciphertext.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClientProtocol.#ctor(System.IO.Stream)">
            <summary>Constructor for blocking mode.</summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> of data to/from the server.</param>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClientProtocol.#ctor(System.IO.Stream,System.IO.Stream)">
            <summary>Constructor for blocking mode.</summary>
            <param name="input">The <see cref="T:System.IO.Stream"/> of data from the server.</param>
            <param name="output">The <see cref="T:System.IO.Stream"/> of data to the server.</param>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClientProtocol.Connect(Org.BouncyCastle.Tls.TlsClient)">
            <summary>Initiates a TLS handshake in the role of client.</summary>
            <remarks>
            In blocking mode, this will not return until the handshake is complete. In non-blocking mode, use
            <see cref="M:Org.BouncyCastle.Tls.TlsPeer.NotifyHandshakeComplete"/> to receive a callback when the handshake is complete.
            </remarks>
            <param name="tlsClient">The <see cref="T:Org.BouncyCastle.Tls.TlsClient"/> to use for the handshake.</param>
            <exception cref="T:System.IO.IOException">If in blocking mode and handshake was not successful.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClientProtocol.Handle13HandshakeMessage(System.Int16,Org.BouncyCastle.Tls.HandshakeMessageInput)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClientProtocol.HandleServerCertificate">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClientProtocol.HandleSupplementalData(System.Collections.IList)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClientProtocol.Process13HelloRetryRequest(Org.BouncyCastle.Tls.ServerHello)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClientProtocol.Process13ServerHello(Org.BouncyCastle.Tls.ServerHello,System.Boolean)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClientProtocol.Process13ServerHelloCoda(Org.BouncyCastle.Tls.ServerHello,System.Boolean)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClientProtocol.ProcessServerHello(Org.BouncyCastle.Tls.ServerHello)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClientProtocol.Receive13CertificateRequest(System.IO.MemoryStream,System.Boolean)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClientProtocol.Receive13EncryptedExtensions(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClientProtocol.Receive13NewSessionTicket(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClientProtocol.Receive13ServerCertificate(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClientProtocol.Receive13ServerCertificateVerify(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClientProtocol.Receive13ServerFinished(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClientProtocol.ReceiveCertificateRequest(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClientProtocol.ReceiveNewSessionTicket(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClientProtocol.ReceiveServerHelloMessage(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClientProtocol.Send13ClientHelloRetry">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClientProtocol.SendCertificateVerifyMessage(Org.BouncyCastle.Tls.DigitallySigned)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClientProtocol.SendClientHello">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClientProtocol.SendClientHelloMessage">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClientProtocol.SendClientKeyExchange">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClientProtocol.Skip13CertificateRequest">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsClientProtocol.Skip13ServerCertificate">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsCloseable.Close">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.TlsContext">
            <summary>Base interface for a TLS context implementation.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Tls.TlsContext.IsServer">
            <summary>Return true if this context is for a server, false otherwise.</summary>
            <returns>true for a server based context, false for a client based one.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Tls.TlsContext.ResumableSession">
            <summary>Used to get the resumable session, if any, used by this connection.</summary>
            <remarks>
            Only available after the handshake has successfully completed.
            </remarks>
            <returns>A <see cref="T:Org.BouncyCastle.Tls.TlsSession"/> representing the resumable session used by this connection, or null if
            no resumable session available.</returns>
            <seealso cref="M:Org.BouncyCastle.Tls.TlsPeer.NotifyHandshakeComplete"/>
        </member>
        <member name="P:Org.BouncyCastle.Tls.TlsContext.Session">
            <summary>Used to get the session information for this connection.</summary>
            <remarks>
            Only available after the handshake has successfully completed. Use <see cref="P:Org.BouncyCastle.Tls.TlsSession.IsResumable"/>
            to find out if the session is resumable.
            </remarks>
            <returns>A <see cref="T:Org.BouncyCastle.Tls.TlsSession"/> representing the session used by this connection.</returns>
            <seealso cref="M:Org.BouncyCastle.Tls.TlsPeer.NotifyHandshakeComplete"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsContext.ExportChannelBinding(System.Int32)">
            <summary>Export the value of the specified channel binding.</summary>
            <remarks>
            Only available after the handshake has successfully completed.
            </remarks>
            <param name="channelBinding">A <see cref="T:Org.BouncyCastle.Tls.ChannelBinding"/> constant specifying the channel binding to
            export.</param>
            <returns>A copy of the channel binding data as a <c>byte[]</c>, or null if the binding could not be
            determined.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsContext.ExportEarlyKeyingMaterial(System.String,System.Byte[],System.Int32)">
            <summary>Export (early data) keying material according to RFC 5705: "Keying Material Exporters for TLS", as
            updated for TLS 1.3 (RFC 8446).</summary>
            <remarks>
            NOTE: for use in settings where an exporter is needed for 0-RTT data.
            </remarks>
            <param name="asciiLabel">indicates which application will use the exported keys.</param>
            <param name="context_value">allows the application using the exporter to mix its own data with the TLS PRF
            for the exporter output.</param>
            <param name="length">the number of bytes to generate.</param>
            <returns>a pseudorandom bit string of 'length' bytes generated from the (exporter_)master_secret.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsContext.ExportKeyingMaterial(System.String,System.Byte[],System.Int32)">
            <summary>Export keying material according to RFC 5705: "Keying Material Exporters for TLS", as updated for
            TLS 1.3 (RFC 8446) when negotiated.</summary>
            <param name="asciiLabel">indicates which application will use the exported keys.</param>
            <param name="context_value">allows the application using the exporter to mix its own data with the TLS PRF
            for the exporter output.</param>
            <param name="length">the number of bytes to generate.</param>
            <returns>a pseudorandom bit string of 'length' bytes generated from the (exporter_)master_secret.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Tls.TlsCredentialedAgreement">
            <summary>Support interface for generating a secret based on the credentials sent by a TLS peer.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsCredentialedAgreement.GenerateAgreement(Org.BouncyCastle.Tls.Crypto.TlsCertificate)">
            <summary>Calculate an agreed secret based on our credentials and the public key credentials of our peer.
            </summary>
            <param name="peerCertificate">public key certificate of our TLS peer.</param>
            <returns>the agreed secret.</returns>
            <exception cref="T:System.IO.IOException">in case of an exception on generation of the secret.</exception>
        </member>
        <member name="T:Org.BouncyCastle.Tls.TlsCredentialedDecryptor">
            <summary>Base interface for a class that decrypts TLS secrets.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsCredentialedDecryptor.Decrypt(Org.BouncyCastle.Tls.Crypto.TlsCryptoParameters,System.Byte[])">
            <summary>Decrypt the passed in cipher text using the parameters available.</summary>
            <param name="cryptoParams">the parameters to use for the decryption.</param>
            <param name="ciphertext">the cipher text containing the secret.</param>
            <returns>a TLS secret.</returns>
            <exception cref="T:System.IO.IOException">on a parsing or decryption error.</exception>
        </member>
        <member name="T:Org.BouncyCastle.Tls.TlsCredentialedSigner">
            <summary>Support interface for generating a signature based on our private credentials.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsCredentialedSigner.GenerateRawSignature(System.Byte[])">
            <summary>Generate a signature against the passed in hash.</summary>
            <param name="hash">a message digest calculated across the message the signature is to apply to.</param>
            <returns>an encoded signature.</returns>
            <exception cref="T:System.IO.IOException">if the hash cannot be processed, or there is an issue with the private
            credentials.</exception>
        </member>
        <member name="P:Org.BouncyCastle.Tls.TlsCredentialedSigner.SignatureAndHashAlgorithm">
            <summary>Return the algorithm IDs for the signature algorithm and the associated hash it uses.</summary>
            <returns>the full algorithm details for the signature.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsCredentialedSigner.GetStreamSigner">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.TlsCredentials">
            <summary>Base interface for interfaces/classes carrying TLS credentials.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Tls.TlsCredentials.Certificate">
            <summary>Return the certificate structure representing our identity.</summary>
            <returns>our certificate structure.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Tls.TlsDHanonKeyExchange">
            <summary>(D)TLS DH_anon key exchange.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.TlsDHGroupVerifier">
            <summary>Interface for verifying explicit Diffie-Hellman group parameters.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsDHGroupVerifier.Accept(Org.BouncyCastle.Tls.Crypto.DHGroup)">
            <summary>Check whether the given DH group is acceptable for use.</summary>
            <param name="dhGroup">the <see cref="T:Org.BouncyCastle.Tls.Crypto.DHGroup"/> to check.</param>
            <returns>true if (and only if) the specified group is acceptable.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Tls.TlsDHKeyExchange">
            <summary>(D)TLS DH key exchange.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsDHUtilities.ReceiveDHConfig(Org.BouncyCastle.Tls.TlsContext,Org.BouncyCastle.Tls.TlsDHGroupVerifier,System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsDHUtilities.ReadDHParameter(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsDHUtilities.WriteDHConfig(Org.BouncyCastle.Tls.Crypto.TlsDHConfig,System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsDHUtilities.WriteDHParameter(Org.BouncyCastle.Math.BigInteger,System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsEccUtilities.CreateNamedECConfig(Org.BouncyCastle.Tls.TlsContext,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsEccUtilities.CheckPointEncoding(System.Int32,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsEccUtilities.ReceiveECDHConfig(Org.BouncyCastle.Tls.TlsContext,System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsEccUtilities.WriteECConfig(Org.BouncyCastle.Tls.Crypto.TlsECConfig,System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsEccUtilities.WriteNamedECParameters(System.Int32,System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.TlsECDHanonKeyExchange">
            <summary>(D)TLS ECDH_anon key exchange (see RFC 4492).</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.TlsECDheKeyExchange">
            <summary>(D)TLS ECDHE key exchange (see RFC 4492).</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.TlsECDHKeyExchange">
            <summary>(D)TLS ECDH key exchange (see RFC 4492).</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddAlpnExtensionClient(System.Collections.IDictionary,System.Collections.IList)">
            <param name="extensions">(Int32 -> byte[])</param>
            <param name="protocolNameList">an <see cref="T:System.Collections.IList"/> of <see cref="T:Org.BouncyCastle.Tls.ProtocolName"/>.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddAlpnExtensionServer(System.Collections.IDictionary,Org.BouncyCastle.Tls.ProtocolName)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddCertificateAuthoritiesExtension(System.Collections.IDictionary,System.Collections.IList)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddClientCertificateTypeExtensionClient(System.Collections.IDictionary,System.Int16[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddClientCertificateTypeExtensionServer(System.Collections.IDictionary,System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddCompressCertificateExtension(System.Collections.IDictionary,System.Int32[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddCookieExtension(System.Collections.IDictionary,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddEarlyDataMaxSize(System.Collections.IDictionary,System.Int64)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddHeartbeatExtension(System.Collections.IDictionary,Org.BouncyCastle.Tls.HeartbeatExtension)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddKeyShareClientHello(System.Collections.IDictionary,System.Collections.IList)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddKeyShareHelloRetryRequest(System.Collections.IDictionary,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddKeyShareServerHello(System.Collections.IDictionary,Org.BouncyCastle.Tls.KeyShareEntry)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddMaxFragmentLengthExtension(System.Collections.IDictionary,System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddOidFiltersExtension(System.Collections.IDictionary,System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddPaddingExtension(System.Collections.IDictionary,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddPreSharedKeyClientHello(System.Collections.IDictionary,Org.BouncyCastle.Tls.OfferedPsks)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddPreSharedKeyServerHello(System.Collections.IDictionary,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddPskKeyExchangeModesExtension(System.Collections.IDictionary,System.Int16[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddRecordSizeLimitExtension(System.Collections.IDictionary,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddServerCertificateTypeExtensionClient(System.Collections.IDictionary,System.Int16[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddServerCertificateTypeExtensionServer(System.Collections.IDictionary,System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddServerNameExtensionClient(System.Collections.IDictionary,System.Collections.IList)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddServerNameExtensionServer(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddSignatureAlgorithmsExtension(System.Collections.IDictionary,System.Collections.IList)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddSignatureAlgorithmsCertExtension(System.Collections.IDictionary,System.Collections.IList)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddStatusRequestExtension(System.Collections.IDictionary,Org.BouncyCastle.Tls.CertificateStatusRequest)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddStatusRequestV2Extension(System.Collections.IDictionary,System.Collections.IList)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddSupportedGroupsExtension(System.Collections.IDictionary,System.Collections.IList)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddSupportedPointFormatsExtension(System.Collections.IDictionary,System.Int16[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddSupportedVersionsExtensionClient(System.Collections.IDictionary,Org.BouncyCastle.Tls.ProtocolVersion[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddSupportedVersionsExtensionServer(System.Collections.IDictionary,Org.BouncyCastle.Tls.ProtocolVersion)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.AddTrustedCAKeysExtensionClient(System.Collections.IDictionary,System.Collections.IList)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetAlpnExtensionClient(System.Collections.IDictionary)">
            <returns>an <see cref="T:System.Collections.IList"/> of <see cref="T:Org.BouncyCastle.Tls.ProtocolName"/>.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetAlpnExtensionServer(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetCertificateAuthoritiesExtension(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetClientCertificateTypeExtensionClient(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetClientCertificateTypeExtensionServer(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetCompressCertificateExtension(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetCookieExtension(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetEarlyDataMaxSize(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetHeartbeatExtension(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetKeyShareClientHello(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetKeyShareHelloRetryRequest(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetKeyShareServerHello(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetMaxFragmentLengthExtension(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetOidFiltersExtension(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetPaddingExtension(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetPreSharedKeyClientHello(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetPreSharedKeyServerHello(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetPskKeyExchangeModesExtension(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetRecordSizeLimitExtension(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetServerCertificateTypeExtensionClient(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetServerCertificateTypeExtensionServer(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetServerNameExtensionClient(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetSignatureAlgorithmsExtension(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetSignatureAlgorithmsCertExtension(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetStatusRequestExtension(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetStatusRequestV2Extension(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetSupportedGroupsExtension(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetSupportedPointFormatsExtension(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetSupportedVersionsExtensionClient(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetSupportedVersionsExtensionServer(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.GetTrustedCAKeysExtensionClient(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.HasClientCertificateUrlExtension(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.HasEarlyDataIndication(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.HasEncryptThenMacExtension(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.HasExtendedMasterSecretExtension(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.HasServerNameExtensionServer(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.HasPostHandshakeAuthExtension(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.HasTruncatedHmacExtension(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.HasTrustedCAKeysExtensionServer(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateAlpnExtensionClient(System.Collections.IList)">
            <param name="protocolNameList">an <see cref="T:System.Collections.IList"/> of <see cref="T:Org.BouncyCastle.Tls.ProtocolName"/>.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateAlpnExtensionServer(Org.BouncyCastle.Tls.ProtocolName)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateCertificateAuthoritiesExtension(System.Collections.IList)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateCertificateTypeExtensionClient(System.Int16[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateCertificateTypeExtensionServer(System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateCompressCertificateExtension(System.Int32[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateCookieExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateEarlyDataMaxSize(System.Int64)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateHeartbeatExtension(Org.BouncyCastle.Tls.HeartbeatExtension)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateKeyShareClientHello(System.Collections.IList)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateKeyShareHelloRetryRequest(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateKeyShareServerHello(Org.BouncyCastle.Tls.KeyShareEntry)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateMaxFragmentLengthExtension(System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateOidFiltersExtension(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreatePaddingExtension(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreatePreSharedKeyClientHello(Org.BouncyCastle.Tls.OfferedPsks)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreatePreSharedKeyServerHello(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreatePskKeyExchangeModesExtension(System.Int16[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateRecordSizeLimitExtension(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateServerNameExtensionClient(System.Collections.IList)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateSignatureAlgorithmsExtension(System.Collections.IList)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateSignatureAlgorithmsCertExtension(System.Collections.IList)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateStatusRequestExtension(Org.BouncyCastle.Tls.CertificateStatusRequest)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateStatusRequestV2Extension(System.Collections.IList)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateSupportedGroupsExtension(System.Collections.IList)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateSupportedPointFormatsExtension(System.Int16[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateSupportedVersionsExtensionClient(Org.BouncyCastle.Tls.ProtocolVersion[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateSupportedVersionsExtensionServer(Org.BouncyCastle.Tls.ProtocolVersion)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.CreateTrustedCAKeysExtensionClient(System.Collections.IList)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadEmptyExtensionData(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadAlpnExtensionClient(System.Byte[])">
            <returns>an <see cref="T:System.Collections.IList"/> of <see cref="T:Org.BouncyCastle.Tls.ProtocolName"/>.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadAlpnExtensionServer(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadCertificateAuthoritiesExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadCertificateTypeExtensionClient(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadCertificateTypeExtensionServer(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadClientCertificateUrlExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadCompressCertificateExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadCookieExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadEarlyDataIndication(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadEarlyDataMaxSize(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadEncryptThenMacExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadExtendedMasterSecretExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadHeartbeatExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadKeyShareClientHello(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadKeyShareHelloRetryRequest(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadKeyShareServerHello(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadMaxFragmentLengthExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadOidFiltersExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadPaddingExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadPostHandshakeAuthExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadPreSharedKeyClientHello(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadPreSharedKeyServerHello(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadPskKeyExchangeModesExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadRecordSizeLimitExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadServerNameExtensionClient(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadServerNameExtensionServer(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadSignatureAlgorithmsExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadSignatureAlgorithmsCertExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadStatusRequestExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadStatusRequestV2Extension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadSupportedGroupsExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadSupportedPointFormatsExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadSupportedVersionsExtensionClient(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadSupportedVersionsExtensionServer(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadTruncatedHmacExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadTrustedCAKeysExtensionClient(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.ReadTrustedCAKeysExtensionServer(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsExtensionsUtilities.PatchOpaque16(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.TlsHandshakeHash">
            <summary>Base interface for an object that can calculate a handshake hash.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsHandshakeHash.CopyBufferTo(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.TlsKeyExchange">
            <summary>A generic interface for key exchange implementations in (D)TLS.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsKeyExchange.SkipServerCredentials">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsKeyExchange.ProcessServerCredentials(Org.BouncyCastle.Tls.TlsCredentials)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsKeyExchange.ProcessServerCertificate(Org.BouncyCastle.Tls.Certificate)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsKeyExchange.GenerateServerKeyExchange">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsKeyExchange.SkipServerKeyExchange">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsKeyExchange.ProcessServerKeyExchange(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsKeyExchange.SkipClientCredentials">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsKeyExchange.ProcessClientCredentials(Org.BouncyCastle.Tls.TlsCredentials)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsKeyExchange.ProcessClientCertificate(Org.BouncyCastle.Tls.Certificate)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsKeyExchange.GenerateClientKeyExchange(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsKeyExchange.ProcessClientKeyExchange(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsKeyExchange.GeneratePreMasterSecret">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.TlsKeyExchangeFactory">
            <summary>Interface for a key exchange factory offering a variety of specific algorithms.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsKeyExchangeFactory.CreateDHKeyExchange(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsKeyExchangeFactory.CreateDHanonKeyExchangeClient(System.Int32,Org.BouncyCastle.Tls.TlsDHGroupVerifier)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsKeyExchangeFactory.CreateDHanonKeyExchangeServer(System.Int32,Org.BouncyCastle.Tls.Crypto.TlsDHConfig)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsKeyExchangeFactory.CreateDheKeyExchangeClient(System.Int32,Org.BouncyCastle.Tls.TlsDHGroupVerifier)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsKeyExchangeFactory.CreateDheKeyExchangeServer(System.Int32,Org.BouncyCastle.Tls.Crypto.TlsDHConfig)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsKeyExchangeFactory.CreateECDHKeyExchange(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsKeyExchangeFactory.CreateECDHanonKeyExchangeClient(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsKeyExchangeFactory.CreateECDHanonKeyExchangeServer(System.Int32,Org.BouncyCastle.Tls.Crypto.TlsECConfig)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsKeyExchangeFactory.CreateECDheKeyExchangeClient(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsKeyExchangeFactory.CreateECDheKeyExchangeServer(System.Int32,Org.BouncyCastle.Tls.Crypto.TlsECConfig)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsKeyExchangeFactory.CreatePskKeyExchangeClient(System.Int32,Org.BouncyCastle.Tls.TlsPskIdentity,Org.BouncyCastle.Tls.TlsDHGroupVerifier)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsKeyExchangeFactory.CreatePskKeyExchangeServer(System.Int32,Org.BouncyCastle.Tls.TlsPskIdentityManager,Org.BouncyCastle.Tls.Crypto.TlsDHConfig,Org.BouncyCastle.Tls.Crypto.TlsECConfig)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsKeyExchangeFactory.CreateRsaKeyExchange(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.TlsNoCloseNotifyException">
            <summary>This exception will be thrown (only) when the connection is closed by the peer without sending a
            <see cref="F:Org.BouncyCastle.Tls.AlertDescription.close_notify">close_notify</see> warning alert.</summary>
            <remarks>
            If this happens, the TLS protocol cannot rule out truncation of the connection data (potentially
            malicious). It may be possible to check for truncation via some property of a higher level protocol
            built upon TLS, e.g.the Content-Length header for HTTPS.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Tls.TlsObjectIdentifiers">
            <summary>Object Identifiers associated with TLS extensions.</summary>
        </member>
        <member name="F:Org.BouncyCastle.Tls.TlsObjectIdentifiers.id_pe_tlsfeature">
            <summary>RFC 7633</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.TlsPeer">
            <summary>Base interface for a (D)TLS endpoint.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsPeer.Cancel">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsPeer.NotifyHandshakeBeginning">
            <summary>Notifies the peer that a new handshake is about to begin.</summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsPeer.GetHandshakeTimeoutMillis">
            <summary>Specify the timeout, in milliseconds, to use for the complete handshake process.</summary>
            <remarks>
            NOTE: Currently only respected by DTLS protocols. Negative values are not allowed. A timeout of zero means
            an infinite timeout (i.e.the handshake will never time out).
            </remarks>
            <returns>the handshake timeout, in milliseconds.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsPeer.RequiresCloseNotify">
            <remarks>
            This option is provided as a last resort for interoperability with TLS peers that fail to correctly send a
            close_notify alert at end of stream. Implementations SHOULD return true; caution is advised if returning
            false without a full understanding of the implications.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsPeer.RequiresExtendedMasterSecret">
            <remarks>This implementation supports RFC 7627 and will always negotiate the extended_master_secret
            extension where possible. When connecting to a peer that does not offer/accept this extension, it is
            recommended to abort the handshake.This option is provided for interoperability with legacy peers, although
            some TLS features will be disabled in that case (see RFC 7627 5.4).
            </remarks>
            <returns><c>true</c> if the handshake should be aborted when the peer does not negotiate the
            extended_master_secret extension, or <c>false</c> to support legacy interoperability.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsPeer.ShouldUseExtendedPadding">
            <summary>See RFC 5246 6.2.3.2. Controls whether block cipher encryption may randomly add extra padding
            beyond the minimum.</summary>
            <remarks>
            Note that in configurations where this is known to be potential security risk this setting will be ignored
            (and extended padding disabled). Extra padding is always supported when decrypting received records.
            </remarks>
            <returns><c>true</c> if random extra padding should be added during block cipher encryption, or
            <c>false</c> to always use the minimum amount of required padding.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsPeer.ShouldUseGmtUnixTime">
            <summary> draft-mathewson-no-gmtunixtime-00 2. "If existing users of a TLS implementation may rely on
            gmt_unix_time containing the current time, we recommend that implementors MAY provide the ability to set
            gmt_unix_time as an option only, off by default.".</summary>
            <remarks>
            NOTE: For a server that has negotiated TLS 1.3 (or later), or a client that has offered TLS 1.3 (or later),
            this is not called and gmt_unix_time is not used.
            </remarks>
            <returns><c>true</c> if the current time should be used in the gmt_unix_time field of Random, or
            <c>false</c> if gmt_unix_time should contain a cryptographically random value.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsPeer.NotifySecureRenegotiation(System.Boolean)">
            <summary>RFC 5746 3.4/3.6. In case this is false, peers may want to terminate the handshake instead of
            continuing; see Section 4.1/4.3 for discussion.</summary>
            <remarks>
            NOTE: TLS 1.3 forbids renegotiation, so this is never called when TLS 1.3 (or later) was negotiated.
            </remarks>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsPeer.GetKeyExchangeFactory">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsPeer.NotifyAlertRaised(System.Int16,System.Int16,System.String,System.Exception)">
            <summary>This method will be called when an alert is raised by the protocol.</summary>
            <param name="alertLevel"><see cref="T:Org.BouncyCastle.Tls.AlertLevel"/></param>
            <param name="alertDescription"><see cref="T:Org.BouncyCastle.Tls.AlertDescription"/></param>
            <param name="message">A human-readable message explaining what caused this alert. May be null.</param>
            <param name="cause">The <see cref="T:System.Exception"/> that caused this alert to be raised. May be null.</param>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsPeer.NotifyAlertReceived(System.Int16,System.Int16)">
            <summary>This method will be called when an alert is received from the remote peer.</summary>
            <param name="alertLevel"><see cref="T:Org.BouncyCastle.Tls.AlertLevel"/></param>
            <param name="alertDescription"><see cref="T:Org.BouncyCastle.Tls.AlertDescription"/></param>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsPeer.NotifyHandshakeComplete">
            <summary>Notifies the peer that the handshake has been successfully completed.</summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsPeer.GetHeartbeat">
            <summary>Return a <see cref="T:Org.BouncyCastle.Tls.TlsHeartbeat"/> instance that will control the generation of heartbeats
            locally (if permitted by the remote peer), or null to not generate heartbeats. Heartbeats are described in
            RFC 6520.</summary>
            <returns>an instance of <see cref="T:Org.BouncyCastle.Tls.TlsHeartbeat"/>.</returns>
            <seealso cref="T:Org.BouncyCastle.Tls.DefaultTlsHeartbeat"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsPeer.GetHeartbeatPolicy">
            <summary>Return the heartbeat mode applicable to the remote peer. Heartbeats are described in RFC 6520.
            </summary>
            <remarks>
            See enumeration class <see cref="T:Org.BouncyCastle.Tls.HeartbeatMode"/> for appropriate return values.
            </remarks>
            <returns>the <see cref="T:Org.BouncyCastle.Tls.HeartbeatMode"/> value.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.ResumeHandshake">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.CloseConnection">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.HandleAlertMessage(System.Int16,System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.HandleAlertWarningMessage(System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.HandleChangeCipherSpecMessage">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.HandleClose(System.Boolean)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.HandleException(System.Int16,System.String,System.Exception)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.HandleFailure">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.HandleHandshakeMessage(System.Int16,Org.BouncyCastle.Tls.HandshakeMessageInput)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.ApplyMaxFragmentLengthExtension(System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.CheckReceivedChangeCipherSpec(System.Boolean)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.BlockForHandshake">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.BeginHandshake">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.CompleteHandshake">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.ProcessRecord(System.Int16,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.ProcessHandshakeQueue(Org.BouncyCastle.Tls.ByteQueue)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.ProcessAlertQueue">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.ProcessChangeCipherSpec(System.Byte[],System.Int32,System.Int32)">
            <summary>This method is called, when a change cipher spec message is received.</summary>
            <exception cref="T:System.IO.IOException">If the message has an invalid content or the handshake is not in the correct
            state.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.ReadApplicationData(System.Byte[],System.Int32,System.Int32)">
            <summary>Read data from the network.</summary>
            <remarks>
            The method will return immediately, if there is still some data left in the buffer, or block until some
            application data has been read from the network.
            </remarks>
            <param name="buffer">The buffer where the data will be copied to.</param>
            <param name="offset">The position where the data will be placed in the buffer.</param>
            <param name="count">The maximum number of bytes to read.</param>
            <returns>The number of bytes read.</returns>
            <exception cref="T:System.IO.IOException">If something goes wrong during reading data.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.SafePreviewRecordHeader(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.SafeReadRecord">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.SafeReadFullRecord(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.SafeWriteRecord(System.Int16,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.WriteApplicationData(System.Byte[],System.Int32,System.Int32)">
            <summary>Write some application data.</summary>
            <remarks>
            Fragmentation is handled internally. Usable in both blocking/non-blocking modes.<br/><br/>
            In blocking mode, the output will be automatically sent via the underlying transport. In non-blocking mode,
            call <see cref="M:Org.BouncyCastle.Tls.TlsProtocol.ReadOutput(System.Byte[],System.Int32,System.Int32)"/> to get the output bytes to send to the peer.<br/><br/>
            This method must not be called until after the initial handshake is complete. Attempting to call it earlier
            will result in an <see cref="T:System.InvalidOperationException"/>.
            </remarks>
            <param name="buffer">The buffer containing application data to send.</param>
            <param name="offset">The offset at which the application data begins</param>
            <param name="count">The number of bytes of application data.</param>
            <exception cref="T:System.InvalidOperationException">If called before the initial handshake has completed.
            </exception>
            <exception cref="T:System.IO.IOException">If connection is already closed, or for encryption or transport errors.
            </exception>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.WriteHandshakeMessage(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="P:Org.BouncyCastle.Tls.TlsProtocol.Stream">
            <summary>The secure bidirectional stream for this connection</summary>
            <remarks>Only allowed in blocking mode.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.CloseInput">
            <summary>Should be called in non-blocking mode when the input data reaches EOF.</summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.PreviewInputRecord(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.PreviewOutputRecord(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.OfferInput(System.Byte[])">
            <summary>Equivalent to <code>OfferInput(input, 0, input.Length)</code>.</summary>
            <param name="input">The input buffer to offer.</param>
            <exception cref="T:System.IO.IOException"/>
            <seealso cref="M:Org.BouncyCastle.Tls.TlsProtocol.OfferInput(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.OfferInput(System.Byte[],System.Int32,System.Int32)">
            <summary>Offer input from an arbitrary source.</summary>
            <remarks>Only allowed in non-blocking mode.<br/><br/>
            This method will decrypt and process all records that are fully available. If only part of a record is
            available, the buffer will be retained until the remainder of the record is offered.<br/><br/>
            If any records containing application data were processed, the decrypted data can be obtained using
            <see cref="M:Org.BouncyCastle.Tls.TlsProtocol.ReadInput(System.Byte[],System.Int32,System.Int32)"/>. If any records containing protocol data were processed, a
            response may have been generated. You should always check to see if there is any available output after
            calling this method by calling <see cref="M:Org.BouncyCastle.Tls.TlsProtocol.GetAvailableOutputBytes"/>.
            </remarks>
            <param name="input">The input buffer to offer.</param>
            <param name="inputOff">The offset within the input buffer that input begins.</param>
            <param name="inputLen">The number of bytes of input being offered.</param>
            <exception cref="T:System.IO.IOException">If an error occurs while decrypting or processing a record.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.GetAvailableInputBytes">
            <summary>Gets the amount of received application data.</summary>
            <remarks>A call to <see cref="!:readInput(byte[], int, int)"/> is guaranteed to be able to return at least
            this much data.<br/><br/>
            Only allowed in non-blocking mode.
            </remarks>
            <returns>The number of bytes of available application data.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.ReadInput(System.Byte[],System.Int32,System.Int32)">
            <summary>Retrieves received application data.</summary>
            <remarks>
            Use <see cref="M:Org.BouncyCastle.Tls.TlsProtocol.GetAvailableInputBytes"/> to check how much application data is currently available. This
            method functions similarly to <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)"/>, except that it never blocks. If
            no data is available, nothing will be copied and zero will be returned.<br/><br/>
            Only allowed in non-blocking mode.
            </remarks>
            <param name="buf">The buffer to hold the application data.</param>
            <param name="off">The start offset in the buffer at which the data is written.</param>
            <param name="len">The maximum number of bytes to read.</param>
            <returns>The total number of bytes copied to the buffer. May be less than the length specified if the
            length was greater than the amount of available data.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.GetAvailableOutputBytes">
            <summary>Gets the amount of encrypted data available to be sent.</summary>
            <remarks>
            A call to <see cref="M:Org.BouncyCastle.Tls.TlsProtocol.ReadOutput(System.Byte[],System.Int32,System.Int32)"/> is guaranteed to be able to return at least this much
            data. Only allowed in non-blocking mode.
            </remarks>
            <returns>The number of bytes of available encrypted data.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.ReadOutput(System.Byte[],System.Int32,System.Int32)">
            <summary>Retrieves encrypted data to be sent.</summary>
            <remarks>
            Use <see cref="M:Org.BouncyCastle.Tls.TlsProtocol.GetAvailableOutputBytes"/> to check how much encrypted data is currently available. This
            method functions similarly to <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)"/>, except that it never blocks. If
            no data is available, nothing will be copied and zero will be returned. Only allowed in non-blocking mode.
            </remarks>
            <param name="buffer">The buffer to hold the encrypted data.</param>
            <param name="offset">The start offset in the buffer at which the data is written.</param>
            <param name="length">The maximum number of bytes to read.</param>
            <returns>The total number of bytes copied to the buffer. May be less than the length specified if the
            length was greater than the amount of available data.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.ProcessFinishedMessage(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.Process13FinishedMessage(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.RaiseAlertFatal(System.Int16,System.String,System.Exception)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.RaiseAlertWarning(System.Int16,System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.Receive13KeyUpdate(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.SendCertificateMessage(Org.BouncyCastle.Tls.Certificate,System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.Send13CertificateMessage(Org.BouncyCastle.Tls.Certificate)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.Send13CertificateVerifyMessage(Org.BouncyCastle.Tls.DigitallySigned)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.SendChangeCipherSpec">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.SendChangeCipherSpecMessage">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.SendFinishedMessage">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.Send13FinishedMessage">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.Send13KeyUpdate(System.Boolean)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.SendSupplementalDataMessage(System.Collections.IList)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.ProcessMaxFragmentLengthExtension(System.Collections.IDictionary,System.Collections.IDictionary,System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.RefuseRenegotiation">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.AssertEmpty(System.IO.MemoryStream)">
            <summary>Make sure the <see cref="P:Org.BouncyCastle.Tls.TlsProtocol.Stream"/> 'buf' is now empty. Fail otherwise.</summary>
            <param name="buf">The <see cref="P:Org.BouncyCastle.Tls.TlsProtocol.Stream"/> to check.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.CreateRenegotiationInfo(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.EstablishMasterSecret(Org.BouncyCastle.Tls.TlsContext,Org.BouncyCastle.Tls.TlsKeyExchange)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.ReadExtensions(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.ReadExtensionsData(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.ReadExtensionsData13(System.Int32,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.ReadExtensionsDataClientHello(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.ReadSupplementalDataMessage(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.WriteExtensions(System.IO.Stream,System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.WriteExtensions(System.IO.Stream,System.Collections.IDictionary,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.WriteExtensionsData(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.WriteExtensionsData(System.Collections.IDictionary,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.WriteExtensionsData(System.Collections.IDictionary,System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.WriteExtensionsData(System.Collections.IDictionary,System.IO.MemoryStream,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.WritePreSharedKeyExtension(System.IO.MemoryStream,System.Collections.IDictionary,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.WriteSelectedExtensions(System.IO.Stream,System.Collections.IDictionary,System.Boolean)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsProtocol.WriteSupplementalData(System.IO.Stream,System.Collections.IList)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.TlsPskIdentity">
            <summary>Processor interface for a PSK identity.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.TlsPskIdentityManager">
            <summary>Base interface for an object that can process a PSK identity.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.TlsPskKeyExchange">
            <summary>(D)TLS PSK key exchange (RFC 4279).</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.TlsRsaKeyExchange">
            <summary>(D)TLS RSA key exchange.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.TlsServer">
            <summary>Interface describing a TLS server endpoint.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServer.GetSessionToResume(System.Byte[])">
            <summary>Return the specified session, if available.</summary>
            <remarks>
            Note that the peer's certificate chain for the session (if any) may need to be periodically revalidated.
            </remarks>
            <param name="sessionID">the ID of the session to resume.</param>
            <returns>A <see cref="T:Org.BouncyCastle.Tls.TlsSession"/> with the specified session ID, or null.</returns>
            <seealso cref="P:Org.BouncyCastle.Tls.SessionParameters.PeerCertificate"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServer.GetExternalPsk(System.Collections.IList)">
            <summary>Return the <see cref="T:Org.BouncyCastle.Tls.TlsPskExternal">external PSK</see> to select from the ClientHello.</summary>
            <remarks>
            WARNING: EXPERIMENTAL FEATURE, UNSTABLE API
            Note that this will only be called when TLS 1.3 or higher is amongst the offered protocol versions, and one
            or more PSKs are actually offered.
            </remarks>
            <param name="identities">an <see cref="T:System.Collections.IList"/> of <see cref="T:Org.BouncyCastle.Tls.PskIdentity"/> instances.</param>
            <returns>The <see cref="T:Org.BouncyCastle.Tls.TlsPskExternal"/> corresponding to the selected identity, or null to not select
            any.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServer.NotifyClientVersion(Org.BouncyCastle.Tls.ProtocolVersion)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServer.NotifyFallback(System.Boolean)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServer.NotifyOfferedCipherSuites(System.Int32[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServer.ProcessClientExtensions(System.Collections.IDictionary)">
            <param name="clientExtensions">(Int32 -> byte[])</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServer.GetServerVersion">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServer.GetSupportedGroups">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServer.GetSelectedCipherSuite">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServer.GetServerExtensions">
            <returns>(Int32 -> byte[])</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServer.GetServerExtensionsForConnection(System.Collections.IDictionary)">
            <param name="serverExtensions">(Int32 -> byte[])</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServer.GetServerSupplementalData">
            <returns>(SupplementalDataEntry)</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServer.GetCredentials">
            <summary>Return server credentials to use.</summary>
            <remarks>
            The returned value may be null, or else it MUST implement <em>exactly one</em> of
            <see cref="T:Org.BouncyCastle.Tls.TlsCredentialedAgreement"/>, <see cref="T:Org.BouncyCastle.Tls.TlsCredentialedDecryptor"/>, or
            <see cref = "T:Org.BouncyCastle.Tls.TlsCredentialedSigner"/>, depending on the key exchange that was negotiated.
            </remarks>
            <returns>a <see cref="T:Org.BouncyCastle.Tls.TlsCredentials"/> object or null for anonymous key exchanges.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServer.GetCertificateStatus">
            <remarks>
            This method will be called (only) if the server included an extension of type "status_request" with empty
            "extension_data" in the extended server hello. See <i>RFC 3546 3.6. Certificate Status Request</i>. If a
            non-null <see cref="T:Org.BouncyCastle.Tls.CertificateStatus"/> is returned, it is sent to the client as a handshake message of
            type "certificate_status".
            </remarks>
            <returns>A <see cref="T:Org.BouncyCastle.Tls.CertificateStatus"/> to be sent to the client (or null for none).</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServer.GetCertificateRequest">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServer.GetPskIdentityManager">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServer.GetDHConfig">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServer.GetECDHConfig">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServer.ProcessClientSupplementalData(System.Collections.IList)">
            <param name="clientSupplementalData">(SupplementalDataEntry)</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServer.NotifyClientCertificate(Org.BouncyCastle.Tls.Certificate)">
            <summary>Called by the protocol handler to report the client certificate, only if
            <see cref="M:Org.BouncyCastle.Tls.TlsServer.GetCertificateRequest"/> returned non-null.</summary>
            <remarks>
            Note: this method is responsible for certificate verification and validation.
            </remarks>
            <param name="clientCertificate">the effective client certificate (may be an empty chain).</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServer.GetNewSessionTicket">
            <summary>RFC 5077 3.3. NewSessionTicket Handshake Message.</summary>
            <remarks>
            This method will be called (only) if a NewSessionTicket extension was sent by the server. See <i>RFC 5077
            4. Recommended Ticket Construction</i> for recommended format and protection.
            </remarks>
            <returns>The ticket.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.TlsServerCertificate">
            <summary>Server certificate carrier interface.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.TlsServerContext">
            <summary>Marker interface to distinguish a TLS server context.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServerProtocol.#ctor">
            <summary>Constructor for non-blocking mode.</summary>
            <remarks>
            When data is received, use <see cref="M:Org.BouncyCastle.Tls.TlsProtocol.OfferInput(System.Byte[])"/> to provide the received ciphertext,
            then use <see cref="M:Org.BouncyCastle.Tls.TlsProtocol.ReadInput(System.Byte[],System.Int32,System.Int32)"/> to read the corresponding cleartext.<br/><br/>
            Similarly, when data needs to be sent, use <see cref="M:Org.BouncyCastle.Tls.TlsProtocol.WriteApplicationData(System.Byte[],System.Int32,System.Int32)"/>
            to provide the cleartext, then use <see cref="M:Org.BouncyCastle.Tls.TlsProtocol.ReadOutput(System.Byte[],System.Int32,System.Int32)"/> to get the
            corresponding ciphertext.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServerProtocol.#ctor(System.IO.Stream)">
            <summary>Constructor for blocking mode.</summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> of data to/from the server.</param>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServerProtocol.#ctor(System.IO.Stream,System.IO.Stream)">
            <summary>Constructor for blocking mode.</summary>
            <param name="input">The <see cref="T:System.IO.Stream"/> of data from the server.</param>
            <param name="output">The <see cref="T:System.IO.Stream"/> of data to the server.</param>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServerProtocol.Accept(Org.BouncyCastle.Tls.TlsServer)">
            <summary>Receives a TLS handshake in the role of server.</summary>
            <remarks>
            In blocking mode, this will not return until the handshake is complete. In non-blocking mode, use
            <see cref="M:Org.BouncyCastle.Tls.TlsPeer.NotifyHandshakeComplete"/> to receive a callback when the handshake is complete.
            </remarks>
            <param name="tlsServer">The <see cref="T:Org.BouncyCastle.Tls.TlsServer"/> to use for the handshake.</param>
            <exception cref="T:System.IO.IOException">If in blocking mode and handshake was not successful.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServerProtocol.Generate13HelloRetryRequest(Org.BouncyCastle.Tls.ClientHello)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServerProtocol.Generate13ServerHello(Org.BouncyCastle.Tls.ClientHello,Org.BouncyCastle.Tls.HandshakeMessageInput,System.Boolean)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServerProtocol.GenerateServerHello(Org.BouncyCastle.Tls.ClientHello,Org.BouncyCastle.Tls.HandshakeMessageInput)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServerProtocol.Handle13HandshakeMessage(System.Int16,Org.BouncyCastle.Tls.HandshakeMessageInput)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServerProtocol.NotifyClientCertificate(Org.BouncyCastle.Tls.Certificate)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServerProtocol.Receive13ClientCertificate(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServerProtocol.Receive13ClientCertificateVerify(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServerProtocol.Receive13ClientFinished(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServerProtocol.ReceiveCertificateMessage(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServerProtocol.ReceiveCertificateVerifyMessage(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServerProtocol.ReceiveClientHelloMessage(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServerProtocol.ReceiveClientKeyExchangeMessage(System.IO.MemoryStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServerProtocol.Send13EncryptedExtensionsMessage(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServerProtocol.Send13ServerHelloCoda(Org.BouncyCastle.Tls.ServerHello,System.Boolean)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServerProtocol.SendCertificateRequestMessage(Org.BouncyCastle.Tls.CertificateRequest)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServerProtocol.SendCertificateStatusMessage(Org.BouncyCastle.Tls.CertificateStatus)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServerProtocol.SendHelloRequestMessage">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServerProtocol.SendNewSessionTicketMessage(Org.BouncyCastle.Tls.NewSessionTicket)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServerProtocol.SendServerHelloDoneMessage">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServerProtocol.SendServerHelloMessage(Org.BouncyCastle.Tls.ServerHello)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServerProtocol.SendServerKeyExchangeMessage(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServerProtocol.Skip13ClientCertificate">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsServerProtocol.Skip13ClientCertificateVerify">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.TlsSession">
            <summary>Base interface for a carrier object for a TLS session.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.TlsSrtpUtilities">
            <summary>RFC 5764 DTLS Extension to Establish Keys for SRTP.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsSrtpUtilities.AddUseSrtpExtension(System.Collections.IDictionary,Org.BouncyCastle.Tls.UseSrtpData)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsSrtpUtilities.GetUseSrtpExtension(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsSrtpUtilities.CreateUseSrtpExtension(Org.BouncyCastle.Tls.UseSrtpData)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsSrtpUtilities.ReadUseSrtpExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsUtilities.ReadDerObject(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsUtilities.RequireDerEncoding(Org.BouncyCastle.Asn1.Asn1Encodable,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsUtilities.EncodeSupportedSignatureAlgorithms(System.Collections.IList,System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsUtilities.ParseSupportedSignatureAlgorithms(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsUtilities.VerifySupportedSignatureAlgorithm(System.Collections.IList,Org.BouncyCastle.Tls.SignatureAndHashAlgorithm)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsUtilities.VerifySupportedSignatureAlgorithm(System.Collections.IList,Org.BouncyCastle.Tls.SignatureAndHashAlgorithm,System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsUtilities.ContainsSignatureAlgorithm(System.Collections.IList,Org.BouncyCastle.Tls.SignatureAndHashAlgorithm)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsUtilities.CalculateEndPointHash(Org.BouncyCastle.Tls.TlsContext,Org.BouncyCastle.Tls.Crypto.TlsCertificate,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsUtilities.CalculateEndPointHash(Org.BouncyCastle.Tls.TlsContext,Org.BouncyCastle.Tls.Crypto.TlsCertificate,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsUtilities.Verify13CertificateVerifyClient(Org.BouncyCastle.Tls.TlsServerContext,Org.BouncyCastle.Tls.TlsHandshakeHash,Org.BouncyCastle.Tls.CertificateVerify)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsUtilities.Verify13CertificateVerifyServer(Org.BouncyCastle.Tls.TlsClientContext,Org.BouncyCastle.Tls.TlsHandshakeHash,Org.BouncyCastle.Tls.CertificateVerify)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsUtilities.Verify13CertificateVerify(System.Collections.IList,System.String,Org.BouncyCastle.Tls.TlsHandshakeHash,Org.BouncyCastle.Tls.Crypto.TlsCertificate,Org.BouncyCastle.Tls.CertificateVerify)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsUtilities.GenerateServerKeyExchangeSignature(Org.BouncyCastle.Tls.TlsContext,Org.BouncyCastle.Tls.TlsCredentialedSigner,System.Byte[],Org.BouncyCastle.Tls.DigestInputBuffer)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsUtilities.VerifyServerKeyExchangeSignature(Org.BouncyCastle.Tls.TlsContext,System.IO.Stream,Org.BouncyCastle.Tls.Crypto.TlsCertificate,System.Byte[],Org.BouncyCastle.Tls.DigestInputBuffer)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsUtilities.IsAeadCipherSuite(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsUtilities.IsBlockCipherSuite(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsUtilities.IsStreamCipherSuite(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsUtilities.IsValidCipherSuiteForSignatureAlgorithms(System.Int32,System.Collections.IList)">
            <returns>Whether a server can select the specified cipher suite given the available signature algorithms
            for ServerKeyExchange.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsUtilities.ChooseSignatureAndHashAlgorithm(Org.BouncyCastle.Tls.TlsContext,System.Collections.IList,System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsUtilities.ChooseSignatureAndHashAlgorithm(Org.BouncyCastle.Tls.ProtocolVersion,System.Collections.IList,System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsUtilities.CreateKeyExchangeClient(Org.BouncyCastle.Tls.TlsClient,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsUtilities.CreateKeyExchangeServer(Org.BouncyCastle.Tls.TlsServer,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsUtilities.InitKeyExchangeClient(Org.BouncyCastle.Tls.TlsClientContext,Org.BouncyCastle.Tls.TlsClient)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsUtilities.InitKeyExchangeServer(Org.BouncyCastle.Tls.TlsServerContext,Org.BouncyCastle.Tls.TlsServer)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsUtilities.CheckPeerSigAlgs(Org.BouncyCastle.Tls.TlsContext,Org.BouncyCastle.Tls.Crypto.TlsCertificate[])">
            <summary>Check the signature algorithm for certificates in the peer's CertPath as specified in RFC 5246
            7.4.2, 7.4.4, 7.4.6 and similar rules for earlier TLS versions.</summary>
            <remarks>
            The supplied CertPath should include the trust anchor (its signature algorithm isn't checked, but in the
            general case checking a certificate requires the issuer certificate).
            </remarks>
            <exception cref="T:System.IO.IOException">if any certificate in the CertPath (excepting the trust anchor) has a
            signature algorithm that is not one of the locally supported signature algorithms.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsUtilities.RequireAgreementCredentials(Org.BouncyCastle.Tls.TlsCredentials)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsUtilities.RequireDecryptorCredentials(Org.BouncyCastle.Tls.TlsCredentials)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsUtilities.RequireSignerCredentials(Org.BouncyCastle.Tls.TlsCredentials)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsUtilities.CheckClientCertificateType(Org.BouncyCastle.Tls.CertificateRequest,System.Int16,System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsUtilities.CheckExtensionData13(System.Collections.IDictionary,System.Int32,System.Int16)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsUtilities.GenerateEncryptedPreMasterSecret(Org.BouncyCastle.Tls.TlsContext,Org.BouncyCastle.Tls.Crypto.TlsEncryptor,System.IO.Stream)">
            <summary>Generate a pre_master_secret and send it encrypted to the server.</summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsUtilities.AddPreSharedKeyToClientExtensions(Org.BouncyCastle.Tls.TlsPsk[],System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsUtilities.AddPreSharedKeyToClientHello(Org.BouncyCastle.Tls.TlsClientContext,Org.BouncyCastle.Tls.TlsClient,System.Collections.IDictionary,System.Int32[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsUtilities.AddPreSharedKeyToClientHelloRetry(Org.BouncyCastle.Tls.TlsClientContext,Org.BouncyCastle.Tls.OfferedPsks.BindersConfig,System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TlsUtilities.GetPskExternalsClient(Org.BouncyCastle.Tls.TlsClient,System.Int32[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TrustedAuthority.Encode(System.IO.Stream)">
            <summary>Encode this <see cref="T:Org.BouncyCastle.Tls.TrustedAuthority"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.TrustedAuthority.Parse(System.IO.Stream)">
            <summary>Parse a <see cref="T:Org.BouncyCastle.Tls.TrustedAuthority"/> from a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="input">the <see cref="T:System.IO.Stream"/> to parse from.</param>
            <returns>a <see cref="T:Org.BouncyCastle.Tls.TrustedAuthority"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.UrlAndHash">
            <summary>RFC 6066 5.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.UrlAndHash.Encode(System.IO.Stream)">
            <summary>Encode this <see cref="T:Org.BouncyCastle.Tls.UrlAndHash"/> to a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="output">the <see cref="T:System.IO.Stream"/> to encode to.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Tls.UrlAndHash.Parse(Org.BouncyCastle.Tls.TlsContext,System.IO.Stream)">
            <summary>Parse a <see cref="T:Org.BouncyCastle.Tls.UrlAndHash"/> from a <see cref="T:System.IO.Stream"/>.</summary>
            <param name="context">the <see cref="T:Org.BouncyCastle.Tls.TlsContext"/> of the current connection.</param>
            <param name="input">the <see cref="T:System.IO.Stream"/> to parse from.</param>
            <returns>a <see cref="T:Org.BouncyCastle.Tls.UrlAndHash"/> object.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Tls.UserMappingType">
            <summary>RFC 4681</summary>
        </member>
        <member name="T:Org.BouncyCastle.Tls.UseSrtpData">
            <summary>RFC 5764 4.1.1</summary>
        </member>
        <member name="M:Org.BouncyCastle.Tls.UseSrtpData.#ctor(System.Int32[],System.Byte[])">
            <param name="protectionProfiles">see <see cref="T:Org.BouncyCastle.Tls.SrtpProtectionProfile"/> for valid constants.</param>
            <param name="mki">valid lengths from 0 to 255.</param>
        </member>
        <member name="P:Org.BouncyCastle.Tls.UseSrtpData.ProtectionProfiles">
            <returns>see <see cref="T:Org.BouncyCastle.Tls.SrtpProtectionProfile"/> for valid constants.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Tls.UseSrtpData.Mki">
            <returns>valid lengths from 0 to 255.</returns>
        </member>
    </members>
</doc>

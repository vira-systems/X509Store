<?xml version="1.0"?>
<doc>
    <assembly>
        <name>bcpkix-fips-1.0.2</name>
    </assembly>
    <members>
        <member name="T:Org.BouncyCastle.Cert.AttributeCertificateHolder">
            <remarks>
            The Holder object.
            <pre>
            Holder ::= SEQUENCE {
            	baseCertificateID   [0] IssuerSerial OPTIONAL,
            		-- the issuer and serial number of
            		-- the holder's Public Key Certificate
            	entityName          [1] GeneralNames OPTIONAL,
            		-- the name of the claimant or role
            	objectDigestInfo    [2] ObjectDigestInfo OPTIONAL
            		-- used to directly authenticate the holder,
            		-- for example, an executable
            }
            </pre>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Cert.AttributeCertificateHolder.#ctor(System.Int32,System.String,System.String,System.Byte[])">
             Constructs a holder for v2 attribute certificates with a hash value for
             some type of object.
             <p>
             <code>digestedObjectType</code> can be one of the following:
             <ul>
             <li>0 - publicKey - A hash of the public key of the holder must be
             passed.</li>
             <li>1 - publicKeyCert - A hash of the public key certificate of the
             holder must be passed.</li>
             <li>2 - otherObjectDigest - A hash of some other object type must be
             passed. <code>otherObjectTypeID</code> must not be empty.</li>
             </ul>
             </p>
             <p>This cannot be used if a v1 attribute certificate is used.</p>
            
             @param digestedObjectType The digest object type.
             @param digestAlgorithm The algorithm identifier for the hash.
             @param otherObjectTypeID The object type ID if
                        <code>digestedObjectType</code> is
                        <code>otherObjectDigest</code>.
             @param objectDigest The hash value.
        </member>
        <member name="P:Org.BouncyCastle.Cert.AttributeCertificateHolder.DigestedObjectType">
             Returns the digest object type if an object digest info is used.
             <p>
             <ul>
             <li>0 - publicKey - A hash of the public key of the holder must be
             passed.</li>
             <li>1 - publicKeyCert - A hash of the public key certificate of the
             holder must be passed.</li>
             <li>2 - otherObjectDigest - A hash of some other object type must be
             passed. <code>otherObjectTypeID</code> must not be empty.</li>
             </ul>
             </p>
            
             @return The digest object type or -1 if no object digest info is set.
        </member>
        <member name="P:Org.BouncyCastle.Cert.AttributeCertificateHolder.DigestAlgorithm">
             Returns the other object type ID if an object digest info is used.
            
             @return The other object type ID or <code>null</code> if no object
                     digest info is set.
        </member>
        <member name="M:Org.BouncyCastle.Cert.AttributeCertificateHolder.GetObjectDigest">
             Returns the hash if an object digest info is used.
            
             @return The hash or <code>null</code> if no object digest info is set.
        </member>
        <member name="P:Org.BouncyCastle.Cert.AttributeCertificateHolder.OtherObjectTypeID">
             Returns the digest algorithm ID if an object digest info is used.
            
             @return The digest algorithm ID or <code>null</code> if no object
                     digest info is set.
        </member>
        <member name="M:Org.BouncyCastle.Cert.AttributeCertificateHolder.GetEntityNames">
             Return any principal objects inside the attribute certificate holder entity names field.
            
             @return an array of IPrincipal objects (usually X500Name), null if no entity names field is set.
        </member>
        <member name="M:Org.BouncyCastle.Cert.AttributeCertificateHolder.GetIssuer">
             Return the principals associated with the issuer attached to this holder
            
             @return an array of principals, null if no BaseCertificateID is set.
        </member>
        <member name="P:Org.BouncyCastle.Cert.AttributeCertificateHolder.SerialNumber">
             Return the serial number associated with the issuer attached to this holder.
            
             @return the certificate serial number, null if no BaseCertificateID is set.
        </member>
        <member name="T:Org.BouncyCastle.Cert.AttributeCertificateIssuer">
            Carrying class for an attribute certificate issuer.
        </member>
        <member name="M:Org.BouncyCastle.Cert.AttributeCertificateIssuer.#ctor(Org.BouncyCastle.Asn1.X509.AttCertIssuer)">
             Set the issuer directly with the ASN.1 structure.
            
             @param issuer The issuer
        </member>
        <member name="M:Org.BouncyCastle.Cert.AttributeCertificateIssuer.GetPrincipals">
            <summary>Return any principal objects inside the attribute certificate issuer object.</summary>
            <returns>An array of IPrincipal objects (usually X509Principal).</returns>
        </member>
        <member name="M:Org.BouncyCastle.Cert.Selector.MSOutlookKeyIdCalculator.Sha1Digest.#ctor(Org.BouncyCastle.Cert.Selector.MSOutlookKeyIdCalculator.Sha1Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Cert.Selector.MSOutlookKeyIdCalculator.Sha1Digest.Reset">
            reset the chaining variables
        </member>
        <member name="M:Org.BouncyCastle.Cert.Selector.X509CertificateSelector.#ctor(System.Byte[])">
             Construct a selector with the value of a public key's subjectKeyId.
            
             @param subjectKeyId a subjectKeyId
        </member>
        <member name="M:Org.BouncyCastle.Cert.Selector.X509CertificateSelector.#ctor(Org.BouncyCastle.Asn1.X500.X500Name,Org.BouncyCastle.Math.BigInteger)">
             Construct a signer ID based on the issuer and serial number of the signer's associated
             certificate.
            
             @param issuer the issuer of the signer's associated certificate.
             @param serialNumber the serial number of the signer's associated certificate.
        </member>
        <member name="M:Org.BouncyCastle.Cert.Selector.X509CertificateSelector.#ctor(Org.BouncyCastle.Asn1.X500.X500Name,Org.BouncyCastle.Math.BigInteger,System.Byte[])">
             Construct a signer ID based on the issuer and serial number of the signer's associated
             certificate.
            
             @param issuer the issuer of the signer's associated certificate.
             @param serialNumber the serial number of the signer's associated certificate.
             @param subjectKeyId the subject key identifier to use to match the signers associated certificate.
        </member>
        <member name="T:Org.BouncyCastle.Cert.X509Attribute">
            Class for carrying the values in an X.509 Attribute.
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509Attribute.#ctor(Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param at an object representing an attribute.
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509Attribute.#ctor(System.String,Org.BouncyCastle.Asn1.Asn1Encodable)">
             Create an X.509 Attribute with the type given by the passed in oid and
             the value represented by an ASN.1 Set containing value.
            
             @param oid type of the attribute
             @param value value object to go into the atribute's value set.
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509Attribute.#ctor(System.String,Org.BouncyCastle.Asn1.Asn1EncodableVector)">
             Create an X.59 Attribute with the type given by the passed in oid and the
             value represented by an ASN.1 Set containing the objects in value.
            
             @param oid type of the attribute
             @param value vector of values to go in the attribute's value set.
        </member>
        <member name="T:Org.BouncyCastle.Cert.X509Certificate">
            <summary>
            An Object representing an X509 Certificate.
            Has static methods for loading Certificates encoded in many forms that return X509Certificate Objects.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Cert.X509Certificate.IsValidNow">
            <summary>
            Return true if the current time is within the start and end times nominated on the certificate.
            </summary>
            <returns>true id certificate is valid for the current time.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509Certificate.IsValid(System.DateTime)">
            <summary>
            Return true if the nominated time is within the start and end times nominated on the certificate.
            </summary>
            <param name="time">The time to test validity against.</param>
            <returns>True if certificate is valid for nominated time.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509Certificate.CheckValidity">
            <summary>
            Checks if the current date is within certificate's validity period.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509Certificate.CheckValidity(System.DateTime)">
            <summary>
            Checks if the given date is within certificate's validity period.
            </summary>
            <exception cref="T:Org.BouncyCastle.Cert.CertificateExpiredException">if the certificate is expired by given date</exception>
            <exception cref="T:Org.BouncyCastle.Cert.CertificateNotYetValidException">if the certificate is not yet valid on given date</exception>
        </member>
        <member name="P:Org.BouncyCastle.Cert.X509Certificate.Version">
            <summary>
            Return the certificate's version.
            </summary>
            <returns>An integer whose value Equals the version of the cerficate.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Cert.X509Certificate.SerialNumber">
            <summary>
            Return a <see cref="T:Org.BouncyCastle.Math.BigInteger">BigInteger</see> containing the serial number.
            </summary>
            <returns>The Serial number.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Cert.X509Certificate.IssuerDN">
            <summary>
            Get the Issuer Distinguished Name. (Who signed the certificate.)
            </summary>
            <returns>And X509Object containing name and value pairs.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Cert.X509Certificate.SubjectDN">
            <summary>
            Get the subject of this certificate.
            </summary>
            <returns>An X509Name object containing name and value pairs.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Cert.X509Certificate.NotBefore">
            <summary>
            The time that this certificate is valid from.
            </summary>
            <returns>A DateTime object representing that time in the local time zone.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Cert.X509Certificate.NotAfter">
            <summary>
            The time that this certificate is valid up to.
            </summary>
            <returns>A DateTime object representing that time in the local time zone.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509Certificate.GetTbsCertificate">
            <summary>
            Return the Der encoded TbsCertificate data.
            This is the certificate component less the signature.
            To Get the whole certificate call the GetEncoded() member.
            </summary>
            <returns>A byte array containing the Der encoded Certificate component.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509Certificate.GetSignature">
            <summary>
            The signature.
            </summary>
            <returns>A byte array containg the signature of the certificate.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Cert.X509Certificate.SigAlgName">
            <summary>
            A meaningful version of the Signature Algorithm. (EG SHA1WITHRSA)
            </summary>
            <returns>A sting representing the signature algorithm.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Cert.X509Certificate.SigAlgOid">
            <summary>
            Get the Signature Algorithms Object ID.
            </summary>
            <returns>A string containg a '.' separated object id.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509Certificate.GetSigAlgParams">
            <summary>
            Get the signature algorithms parameters. (EG DSA Parameters)
            </summary>
            <returns>A byte array containing the Der encoded version of the parameters or null if there are none.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Cert.X509Certificate.IssuerUniqueID">
            <summary>
            Get the issuers UID.
            </summary>
            <returns>A DerBitString.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Cert.X509Certificate.SubjectUniqueID">
            <summary>
            Get the subjects UID.
            </summary>
            <returns>A DerBitString.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509Certificate.GetKeyUsage">
            <summary>
            Get a key usage guidlines.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Cert.X509Certificate.SubjectPublicKeyInfo">
            <summary>
            Return the plain SubjectPublicKeyInfo that holds the encoded public key.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509Certificate.GetPublicKey">
            <summary>
            Get the public key of the subject of the certificate.
            </summary>
            <returns>The public key parameters.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509Certificate.GetEncoded">
            <summary>
            Return a Der encoded version of this certificate.
            </summary>
            <returns>A byte array.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509Certificate.Verify(Org.BouncyCastle.Crypto.IVerifierFactoryProvider{Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier})">
            <summary>
            Verify the certificate's signature using a verifier created using the passed in verifier provider.
            </summary>
            <param name="verifierProvider">An appropriate provider for verifying the certificate's signature.</param>
            <returns>True if the signature is valid.</returns>
            <exception cref="T:System.Exception">If verifier provider is not appropriate or the certificate algorithm is invalid.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509CertificateParser.ReadCertificate(System.Byte[])">
            <summary>
            Create loading data from byte array.
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509CertificateParser.ReadCertificates(System.Byte[])">
            <summary>
            Create loading data from byte array.
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509CertificateParser.ReadCertificate(System.IO.Stream)">
            Generates a certificate object and initializes it with the data
            read from the input stream inStream.
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509CertificateParser.ReadCertificates(System.IO.Stream)">
            Returns a (possibly empty) collection view of the certificates
            read from the given input stream inStream.
        </member>
        <member name="T:Org.BouncyCastle.Cert.X509Crl">
             The following extensions are listed in RFC 2459 as relevant to CRLs
            
             Authority Key Identifier
             Issuer Alternative Name
             CRL Number
             Delta CRL Indicator (critical)
             Issuing Distribution Point (critical)
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509Crl.Verify(Org.BouncyCastle.Crypto.IVerifierFactoryProvider{Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier})">
            <summary>
            Verify the CRL's signature using a verifier created using the passed in verifier provider.
            </summary>
            <param name="verifierProvider">An appropriate provider for verifying the CRL's signature.</param>
            <returns>True if the signature is valid.</returns>
            <exception cref="T:System.Exception">If verifier provider is not appropriate or the CRL algorithm is invalid.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509Crl.ToString">
             Returns a string representation of this CRL.
            
             @return a string representation of this CRL.
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509Crl.IsRevoked(Org.BouncyCastle.Cert.X509Certificate)">
             Checks whether the given certificate is on this CRL.
            
             @param cert the certificate to check for.
             @return true if the given certificate is on this CRL,
             false otherwise.
        </member>
        <member name="T:Org.BouncyCastle.Cert.X509CrlEntry">
             The following extensions are listed in RFC 2459 as relevant to CRL Entries
            
             ReasonCode Hode Instruction Code Invalidity Date Certificate Issuer
             (critical)
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509CrlEntry.#ctor(Org.BouncyCastle.Asn1.X509.CrlEntry,System.Boolean,Org.BouncyCastle.Asn1.X500.X500Name)">
             Constructor for CRLEntries of indirect CRLs. If <code>isIndirect</code>
             is <code>false</code> {@link #getCertificateIssuer()} will always
             return <code>null</code>, <code>previousCertificateIssuer</code> is
             ignored. If this <code>isIndirect</code> is specified and this CrlEntry
             has no certificate issuer CRL entry extension
             <code>previousCertificateIssuer</code> is returned by
             {@link #getCertificateIssuer()}.
            
             @param c
                        TbsCertificateList.CrlEntry object.
             @param isIndirect
                        <code>true</code> if the corresponding CRL is a indirect
                        CRL.
             @param previousCertificateIssuer
                        Certificate issuer of the previous CrlEntry.
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509ExtensionBase.GetNonCriticalExtensionOids">
            <summary>
            Get non critical extensions.
            </summary>
            <returns>A set of non critical extension oids.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509ExtensionBase.GetCriticalExtensionOids">
            <summary>
            Get any critical extensions.
            </summary>
            <returns>A set of critical extension oids.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509ExtensionBase.GetExtensionValue(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>
            Get the value of a given extension.
            </summary>
            <param name="oid">The object ID of the extension. </param>
            <returns>An Asn1OctetString object if that extension is found or null if not.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Cert.X509ExtensionUtilities">
            <summary>
            General utility methods for generating X.509 certificates.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509ExtensionUtilities.#ctor(Org.BouncyCastle.Crypto.IDigestFactory{Org.BouncyCastle.Crypto.Fips.FipsShs.Parameters})">
            <summary>
            Base constructor.
            </summary>
            <param name="digestFactory">The digest factory to base key info/identifier calculations on.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509ExtensionUtilities.CreateAuthorityKeyIdentifier(Org.BouncyCastle.Cert.X509Certificate)">
            <summary>
            Create an AuthorityKeyIdentifier from the passed in arguments.
            </summary>
            <param name="certHolder">the issuer certificate that the AuthorityKeyIdentifier should refer to.</param>
            <returns>an AuthorityKeyIdentifier.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509ExtensionUtilities.CreateAuthorityKeyIdentifier(Org.BouncyCastle.Crypto.IAsymmetricPublicKey)">
            <summary>
            Create an AuthorityKeyIdentifier from the passed in public key.
            </summary>
            <param name="publicKey">the public key to base the key identifier on.</param>
            <returns>an AuthorityKeyIdentifier.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509ExtensionUtilities.CreateAuthorityKeyIdentifier(Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo)">
            <summary>
            Create an AuthorityKeyIdentifier from the passed in SubjectPublicKeyInfo.
            </summary>
            <param name="publicKeyInfo">the SubjectPublicKeyInfo to base the key identifier on.</param>
            <returns>an AuthorityKeyIdentifier.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509ExtensionUtilities.CreateAuthorityKeyIdentifier(Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo,Org.BouncyCastle.Asn1.X509.GeneralNames,Org.BouncyCastle.Math.BigInteger)">
            <summary>
            Create an AuthorityKeyIdentifier from the passed in arguments.
            </summary>
            <param name="publicKeyInfo">the SubjectPublicKeyInfo to base the key identifier on.</param>
            <param name="generalNames">the general names to associate with the issuer cert's issuer.</param>
            <param name="serial">the serial number of the issuer cert.</param>
            <returns>an AuthorityKeyIdentifier.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509ExtensionUtilities.CreateSubjectKeyIdentifier(Org.BouncyCastle.Crypto.IAsymmetricPublicKey)">
            <summary>
            Return a RFC 5280 type 1 key identifier. As in: "(1) The keyIdentifier is composed of the 160-bit SHA-1 hash of the
            value of the BIT STRING subjectPublicKey(excluding the tag, length, and number of unused bits)."
            </summary>
            <param name="publicKey">the public key to base the identifier on.</param>
            <returns>the key identifier.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509ExtensionUtilities.CreateSubjectKeyIdentifier(Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo)">
            <summary>
            Return a RFC 5280 type 1 key identifier. As in: "(1) The keyIdentifier is composed of the 160-bit SHA-1 hash of the
            value of the BIT STRING subjectPublicKey(excluding the tag, length, and number of unused bits)."
            </summary>
            <param name="publicKeyInfo">the key info object containing the subjectPublicKey field.</param>
            <returns>the key identifier.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509ExtensionUtilities.CreateTruncatedSubjectKeyIdentifier(Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo)">
            <summary>
            Return a RFC 5280 type 2 key identifier. As in: "(2) The keyIdentifier is composed of a four bit type field with
            the value 0100 followed by the least significant 60 bits of the SHA-1 hash of the value of the BIT STRING subjectPublicKey.
            </summary>
            <param name="publicKeyInfo">the key info object containing the subjectPublicKey field.</param>
            <returns>the key identifier.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Cert.X509V1CertificateGenerator">
            <summary>
            Class to Generate X509V1 Certificates.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V1CertificateGenerator.#ctor">
            <summary>
            Default Constructor.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V1CertificateGenerator.Reset">
            <summary>
            Reset the generator.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V1CertificateGenerator.SetSerialNumber(Org.BouncyCastle.Math.BigInteger)">
            <summary>
            Set the certificate's serial number.
            </summary>
            <remarks>Make serial numbers long, if you have no serial number policy make sure the number is at least 16 bytes of secure random data.
            You will be surprised how ugly a serial number collision can get.</remarks>
            <param name="serialNumber">The serial number.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V1CertificateGenerator.SetIssuerDN(Org.BouncyCastle.Asn1.X500.X500Name)">
            <summary>
            Set the issuer distinguished name.
            The issuer is the entity whose private key is used to sign the certificate.
            </summary>
            <param name="issuer">The issuers DN.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V1CertificateGenerator.SetNotBefore(System.DateTime)">
            <summary>
            Set the date that this certificate is to be valid from.
            </summary>
            <param name="date">Date from which a generated certificate is valid.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V1CertificateGenerator.SetNotAfter(System.DateTime)">
            <summary>
            Set the date after which this certificate will no longer be valid.
            </summary>
            <param name="date">Date after which a generated certificate will expire.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V1CertificateGenerator.SetSubjectDN(Org.BouncyCastle.Asn1.X500.X500Name)">
            <summary>
            Set the DN of the entity that is represented by the generated certificate's public key.
            </summary>
            <param name="subject">The X.500 name of the generated certificate's subject.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V1CertificateGenerator.SetPublicKey(Org.BouncyCastle.Crypto.IAsymmetricPublicKey)">
            <summary>
            Set the public key that this certificate identifies.
            </summary>
            <param name="publicKey">The public key to be carried by the generated certificate.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V1CertificateGenerator.Generate(Org.BouncyCastle.Crypto.ISignatureFactory{Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier})">
            <summary>
            Generate a new X509Certificate using the passed in SignatureCalculator.
            </summary>
            <param name="signatureCalculatorFactory">A signature calculator factory with the necessary algorithm details.</param>
            <returns>An X509Certificate.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Cert.X509V2AttributeCertificate">
            <summary>An implementation of a version 2 X.509 Attribute Certificate.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V2AttributeCertificate.Verify(Org.BouncyCastle.Crypto.IVerifierFactoryProvider{Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier})">
            <summary>
            Verify the certificate's signature using a verifier created using the passed in verifier provider.
            </summary>
            <param name="verifierProvider">An appropriate provider for verifying the certificate's signature.</param>
            <returns>True if the signature is valid.</returns>
            <exception cref="T:System.Exception">If verifier provider is not appropriate or the certificate algorithm is invalid.</exception>
        </member>
        <member name="T:Org.BouncyCastle.Cert.X509V2AttributeCertificateGenerator">
            <remarks>Class to produce an X.509 Version 2 AttributeCertificate.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V2AttributeCertificateGenerator.Reset">
            <summary>Reset the generator</summary>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V2AttributeCertificateGenerator.SetHolder(Org.BouncyCastle.Cert.AttributeCertificateHolder)">
            <summary>Set the Holder of this Attribute Certificate.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V2AttributeCertificateGenerator.SetIssuer(Org.BouncyCastle.Cert.AttributeCertificateIssuer)">
            <summary>Set the issuer.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V2AttributeCertificateGenerator.SetSerialNumber(Org.BouncyCastle.Math.BigInteger)">
            <summary>Set the serial number for the certificate.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V2AttributeCertificateGenerator.AddAttribute(Org.BouncyCastle.Cert.X509Attribute)">
            <summary>Add an attribute.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V2AttributeCertificateGenerator.AddExtension(System.String,System.Boolean,Org.BouncyCastle.Asn1.Asn1Encodable)">
            <summary>Add a given extension field for the standard extensions tag.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V2AttributeCertificateGenerator.AddExtension(System.String,System.Boolean,System.Byte[])">
            <summary>
            Add a given extension field for the standard extensions tag.
            The value parameter becomes the contents of the octet string associated
            with the extension.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V2AttributeCertificateGenerator.Generate(Org.BouncyCastle.Crypto.ISignatureFactory{Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier})">
            <summary>
            Generate a new X.509 Attribute Certificate using the passed in SignatureCalculator.
            </summary>
            <param name="signatureCalculatorFactory">A signature calculator factory with the necessary algorithm details.</param>
            <returns>An IX509AttributeCertificate.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Cert.X509V2CrlGenerator">
            <summary>
            Generator for an X.509 Version 2 CRL.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V2CrlGenerator.#ctor">
            <summary>
            Base constructor.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V2CrlGenerator.Reset">
            <summary>
            Reset the generator.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V2CrlGenerator.SetIssuerDN(Org.BouncyCastle.Asn1.X500.X500Name)">
            <summary>
            Set the issuer distinguished name - the issuer is the entity whose private key is used to sign the
            certificate.
            </summary>
            <param name="issuer">The issuer name.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V2CrlGenerator.SetThisUpdate(System.DateTime)">
            <summary>
            
            </summary>
            <param name="date"></param>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V2CrlGenerator.SetNextUpdate(System.DateTime)">
            <summary>
            
            </summary>
            <param name="date"></param>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V2CrlGenerator.AddCrlEntry(Org.BouncyCastle.Math.BigInteger,System.DateTime,System.Int32)">
            <summary>
            Add a CRL entry with a CrlReason extension.
            Reason being as indicated by CrlReason, i.e.CrlReason.KeyCompromise or 0 if CrlReason is not to be used
            </summary>
            <param name="userCertificate">The serial number of the certificate being revoked.</param>
            <param name="revocationDate">The date of revocation.</param>
            <param name="reason">The reason for revocation.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V2CrlGenerator.AddCrlEntry(Org.BouncyCastle.Math.BigInteger,System.DateTime,System.Int32,System.DateTime)">
            <summary>
            Add a CRL entry with an Invalidity Date extension as well as a CrlReason extension.
            Reason being as indicated by CrlReason, i.e.CrlReason.KeyCompromise or 0 if CrlReason is not to be used
            </summary>
            <param name="userCertificate">The serial number of the certificate being revoked.</param>
            <param name="revocationDate">The date of revocation.</param>
            <param name="reason">The reason for revocation.</param>
            <param name="invalidityDate">The invalidity date.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V2CrlGenerator.AddCrlEntry(Org.BouncyCastle.Math.BigInteger,System.DateTime,Org.BouncyCastle.Asn1.X509.X509Extensions)">
            <summary>
            Add a CRL entry with extensions.
            </summary>
            <param name="userCertificate">Serial number of certificate to be revoked.</param>
            <param name="revocationDate">Revocation date of the certificate.</param>
            <param name="extensions">The extensions to be associated with the CRL entry.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V2CrlGenerator.AddCrl(Org.BouncyCastle.Cert.X509Crl)">
            <summary>
            Add the CRLEntry objects contained in a previous CRL.
            </summary>
            <param name="other">A source CRL for CRL entry objects.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V2CrlGenerator.AddExtension(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Boolean,Org.BouncyCastle.Asn1.Asn1Encodable)">
            <summary>
            Add a given extension field for the standard extensions tag (tag 0)
            </summary>
            <param name="oid">The object identifier identifying the extension type.</param>
            <param name="critical">true if the extension should be regarded as critical, false otherwise.</param>
            <param name="extensionValue">The ASN.1 object to be encoded as the extension's value.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V2CrlGenerator.AddExtension(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Boolean,System.Byte[])">
            <summary>
            Add a given extension field for the standard extensions tag (tag 0)
            </summary>
            <param name="oid">Its Object Identifier.</param>
            <param name="critical">Is it critical.</param>
            <param name="extensionValue">byte[] containing the value of this extension.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V2CrlGenerator.Generate(Org.BouncyCastle.Crypto.ISignatureFactory{Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier})">
            <summary>
            Generate a new X509CRL using the passed in SignatureCalculator.
            </summary>
            <param name="signatureCalculatorFactory">A signature calculator factory with the necessary algorithm details.</param>
            <returns>An X509CRL.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Cert.X509V3CertificateGenerator">
            <summary>
            A class to Generate Version 3 X509Certificates.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V3CertificateGenerator.#ctor">
            <summary>
            Base constructor.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V3CertificateGenerator.Reset">
            <summary>
            Reset the Generator.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V3CertificateGenerator.SetSerialNumber(Org.BouncyCastle.Math.BigInteger)">
            <summary>
            Set the certificate's serial number.
            </summary>
            <remarks>Make serial numbers long, if you have no serial number policy make sure the number is at least 16 bytes of secure random data.
            You will be surprised how ugly a serial number collision can Get.</remarks>
            <param name="serialNumber">The serial number.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V3CertificateGenerator.SetIssuerDN(Org.BouncyCastle.Asn1.X500.X500Name)">
            <summary>
            Set the distinguished name of the issuer.
            The issuer is the entity which is signing the certificate.
            </summary>
            <param name="issuer">The issuer's DN.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V3CertificateGenerator.SetNotBefore(System.DateTime)">
            <summary>
            Set the date that this certificate is to be valid from.
            </summary>
            <param name="date">Date from which a generated certificate is valid.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V3CertificateGenerator.SetNotAfter(System.DateTime)">
            <summary>
            Set the date after which this certificate will no longer be valid.
            </summary>
            <param name="date">Date after which a generated certificate will expire.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V3CertificateGenerator.SetSubjectDN(Org.BouncyCastle.Asn1.X500.X500Name)">
            <summary>
            Set the DN of the entity that is represented by the generated certificate's public key.
            </summary>
            <param name="subject">The X.500 name of the generated certificate's subject.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V3CertificateGenerator.SetPublicKey(Org.BouncyCastle.Crypto.IAsymmetricPublicKey)">
            <summary>
            Set the public key that this certificate identifies.
            </summary>
            <param name="publicKey">The public key to be carried by the generated certificate.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V3CertificateGenerator.SetSubjectUniqueID(System.Boolean[])">
            <summary>
            Set the subject unique ID - note: it is very rare that it is correct to do this.
            </summary>
            <param name="uniqueID">The subject unique ID.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V3CertificateGenerator.SetIssuerUniqueID(System.Boolean[])">
            <summary>
            Set the issuer unique ID - note: it is very rare that it is correct to do this.
            </summary>
            <param name="uniqueID">The issuer unique ID.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V3CertificateGenerator.AddExtension(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Boolean,Org.BouncyCastle.Asn1.Asn1Encodable)">
            <summary>
            Add the given extension details to the certificate.
            </summary>
            <param name="oid">The object identifier identifying the extension type.</param>
            <param name="critical">true if the extension should be regarded as critical, false otherwise.</param>
            <param name="extensionValue">The ASN.1 object to be encoded as the extension's value.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V3CertificateGenerator.AddExtension(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Boolean,System.Byte[])">
            <summary>
            Add an extension to this certificate.
            </summary>
            <param name="oid">Its Object Identifier.</param>
            <param name="critical">true, if the extension should be regarded as critical critical.</param>
            <param name="extensionValue">byte[] containing the value octets of this extension.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V3CertificateGenerator.CopyAndAddExtension(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Boolean,Org.BouncyCastle.Cert.X509Certificate)">
            <summary>
            Add a given extension field for the standard extensions tag (tag 3),
            copying the extension value from another certificate.
            </summary>
            <param name="oid">The object identifier of the extension to be copied.</param>
            <param name="critical">true, if the copied extension should be regarded as critical critical.</param>
            <param name="cert">The source certificate to copy the extension from.</param>
            <exception cref="T:Org.BouncyCastle.Cert.CertificateParsingException">If the extension cannot be extracted.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Cert.X509V3CertificateGenerator.Generate(Org.BouncyCastle.Crypto.ISignatureFactory{Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier})">
            <summary>
            Generate a new X509Certificate using the passed in SignatureCalculator.
            </summary>
            <param name="signatureCalculatorFactory">A signature calculator factory with the necessary algorithm details.</param>
            <returns>An X509Certificate.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Cmp.PKMacBuilder.#ctor">
            <summary>
            Default, IterationCount = 1000, OIW=IdSha1, Mac=HmacSHA1
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Cmp.PKMacBuilder.#ctor(Org.BouncyCastle.Crmf.IPKMacPrimitivesProvider)">
            <summary>
            Defaults with IPKMacPrimitivesProvider
            </summary>
            <param name="provider"></param>
        </member>
        <member name="M:Org.BouncyCastle.Cmp.PKMacBuilder.#ctor(Org.BouncyCastle.Crmf.IPKMacPrimitivesProvider,Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier,Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier)">
            <summary>
            Create.
            </summary>
            <param name="provider">The Mac provider</param>
            <param name="digestAlgorithmIdentifier">Digest Algorithm Id</param>
            <param name="macAlgorithmIdentifier">Mac Algorithm Id</param>
        </member>
        <member name="M:Org.BouncyCastle.Cmp.PKMacBuilder.#ctor(Org.BouncyCastle.Crmf.IPKMacPrimitivesProvider,System.Int32)">
            <summary>
            Create a PKMAC builder enforcing a ceiling on the maximum iteration count.
            </summary>
            <param name="provider">supporting calculator</param>
            <param name="maxIterations">max allowable value for iteration count.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cmp.PKMacBuilder.SetSaltLength(System.Int32)">
             Set the salt length in octets.
            
             @param saltLength length in octets of the salt to be generated.
             @return the generator
        </member>
        <member name="M:Org.BouncyCastle.Cmp.PKMacBuilder.SetIterationCount(System.Int32)">
            <summary>
            Set the iteration count.
            </summary>
            <param name="iterationCount">the iteration count.</param>
            <returns>this</returns>
            <exception cref="T:System.ArgumentException">if iteration count is less than 100</exception>
        </member>
        <member name="M:Org.BouncyCastle.Cmp.PKMacBuilder.SetParameters(Org.BouncyCastle.Asn1.Cmp.PbmParameter)">
            <summary>
            Set PbmParameters
            </summary>
            <param name="parameters">The parameters.</param>
            <returns>this</returns>
        </member>
        <member name="M:Org.BouncyCastle.Cmp.PKMacBuilder.SetSecureRandom(Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            The Secure random
            </summary>
            <param name="random">The random.</param>
            <returns>this</returns>
        </member>
        <member name="M:Org.BouncyCastle.Cmp.PKMacBuilder.Build(System.Char[])">
            <summary>
            Build an IMacFactory.
            </summary>
            <param name="password">The password.</param>
            <returns>IMacFactory</returns>
        </member>
        <member name="T:Org.BouncyCastle.Cmp.ProtectedPkiMessage">
            <summary>
            Wrapper for a PKIMessage with protection attached to it.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Cmp.ProtectedPkiMessage.#ctor(Org.BouncyCastle.Asn1.Cmp.GeneralPkiMessage)">
            <summary>
            Wrap a general message.
            </summary>
            <exception cref="T:System.ArgumentException">If the general message does not have protection.</exception>
            <param name="pkiMessage">The General message</param>
        </member>
        <member name="M:Org.BouncyCastle.Cmp.ProtectedPkiMessage.#ctor(Org.BouncyCastle.Asn1.Cmp.PkiMessage)">
            <summary>
            Wrap a PKI message.
            </summary>
            <exception cref="T:System.ArgumentException">If the PKI message does not have protection.</exception>
            <param name="pkiMessage">The PKI message</param>
        </member>
        <member name="P:Org.BouncyCastle.Cmp.ProtectedPkiMessage.Header">
            <summary>
            Message header
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Cmp.ProtectedPkiMessage.Body">
            <summary>
            Message Body
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Cmp.ProtectedPkiMessage.ToAsn1Message">
            <summary>
            Return the underlying ASN.1 structure contained in this object.
            </summary>
            <returns>PKI Message structure</returns>
        </member>
        <member name="P:Org.BouncyCastle.Cmp.ProtectedPkiMessage.HasPasswordBasedMacProtected">
            <summary>
            Determine whether the message is protected by a password based MAC. Use verify(PKMACBuilder, char[])
            to verify the message if this method returns true.
            </summary>
            <returns>true if protection MAC PBE based, false otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Cmp.ProtectedPkiMessage.GetCertificates">
            <summary>
            Return the extra certificates associated with this message.
            </summary>
            <returns>an array of extra certificates, zero length if none present.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Cmp.ProtectedPkiMessage.Verify(Org.BouncyCastle.Crypto.IVerifierFactory{Org.BouncyCastle.Crypto.IParameters{Org.BouncyCastle.Crypto.Algorithm}})">
            <summary>
            Verify a message with a public key based signature attached.
            </summary>
            <param name="verifierFactory">a factory of signature verifiers.</param>
            <returns>true if the provider is able to create a verifier that validates the signature, false otherwise.</returns>      
        </member>
        <member name="M:Org.BouncyCastle.Cmp.ProtectedPkiMessage.Verify(Org.BouncyCastle.Cmp.PKMacBuilder,System.Char[])">
            <summary>
            Verify a message with password based MAC protection.
            </summary>
            <param name="pkMacBuilder">MAC builder that can be used to construct the appropriate MacCalculator</param>
            <param name="password">the MAC password</param>
            <returns>true if the passed in password and MAC builder verify the message, false otherwise.</returns>
            <exception cref="T:System.InvalidOperationException">if algorithm not MAC based, or an exception is thrown verifying the MAC.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.GeneralPkiMessage.#ctor(Org.BouncyCastle.Asn1.Cmp.PkiMessage)">
            <summary>
            Wrap a PKIMessage ASN.1 structure.
            </summary>
            <param name="pkiMessage">PKI message.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Cmp.GeneralPkiMessage.#ctor(System.Byte[])">
            <summary>
            Create a PKIMessage from the passed in bytes.
            </summary>
            <param name="encoding">BER/DER encoding of the PKIMessage</param>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Cmp.GeneralPkiMessage.HasProtection">
            <summary>
            Return true if this message has protection bits on it. A return value of true
            indicates the message can be used to construct a ProtectedPKIMessage.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsContentInfoParser.Close">
            Close the underlying data stream.
            @throws IOException if the close fails.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEncryptedData.ToAsn1Structure">
            <summary>
            Return the ContentInfo
            </summary>
            <returns>The underlying ContentInfo object.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEncryptedDataGenerator.#ctor">
            base constructor
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEncryptedDataGenerator.generate(Org.BouncyCastle.Cms.ICmsTypedData,Org.BouncyCastle.Crypto.ICipherBuilder{Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier})">
             generate an encrypted object that contains an Cms Encrypted Data structure.
            
             @param content the content to be encrypted
             @param contentEncryptor the symmetric key based encryptor to encrypt the content with.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEncryptedGenerator.#ctor">
            base constructor
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsEnvelopedData">
            containing class for an CMS Enveloped Data object
        </member>
        <member name="P:Org.BouncyCastle.Cms.CmsEnvelopedData.EncryptionAlgOid">
            return the object identifier for the content encryption algorithm.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedData.GetRecipientInfos">
            return a store of the intended recipients for this message
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedData.ToAsn1Structure">
            <summary>
            Return the underlying ASN.1 structure for this object.
            </summary>
            <returns>A ContentInfo object.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedData.GetUnprotectedAttributes">
            return a table of the unprotected attributes indexed by
            the OID of the attribute.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedData.GetEncoded">
            return the ASN.1 encoded representation of this object.
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsEnvelopedDataGenerator">
            <summary>
             General class for generating a CMS enveloped-data message.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedDataGenerator.#ctor">
            base constructor
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedDataGenerator.generate(Org.BouncyCastle.Cms.ICmsTypedData,Org.BouncyCastle.Crypto.ICipherBuilderWithKey{Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier})">
            <summary>
            Generate an enveloped object that contains an CMS Enveloped Data object using the given provider.
            </summary>
            <param name="content">The content to be encrypted</param>
            <param name="contentEncryptorBuilder">The symmetric key based encryptor to encrypt the content with.</param>
            <returns>A new CMS EnvelopedData object.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsEnvelopedGenerator">
            <summary>
            General class for generating a CMS enveloped-data message.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedGenerator.#ctor">
            base constructor
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsEnvelopedGenerator.AddRecipientInfoGenerator(Org.BouncyCastle.Cms.IRecipientInfoGenerator)">
            Add a generator to produce the recipient info required.
            
            @param recipientGenerator a generator of a recipient info object.
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsSignedData">
             general class for handling a pkcs7-signature message.
            
             A simple example of usage - note, in the example below the validity of
             the certificate isn't verified, just the fact that one of the certs
             matches the given signer...
            
             <pre>
              IX509Store              certs = s.GetCertificates();
              SignerInformationStore  signers = s.GetSignerInfos();
            
              foreach (SignerInformation signer in signers.GetSigners())
              {
                  ArrayList       certList = new ArrayList(certs.GetMatches(signer.SignerID));
                  X509Certificate cert = (X509Certificate) certList[0];
            
                  if (signer.Verify(cert.GetPublicKey()))
                  {
                      verified++;
                  }
              }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedData.#ctor(System.Byte[])">
            <summary>
            Base constructor - with encapsulated content
            </summary>
            <param name="sigBlock">A byte array containing a ContentInfo containing a signedData object.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedData.#ctor(Org.BouncyCastle.Cms.ICmsTypedData,System.Byte[])">
            <summary>
            Base constructor - with detached signature.
            </summary>
            <param name="signedContent">The content that was signed.</param>
            <param name="sigBlock">A byte array containing a ContentInfo containing a signedData object.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedData.#ctor(System.Collections.Generic.IDictionary{Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Byte[]},System.Byte[])">
            <summary>
            Content with detached signature, digests precomputed in hashes.
            </summary>
            <param name="hashes">A map of precomputed digests for content indexed by name of hash.</param>
            <param name="sigBlock">The content info signature object.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedData.#ctor(Org.BouncyCastle.Cms.ICmsTypedData,System.IO.Stream)">
            <summary>
            Stream constructor - with detached signature.
            </summary>
            <param name="signedContent">The content that was signed.</param>
            <param name="sigData">A stream representing a ContentInfo containing a signedData object.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedData.#ctor(System.IO.Stream)">
            <summary>
            Stream constructor - with encapsulated content
            </summary>
            <param name="sigData">A stream representing a ContentInfo containing a signedData object.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedData.#ctor(Org.BouncyCastle.Cms.ICmsTypedData,Org.BouncyCastle.Asn1.Cms.ContentInfo)">
            <summary>
            ContentInfo constructor - with detached signature.
            </summary>
            <param name="signedContent">The content that was signed.</param>
            <param name="sigData">A ContentInfo containing a signedData object.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedData.#ctor(System.Collections.Generic.IDictionary{Org.BouncyCastle.Asn1.DerObjectIdentifier,System.Byte[]},Org.BouncyCastle.Asn1.Cms.ContentInfo)">
            <summary>
            ContentInfo with detached signature, digests precomputed in hashes.
            </summary>
            <param name="hashes">A map of precomputed digests for content indexed by name of hash.</param>
            <param name="sigData">A ContentInfo containing a signedData object.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedData.#ctor(Org.BouncyCastle.Asn1.Cms.ContentInfo)">
            <summary>
            ContentInfo constructor - with encapsulated content
            </summary>
            <param name="sigData">A ContentInfo containing a signedData object.</param>
        </member>
        <member name="P:Org.BouncyCastle.Cms.CmsSignedData.Version">
            <summary>Return the version number for this object.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Cms.CmsSignedData.IsDetachedSignature">
            <summary>
            Return true if this message represents a detached signature, false otherwise.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Cms.CmsSignedData.IsCertificateManagementMessage">
            <summary>
            Return true if this is object represents a certificate management message.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedData.GetSignerInfos">
            <summary>
            Return the collection of signers that are associated with the signatures for the message.
            </summary>
            <returns>A (possibly empty) collection of signers.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedData.GetAttributeCertificates(System.String)">
             return a X509Store containing the attribute certificates, if any, contained
             in this message.
            
             @param type type of store to create
             @return a store of attribute certificates
             @exception NoSuchStoreException if the store type isn't available.
             @exception CmsException if a general exception prevents creation of the X509Store
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedData.GetCertificates">
             return a Store containing the public key certificates, if any, contained
             in this message.
            
             @param type type of store to create
             @return a store of public key certificates
             @exception NoSuchStoreException if the store type isn't available.
             @exception CmsException if a general exception prevents creation of the X509Store
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedData.GetCrls">
             return a Store containing CRLs, if any, contained
             in this message.
            
             @param type type of store to create
             @return a store of CRLs
             @exception NoSuchStoreException if the store type isn't available.
             @exception CmsException if a general exception prevents creation of the X509Store
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedData.GetEncoded">
            <summary>
            Return the ASN.1 encoded representation of this object.
            </summary>
            <returns>A BER encoded byte arrary representing the object.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedData.ToAsn1Structure">
            <summary>
            Return the underlying ASN.1 structure for this object.
            </summary>
            <returns>A ContentInfo object.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedData.ReplaceSigners(Org.BouncyCastle.Cms.CmsSignedData,Org.BouncyCastle.Cms.SignerInformationStore)">
             Replace the signerinformation store associated with this
             CmsSignedData object with the new one passed in. You would
             probably only want to do this if you wanted to change the unsigned
             attributes associated with a signer, or perhaps delete one.
            
             @param signedData the signed data object to be used as a base.
             @param signerInformationStore the new signer information store to use.
             @return a new signed data object.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedData.ReplaceCertificatesAndCrls(Org.BouncyCastle.Cms.CmsSignedData,Org.BouncyCastle.Utilities.IStore{Org.BouncyCastle.Cert.X509Certificate},Org.BouncyCastle.Utilities.IStore{Org.BouncyCastle.Cert.X509Crl},Org.BouncyCastle.Utilities.IStore{Org.BouncyCastle.Cert.X509V2AttributeCertificate})">
             Replace the certificate and CRL information associated with this
             CmsSignedData object with the new one passed in.
            
             @param signedData the signed data object to be used as a base.
             @param x509Certs the new certificates to be used.
             @param x509Crls the new CRLs to be used.
             @return a new signed data object.
             @exception CmsException if there is an error processing the stores
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsSignedDataGenerator">
                 * general class for generating a pkcs7-signature message.
                 * <p>
                 * A simple example of usage.
                 *
                 * <pre>
                 *      IX509Store certs...
                 *      IX509Store crls...
                 *      CmsSignedDataGenerator gen = new CmsSignedDataGenerator();
                 *
                 *      gen.AddSigner(privKey, cert, CmsSignedGenerator.DigestSha1);
                 *      gen.AddCertificates(certs);
                 *      gen.AddCrls(crls);
                 *
                 *      CmsSignedData data = gen.Generate(content);
                 * </pre>
            	 * </p>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataGenerator.#ctor">
            <summary>
            Base constructor.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataGenerator.Generate(Org.BouncyCastle.Cms.ICmsTypedData)">
            generate a signed object that for a CMS Signed Data object
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataGenerator.Generate(Org.BouncyCastle.Cms.ICmsTypedData,System.Boolean)">
            generate a signed object that for a CMS Signed Data
            object  - if encapsulate is true a copy
            of the message will be included in the signature. The content type
            is set according to the OID represented by the string signedContentType.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataGenerator.GenerateCounterSigners(Org.BouncyCastle.Cms.SignerInformation)">
             generate a set of one or more SignerInformation objects representing counter signatures on
             the passed in SignerInformation object.
            
             @param signer the signer to be countersigned
             @param sigProvider the provider to be used for counter signing.
             @return a store containing the signers.
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsSignedDataParser">
             Parsing class for an CMS Signed Data object from an input stream.
             <p>
             Note: that because we are in a streaming mode only one signer can be tried and it is important
             that the methods on the parser are called in the appropriate order.
             </p>
             <p>
             A simple example of usage for an encapsulated signature.
             </p>
             <p>
             Two notes: first, in the example below the validity of
             the certificate isn't verified, just the fact that one of the certs
             matches the given signer, and, second, because we are in a streaming
             mode the order of the operations is important.
             </p>
             <pre>
                  CmsSignedDataParser     sp = new CmsSignedDataParser(encapSigData);
            
                  sp.GetSignedContent().Drain();
            
                  IX509Store              certs = sp.GetCertificates();
                  SignerInformationStore  signers = sp.GetSignerInfos();
            
                  foreach (SignerInformation signer in signers.GetSigners())
                  {
                      ArrayList       certList = new ArrayList(certs.GetMatches(signer.SignerID));
                      X509Certificate cert = (X509Certificate) certList[0];
            
                      Console.WriteLine("verify returns: " + signer.Verify(cert));
                  }
             </pre>
              Note also: this class does not introduce buffering - if you are processing large files you should create
              the parser with:
              <pre>
                      CmsSignedDataParser     ep = new CmsSignedDataParser(new BufferedInputStream(encapSigData, bufSize));
              </pre>
              where bufSize is a suitably large buffer size.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataParser.#ctor(System.IO.Stream)">
            base constructor - with encapsulated content
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataParser.#ctor(Org.BouncyCastle.Cms.CmsTypedStream,System.IO.Stream)">
             base constructor
            
             @param signedContent the content that was signed.
             @param sigData the signature object.
        </member>
        <member name="P:Org.BouncyCastle.Cms.CmsSignedDataParser.Version">
             Return the version number for the SignedData object
            
             @return the version number
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataParser.GetSignerInfos">
            return the collection of signers that are associated with the
            signatures for the message.
            @throws CmsException
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataParser.GetAttributeCertificates">
             return a X509Store containing the attribute certificates, if any, contained
             in this message.
            
             @param type type of store to create
             @return a store of attribute certificates
             @exception org.bouncycastle.x509.NoSuchStoreException if the store type isn't available.
             @exception CmsException if a general exception prevents creation of the X509Store
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataParser.GetCertificates">
             return a X509Store containing the public key certificates, if any, contained
             in this message.
            
             @param type type of store to create
             @return a store of public key certificates
             @exception NoSuchStoreException if the store type isn't available.
             @exception CmsException if a general exception prevents creation of the X509Store
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataParser.GetCrls">
             return a X509Store containing CRLs, if any, contained
             in this message.
            
             @param type type of store to create
             @return a store of CRLs
             @exception NoSuchStoreException if the store type isn't available.
             @exception CmsException if a general exception prevents creation of the X509Store
        </member>
        <member name="P:Org.BouncyCastle.Cms.CmsSignedDataParser.SignedContentType">
            <summary>
            Return the <c>DerObjectIdentifier</c> associated with the encapsulated
            content info structure carried in the signed data.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedDataParser.GetAsn1Set(Org.BouncyCastle.Asn1.Asn1SetParser)">
            Replace the certificate and CRL information associated with this
            CMSSignedData object with the new one passed in.
            <p>
            The output stream is returned unclosed.
            </p>
            @param original the signed data stream to be used as a base.
            @param certsAndCrls the new certificates and CRLs to be used.
            @param out the stream to Write the new signed data object to.
            @return out.
            @exception CmsException if there is an error processing the CertStore
        </member>
        <member name="F:Org.BouncyCastle.Cms.CmsSignedGenerator.Data">
            Default type for the signed data.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedGenerator.AddAttributeCertificates(Org.BouncyCastle.Utilities.IStore{Org.BouncyCastle.Cert.X509V2AttributeCertificate})">
             Add the attribute certificates contained in the passed in store to the
             generator.
            
             @param store a store of Version 2 attribute certificates
             @throws CmsException if an error occurse processing the store.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedGenerator.AddSigners(Org.BouncyCastle.Cms.SignerInformationStore)">
             Add a store of precalculated signers to the generator.
            
             @param signerStore store of signers
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedGenerator.GetGeneratedDigests">
             Return a map of oids and byte arrays representing the digests calculated on the content during
             the last generate.
            
             @return a map of oids (as String objects) and byte[] representing digests.
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedHelper.GetDigestAlgName(System.String)">
            Return the digest algorithm using one of the standard JCA string
            representations rather than the algorithm identifier (if possible).
        </member>
        <member name="M:Org.BouncyCastle.Cms.CmsSignedHelper.GetEncryptionAlgName(System.String)">
            Return the digest encryption algorithm using one of the standard
            JCA string representations rather than the algorithm identifier (if
            possible).
        </member>
        <member name="T:Org.BouncyCastle.Cms.DefaultSignedAttributeTableGenerator">
            Default signed attributes generator.
        </member>
        <member name="M:Org.BouncyCastle.Cms.DefaultSignedAttributeTableGenerator.#ctor">
            Initialise to use all defaults
        </member>
        <member name="M:Org.BouncyCastle.Cms.DefaultSignedAttributeTableGenerator.#ctor(Org.BouncyCastle.Asn1.Cms.AttributeTable)">
             Initialise with some extra attributes or overrides.
            
             @param attributeTable initial attribute table to use.
        </member>
        <member name="M:Org.BouncyCastle.Cms.DefaultSignedAttributeTableGenerator.createStandardAttributeTable(System.Collections.Generic.IDictionary{System.String,System.Object})">
             Create a standard attribute table from the passed in parameters - this will
             normally include contentType, signingTime, and messageDigest. If the constructor
             using an AttributeTable was used, entries in it for contentType, signingTime, and
             messageDigest will override the generated ones.
            
             @param parameters source parameters for table generation.
            
             @return a filled in Hashtable of attributes.
        </member>
        <member name="M:Org.BouncyCastle.Cms.DefaultSignedAttributeTableGenerator.GetAttributes(System.Collections.Generic.IDictionary{System.String,System.Object})">
            @param parameters source parameters
            @return the populated attribute table
        </member>
        <member name="T:Org.BouncyCastle.Cms.CmsAttributeTableParameter">
            <remarks>
            The 'Signature' parameter is only available when generating unsigned attributes.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Cms.ICmsAttributeTableGenerator">
            <summary>
            Base interface for a CMS Attribute table generator.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Cms.ICmsAttributeTableGenerator.GetAttributes(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Construct an AttributeTable from the passed in dictionary of (key, value) pairs.
            </summary>
            <param name="parameters">The (key, value) pairs to construct the returned table from.</param>
            <returns>A new attribute table.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Cms.ICmsTypedData.Write(System.IO.Stream)">
            <summary>
            generic routine to copy out the data we want processed - the OutputStream
            passed in will do the handling on it's own.
            Note: this routine may be called multiple times.
            </summary>
            <param name="output"></param>
        </member>
        <member name="P:Org.BouncyCastle.Cms.IRecipientID`1.Type">
            <summary>
             Return the type code for this recipient ID.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Cms.ISignatureEncryptionAlgorithmFinder">
            <summary>
            Finder which is used to look up the algorithm identifiers representing the encryption algorithms that
            are associated with a particular signature algorithm.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Cms.ISignatureEncryptionAlgorithmFinder.FindEncryptionAlgorithm(Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier)">
            <summary>
            Return the encryption algorithm identifier associated with the passed in signatureAlgorithm
            </summary>
            <param name="signatureAlgorithm">the algorithm identifier of the signature of interest</param>
            <returns>the algorithm identifier to be associated with the encryption algorithm used in signature creation.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Cms.KeyTransRecipientID.#ctor(System.Byte[])">
            <summary>
            Construct a key trans recipient ID with the value of a public key's subjectKeyId.
            </summary>
            <param name="subjectKeyId">a subjectKeyId</param>
        </member>
        <member name="M:Org.BouncyCastle.Cms.KeyTransRecipientID.#ctor(Org.BouncyCastle.Asn1.X500.X500Name,Org.BouncyCastle.Math.BigInteger)">
            <summary>
            Construct a key trans recipient ID based on the issuer and serial number of the recipient's associated certificate.
            </summary>
            <param name="issuer">The issuer of the recipient's associated certificate.</param>
            <param name="serialNumber">The serial number of the recipient's associated certificate.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cms.KeyTransRecipientID.#ctor(Org.BouncyCastle.Cert.X509Certificate)">
            <summary>
            Construct a key trans recipient ID based on the issuer and serial number of the recipient's associated certificate.
            </summary>
            <param name="certificate">The recipient's associated certificate.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cms.KeyTransRecipientID.#ctor(Org.BouncyCastle.Asn1.X500.X500Name,Org.BouncyCastle.Math.BigInteger,System.Byte[])">
            <summary>
            Construct a key trans recipient ID based on the issuer and serial number of the recipient's associated certificate.
            </summary>
            <param name="issuer">The issuer of the recipient's associated certificate.</param>
            <param name="serialNumber">The serial number of the recipient's associated certificate.</param>
            <param name="subjectKeyId">The subject key identifier to use to match the recipients associated certificate.</param>
        </member>
        <member name="T:Org.BouncyCastle.Cms.KeyTransRecipientInformation">
            the KeyTransRecipientInformation class for a recipient who has been sent a secret
            key encrypted using their public key that needs to be used to
            extract the message.
        </member>
        <member name="M:Org.BouncyCastle.Cms.RecipientInformation.GetContentDigest">
             Return the content digest calculated during the read of the content if one has been generated. This will
             only happen if we are dealing with authenticated data and authenticated attributes are present.
            
             @return byte array containing the digest.
        </member>
        <member name="M:Org.BouncyCastle.Cms.RecipientInformation.GetMac">
            <summary>
            Return the MAC calculated for the recipient. Note: this call is only meaningful once all
            the content has been read.
            </summary>
            <returns>byte array containing the mac.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Cms.RecipientInformation.GetContent(Org.BouncyCastle.Cms.IRecipient)">
            <summary>
            Return the decrypted/encapsulated content in the EnvelopedData after recovering the content
            encryption/MAC key using the passed in Recipient.
            </summary>
            <param name="recipient">Recipient object to use to recover content encryption key</param>
            <returns>The content inside the EnvelopedData this RecipientInformation is associated with.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Cms.RecipientInformation.GetContentStream(Org.BouncyCastle.Cms.IRecipient)">
            <summary>
            Return a CmsTypedStream representing the content in the EnvelopedData after recovering the content
            encryption/MAC key using the passed in Recipient.
            </summary>
            <param name="recipient">Recipient object to use to recover content encryption key</param>
            <returns>The content inside the EnvelopedData this RecipientInformation is associated with.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Cms.RecipientInformationStore">
            <summary>
            A store collection class for RecipientInformation objects.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Cms.RecipientInformationStore.#ctor(System.Collections.Generic.ICollection{Org.BouncyCastle.Cms.RecipientInformation})">
            <summary>
            Create a store containing a collection of RecipientInformation objects.
            </summary>
            <param name="recipientInfos">A collection of recipient information objects to contain.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cms.RecipientInformationStore.GetFirstMatch(Org.BouncyCastle.Cms.IRecipientID{Org.BouncyCastle.Cms.RecipientInformation})">
             Return the first RecipientInformation object that matches the
             passed in selector. Null if there are no matches.
            
             @param selector to identify a recipient
             @return a single RecipientInformation object. Null if none matches.
        </member>
        <member name="P:Org.BouncyCastle.Cms.RecipientInformationStore.Count">
             Return the number of recipients in the collection.
            
             @return number of recipients identified.
        </member>
        <member name="M:Org.BouncyCastle.Cms.RecipientInformationStore.GetAll">
             Return all recipients in the collection
            
             @return a collection of recipients.
        </member>
        <member name="M:Org.BouncyCastle.Cms.RecipientInformationStore.GetMatches(Org.BouncyCastle.Utilities.ISelector{Org.BouncyCastle.Cms.RecipientInformation})">
             Return possible empty collection with recipients matching the passed in RecipientID
            
             @param selector a recipient id to select against.
             @return a collection of RecipientInformation objects.
        </member>
        <member name="T:Org.BouncyCastle.Cms.SignerID">
            a basic index for a signer.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerID.#ctor(System.Byte[])">
             Construct a signer ID with the value of a public key's subjectKeyId.
            
             @param subjectKeyId a subjectKeyId
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerID.#ctor(Org.BouncyCastle.Asn1.X500.X500Name,Org.BouncyCastle.Math.BigInteger)">
             Construct a signer ID based on the issuer and serial number of the signer's associated
             certificate.
            
             @param issuer the issuer of the signer's associated certificate.
             @param serialNumber the serial number of the signer's associated certificate.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerID.#ctor(Org.BouncyCastle.Asn1.X500.X500Name,Org.BouncyCastle.Math.BigInteger,System.Byte[])">
             Construct a signer ID based on the issuer and serial number of the signer's associated
             certificate.
            
             @param issuer the issuer of the signer's associated certificate.
             @param serialNumber the serial number of the signer's associated certificate.
             @param subjectKeyId the subject key identifier to use to match the signers associated certificate.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInfoGeneratorBuilder.#ctor(Org.BouncyCastle.Crypto.IDigestFactoryProvider{Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier})">
              Base constructor.
            
             @param digestProvider  a provider of digest calculators for the algorithms required in the signature and attribute calculations.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInfoGeneratorBuilder.#ctor(Org.BouncyCastle.Crypto.IDigestFactoryProvider{Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier},Org.BouncyCastle.Cms.ISignatureEncryptionAlgorithmFinder)">
              Base constructor.
            
             @param digestProvider  a provider of digest calculators for the algorithms required in the signature and attribute calculations.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInfoGeneratorBuilder.SetDirectSignature(System.Boolean)">
             If the passed in flag is true, the signer signature will be based on the data, not
             a collection of signed attributes, and no signed attributes will be included.
            
             @return the builder object
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInfoGeneratorBuilder.WithSignedAttributeGenerator(Org.BouncyCastle.Cms.ICmsAttributeTableGenerator)">
              Provide a custom signed attribute generator.
            
             @param signedGen a generator of signed attributes.
             @return the builder object
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInfoGeneratorBuilder.WithUnsignedAttributeGenerator(Org.BouncyCastle.Cms.ICmsAttributeTableGenerator)">
             Provide a generator of unsigned attributes.
            
             @param unsignedGen  a generator for signed attributes.
             @return the builder object
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInfoGeneratorBuilder.Build(Org.BouncyCastle.Crypto.ISignatureFactory{Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier},Org.BouncyCastle.Cert.X509Certificate)">
            <summary>
            Build a generator with the passed in certificate issuer and serial number as the signerIdentifier.
            </summary>
            <param name="contentSigner">operator for generating the final signature in the SignerInfo with.</param>
            <param name="certificate">carrier for the X.509 certificate related to the contentSigner.</param>
            <returns>a SignerInfoGenerator</returns>
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInfoGeneratorBuilder.Build(Org.BouncyCastle.Crypto.ISignatureFactory{Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier},System.Byte[])">
            <summary>
            Build a generator with the passed in subjectKeyIdentifier as the signerIdentifier. If used  you should
            try to follow the calculation described in RFC 5280 section 4.2.1.2.
            </summary>
            <param name="contentSigner">operator factory for generating the final signature in the SignerInfo with.</param>
            <param name="subjectKeyIdentifier">key identifier to identify the public key for verifying the signature.</param>
            <returns>a SignerInfoGenerator</returns>
        </member>
        <member name="T:Org.BouncyCastle.Cms.SignerInformation">
            <summary>
            An expanded SignerInfo block from a CMS Signed message
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Cms.SignerInformation.Version">
            <summary>
            Return the version number for this objects underlying SignerInfo structure.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Cms.SignerInformation.SignatureAlgorithmID">
            <summary>
            Return the signature, or digest encryption, algorithm
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Cms.SignerInformation.DigestAlgorithmID">
            <summary>
            Return the digest algorithm details associated with the signature.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformation.GetContentDigest">
            <summary>
            Return the content digest that was calculated during verification.
            </summary>
            <returns>The content digest resulting from the last verify call.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Cms.SignerInformation.SignedAttributes">
            return a table of the signed attributes - indexed by
            the OID of the attribute.
        </member>
        <member name="P:Org.BouncyCastle.Cms.SignerInformation.UnsignedAttributes">
            return a table of the unsigned attributes indexed by
            the OID of the attribute.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformation.GetSignature">
            return the encoded signature
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformation.GetCounterSignatures">
            Return a SignerInformationStore containing the counter signatures attached to this
            signer. If no counter signatures are present an empty store is returned.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformation.GetEncodedSignedAttributes">
            return the DER encoding of the signed attributes.
            @throws IOException if an encoding error occurs.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformation.ToAsn1Structure">
             Return the base ASN.1 CMS structure that this object contains.
            
             @return an object containing a CMS SignerInfo structure.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformation.ReplaceUnsignedAttributes(Org.BouncyCastle.Cms.SignerInformation,Org.BouncyCastle.Asn1.Cms.AttributeTable)">
             Return a signer information object with the passed in unsigned
             attributes replacing the ones that are current associated with
             the object passed in.
            
             @param signerInformation the signerInfo to be used as the basis.
             @param unsignedAttributes the unsigned attributes to add.
             @return a copy of the original SignerInformationObject with the changed attributes.
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformation.AddCounterSigners(Org.BouncyCastle.Cms.SignerInformation,Org.BouncyCastle.Cms.SignerInformationStore)">
             Return a signer information object with passed in SignerInformationStore representing counter
             signatures attached as an unsigned attribute.
            
             @param signerInformation the signerInfo to be used as the basis.
             @param counterSigners signer info objects carrying counter signature.
             @return a copy of the original SignerInformationObject with the changed attributes.
        </member>
        <member name="T:Org.BouncyCastle.Cms.SignerInformationStore">
            <summary>
            A store collection class for SignerInformation objects.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformationStore.#ctor(Org.BouncyCastle.Cms.SignerInformation)">
            <summary>
            Create a store containing a single SignerInformation object.
            </summary>
            <param name="signerInfo">The signer information to contain.</param>
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformationStore.#ctor(System.Collections.Generic.ICollection{Org.BouncyCastle.Cms.SignerInformation})">
            <summary>
            Create a store containing a collection of SignerInformation objects.
            </summary>
            <param name="signerInfos">A collection of signer information objects to contain.</param>
        </member>
        <member name="P:Org.BouncyCastle.Cms.SignerInformationStore.Count">
            <summary>The number of signers in the collection.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformationStore.GetAll">
            <returns>An ICollection of all signers in the collection</returns>
        </member>
        <member name="M:Org.BouncyCastle.Cms.SignerInformationStore.GetFirstMatch(Org.BouncyCastle.Utilities.ISelector{Org.BouncyCastle.Cms.SignerInformation})">
             Return the first SignerInformation object that matches the
             passed in selector. Null if there are no matches.
            
             @param selector to identify a signer
             @return a single SignerInformation object. Null if none matches.
        </member>
        <member name="M:Org.BouncyCastle.Crmf.AuthenticatorControl.#ctor(Org.BouncyCastle.Asn1.DerUtf8String)">
            <summary>
            Basic constructor - build from a UTF-8 string representing the token.
            </summary>
            <param name="token">UTF-8 string representing the token.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crmf.AuthenticatorControl.#ctor(System.String)">
            <summary>
            Basic constructor - build from a string representing the token.
            </summary>
            <param name="token">string representing the token.</param>
        </member>
        <member name="P:Org.BouncyCastle.Crmf.AuthenticatorControl.Type">
            <summary>
            Return the type of this control.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crmf.AuthenticatorControl.Value">
            <summary>
            Return the token associated with this control (a UTF8String).
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crmf.CertificateRequestMessage.#ctor(System.Byte[])">
            <summary>
            Create a CertificateRequestMessage from the passed in bytes.
            </summary>
            <param name="encoded">BER/DER encoding of the CertReqMsg structure.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crmf.CertificateRequestMessage.ToAsn1Structure">
            <summary>
            Return the underlying ASN.1 object defining this CertificateRequestMessage object.
            </summary>
            <returns>A CertReqMsg</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crmf.CertificateRequestMessage.GetCertTemplate">
            <summary>
            Return the certificate template contained in this message.
            </summary>
            <returns>a CertTemplate structure.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Crmf.CertificateRequestMessage.HasControls">
            <summary>
            Return whether or not this request has control values associated with it.
            </summary>
            <returns>true if there are control values present, false otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crmf.CertificateRequestMessage.HasControl(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>
            Return whether or not this request has a specific type of control value.
            </summary>
            <param name="objectIdentifier">the type OID for the control value we are checking for.</param>
            <returns>true if a control value of type is present, false otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crmf.CertificateRequestMessage.GetControl(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>
            Return a control value of the specified type.
            </summary>
            <param name="type">the type OID for the control value we are checking for.</param>
            <returns>the control value if present, null otherwise.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Crmf.CertificateRequestMessage.HasProofOfPossession">
            <summary>
            Return whether or not this request message has a proof-of-possession field in it.
            </summary>
            <returns>true if proof-of-possession is present, false otherwise.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Crmf.CertificateRequestMessage.ProofOfPossession">
            <summary>
            Return the type of the proof-of-possession this request message provides.
            </summary>
            <returns>one of: popRaVerified, popSigningKey, popKeyEncipherment, popKeyAgreement</returns>
        </member>
        <member name="P:Org.BouncyCastle.Crmf.CertificateRequestMessage.HasSigningKeyProofOfPossessionWithPkMac">
            <summary>
            Return whether or not the proof-of-possession (POP) is of the type popSigningKey and
            it has a public key MAC associated with it.
            </summary>
            <returns>true if POP is popSigningKey and a PKMAC is present, false otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crmf.CertificateRequestMessage.IsValidSigningKeyPop(Org.BouncyCastle.Crypto.IVerifierFactoryProvider{Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier})">
            <summary>
            Return whether or not a signing key proof-of-possession (POP) is valid.
            </summary>
            <param name="verifierProvider">a provider that can produce content verifiers for the signature contained in this POP.</param>
            <returns>true if the POP is valid, false otherwise.</returns>
            <exception cref="T:System.InvalidOperationException">if there is a problem in verification or content verifier creation.</exception>
            <exception cref="T:System.InvalidOperationException">if POP not appropriate.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Crmf.CertificateRequestMessage.GetEncoded">
            <summary>
            Return the ASN.1 encoding of the certReqMsg we wrap.
            </summary>
            <returns>a byte array containing the binary encoding of the certReqMsg.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crmf.CrmfOptionalValidity.ToAsn1Object">
            <pre>
            OptionalValidity ::= SEQUENCE {
                                   notBefore  [0] Time OPTIONAL,
                                   notAfter   [1] Time OPTIONAL } --at least one MUST be present
            </pre>
            @return a basic ASN.1 object representation.
        </member>
        <member name="M:Org.BouncyCastle.Crmf.CrmfUtilities.CreateOptionalValidity(Org.BouncyCastle.Asn1.X509.Time,Org.BouncyCastle.Asn1.X509.Time)">
            <summary>
            Create an instance of OptionalValidity
            </summary>
            <param name="notBefore"></param>
            <param name="notAfter"></param>
            <returns></returns>
        </member>
        <member name="M:Org.BouncyCastle.Crmf.EncryptedValueBuilder.#ctor(Org.BouncyCastle.Crypto.IKeyWrapper{Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier},Org.BouncyCastle.Crypto.ICipherBuilderWithKey{Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier})">
            
             Create a builder that makes EncryptedValue structures.
            
             <param name="wrapper">wrapper a wrapper for key used to encrypt the actual data contained in the EncryptedValue.</param>
             <param name="encryptor">encryptor  an output encryptor to encrypt the actual data contained in the EncryptedValue. </param>
            
        </member>
        <member name="M:Org.BouncyCastle.Crmf.EncryptedValueBuilder.#ctor(Org.BouncyCastle.Crypto.IKeyWrapper{Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier},Org.BouncyCastle.Crypto.ICipherBuilderWithKey{Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier},Org.BouncyCastle.Crmf.IEncryptedValuePadder)">
            
             Create a builder that makes EncryptedValue structures with fixed length blocks padded using the passed in padder.
            
             <param name="wrapper">a wrapper for key used to encrypt the actual data contained in the EncryptedValue.</param>
             <param name="encryptor">encryptor  an output encryptor to encrypt the actual data contained in the EncryptedValue.</param>
             <param name="padder">padder a padder to ensure that the EncryptedValue created will always be a constant length.</param>
            
        </member>
        <member name="M:Org.BouncyCastle.Crmf.EncryptedValueBuilder.Build(System.Char[])">
            
             Build an EncryptedValue structure containing the passed in pass phrase.
            
             <param name="revocationPassphrase">a revocation pass phrase.</param>
            <returns>an EncryptedValue containing the encrypted pass phrase.</returns>       
            
        </member>
        <member name="M:Org.BouncyCastle.Crmf.EncryptedValueBuilder.Build(Org.BouncyCastle.Cert.X509Certificate)">
            <summary>
             Build an EncryptedValue structure containing the certificate contained in
             the passed in holder.
            </summary>
             <param name="holder">a holder containing a certificate.</param>
              <returns>an EncryptedValue containing the encrypted certificate.</returns>
             <exception cref="T:Org.BouncyCastle.Crmf.CrmfException">on a failure to encrypt the data, or wrap the symmetric key for this value.</exception>
            
        </member>
        <member name="M:Org.BouncyCastle.Crmf.EncryptedValueBuilder.Build(Org.BouncyCastle.Asn1.Pkcs.PrivateKeyInfo)">
            <summary>
             Build an EncryptedValue structure containing the private key contained in
             the passed info structure.
            </summary>
             <param name="privateKeyInfo">a PKCS#8 private key info structure.</param>
             <returns>an EncryptedValue containing an EncryptedPrivateKeyInfo structure.</returns>
             <exception cref="T:Org.BouncyCastle.Crmf.CrmfException">on a failure to encrypt the data, or wrap the symmetric key for this value.</exception>
            
        </member>
        <member name="T:Org.BouncyCastle.Crmf.IControl">
            <summary>
            Generic interface for a CertificateRequestMessage control value.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crmf.IControl.Type">
            <summary>
            Return the type of this control.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crmf.IControl.Value">
            <summary>
            Return the value contained in this control object.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crmf.IEncryptedValuePadder.GetPaddedData(System.Byte[])">
            
             <summary>Return a byte array of padded data.</summary>
            
             <param name="data">the data to be padded.</param>
             <returns>a padded byte array containing data.</returns>
            
        </member>
        <member name="M:Org.BouncyCastle.Crmf.IEncryptedValuePadder.GetUnpaddedData(System.Byte[])">
            
             <summary>Return a byte array of with padding removed.</summary>
            
             <param name="paddedData">the data to be padded.</param>
             <returns>an array containing the original unpadded data.</returns>
            
        </member>
        <member name="M:Org.BouncyCastle.Crmf.PkiArchiveControl.#ctor(Org.BouncyCastle.Asn1.Crmf.PkiArchiveOptions)">
            <summary>
            Basic constructor - build from an PKIArchiveOptions structure.
            </summary>
            <param name="pkiArchiveOptions">the ASN.1 structure that will underlie this control.</param>
        </member>
        <member name="P:Org.BouncyCastle.Crmf.PkiArchiveControl.Type">
            <summary>
            Return the type of this control.
            </summary>
            <returns>CRMFObjectIdentifiers.id_regCtrl_pkiArchiveOptions</returns>
        </member>
        <member name="P:Org.BouncyCastle.Crmf.PkiArchiveControl.Value">
            <summary>
            Return the underlying ASN.1 object.
            </summary>
            <returns>a PKIArchiveOptions structure.</returns>    
        </member>
        <member name="P:Org.BouncyCastle.Crmf.PkiArchiveControl.ArchiveType">
            <summary>
            Return the archive control type, one of: encryptedPrivKey,keyGenParameters,or archiveRemGenPrivKey.
            </summary>
            <returns>the archive control type.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Crmf.PkiArchiveControl.EnvelopedData">
            <summary>
            Return whether this control contains enveloped data.
            </summary>
            <returns>true if the control contains enveloped data, false otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crmf.PkiArchiveControl.GetEnvelopedData">
            <summary>
            Return the enveloped data structure contained in this control.
            </summary>
            <returns>a CMSEnvelopedData object.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crmf.PkiArchiveControlBuilder.#ctor(Org.BouncyCastle.Asn1.Pkcs.PrivateKeyInfo,Org.BouncyCastle.Asn1.X509.GeneralName)">
             <summary>
            Basic constructor - specify the contents of the PKIArchiveControl structure.
             </summary>
             <param name="privateKeyInfo">the private key to be archived.</param>
             <param name="generalName">the general name to be associated with the private key.</param>
            
        </member>
        <member name="M:Org.BouncyCastle.Crmf.PkiArchiveControlBuilder.AddRecipientGenerator(Org.BouncyCastle.Cms.IRecipientInfoGenerator)">
            <summary>Add a recipient generator to this control.</summary>       
            <param name="recipientGen"> recipient generator created for a specific recipient.</param>
            <returns>this builder object.</returns>       
        </member>
        <member name="M:Org.BouncyCastle.Crmf.PkiArchiveControlBuilder.Build(Org.BouncyCastle.Crypto.ICipherBuilderWithKey{Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier})">
            <summary>Build the PKIArchiveControl using the passed in encryptor to encrypt its contents.</summary>
            <param name="contentEncryptor">a suitable content encryptor.</param>
            <returns>a PKIArchiveControl object.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crmf.RegTokenControl.#ctor(Org.BouncyCastle.Asn1.DerUtf8String)">
            <summary>
            Basic constructor - build from a UTF-8 string representing the token.
            </summary>
            <param name="token">UTF-8 string representing the token.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crmf.RegTokenControl.#ctor(System.String)">
            <summary>
            Basic constructor - build from a string representing the token.
            </summary>
            <param name="token">string representing the token.</param>
        </member>
        <member name="P:Org.BouncyCastle.Crmf.RegTokenControl.Type">
            <summary>
            Return the type of this control.
            </summary>
            <returns>CRMFObjectIdentifiers.id_regCtrl_regToken</returns>
        </member>
        <member name="P:Org.BouncyCastle.Crmf.RegTokenControl.Value">
            <summary>
            Return the token associated with this control (a UTF8String).
            </summary>
            <returns>a UTF8String.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Ocsp.BasicOcspResp">
            <remarks>
            <code>
            BasicOcspResponse ::= SEQUENCE {
            	tbsResponseData		ResponseData,
            	signatureAlgorithm	AlgorithmIdentifier,
            	signature			BIT STRING,
            	certs				[0] EXPLICIT SEQUENCE OF Certificate OPTIONAL
            }
            </code>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.BasicOcspResp.GetTbsResponseData">
            <returns>The DER encoding of the tbsResponseData field.</returns>
            <exception cref="T:Org.BouncyCastle.Ocsp.OcspException">In the event of an encoding error.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.BasicOcspResp.GetCertificates">
            <returns>The certificates, if any, associated with the response.</returns>
            <exception cref="T:Org.BouncyCastle.Ocsp.OcspException">In the event of an encoding error.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.BasicOcspResp.IsVerified(Org.BouncyCastle.Crypto.IVerifierFactoryProvider{Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier})">
            <summary>
            Verify the responses's signature using a verifier created using the passed in verifier provider.
            </summary>
            <param name="verifierProvider">An appropriate provider for verifying the responses's signature.</param>
            <returns>true is the signature on the response verifies, false otherwise.</returns>
            <exception cref="T:System.Exception">If verifier provider is not appropriate, the response's algorithm is invalid.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.BasicOcspResp.GetEncoded">
            <returns>The ASN.1 encoded representation of this object.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Ocsp.BasicOcspRespGenerator">
            Generator for basic OCSP response objects.
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.BasicOcspRespGenerator.#ctor(Org.BouncyCastle.Ocsp.RespID)">
            basic constructor
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.BasicOcspRespGenerator.#ctor(Org.BouncyCastle.Crypto.IAsymmetricPublicKey)">
            construct with the responderID to be the SHA-1 keyHash of the passed in public key.
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.BasicOcspRespGenerator.AddResponse(Org.BouncyCastle.Ocsp.CertificateID,Org.BouncyCastle.Ocsp.CertificateStatus)">
             Add a response for a particular Certificate ID.
            
             @param certID certificate ID details
             @param certStatus status of the certificate - null if okay
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.BasicOcspRespGenerator.AddResponse(Org.BouncyCastle.Ocsp.CertificateID,Org.BouncyCastle.Ocsp.CertificateStatus,Org.BouncyCastle.Asn1.X509.X509Extensions)">
             Add a response for a particular Certificate ID.
            
             @param certID certificate ID details
             @param certStatus status of the certificate - null if okay
             @param singleExtensions optional extensions
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.BasicOcspRespGenerator.AddResponse(Org.BouncyCastle.Ocsp.CertificateID,Org.BouncyCastle.Ocsp.CertificateStatus,System.Nullable{System.DateTime},Org.BouncyCastle.Asn1.X509.X509Extensions)">
             Add a response for a particular Certificate ID.
            
             @param certID certificate ID details
             @param nextUpdate date when next update should be requested
             @param certStatus status of the certificate - null if okay
             @param singleExtensions optional extensions
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.BasicOcspRespGenerator.AddResponse(Org.BouncyCastle.Ocsp.CertificateID,Org.BouncyCastle.Ocsp.CertificateStatus,System.DateTime,System.Nullable{System.DateTime},Org.BouncyCastle.Asn1.X509.X509Extensions)">
             Add a response for a particular Certificate ID.
            
             @param certID certificate ID details
             @param thisUpdate date this response was valid on
             @param nextUpdate date when next update should be requested
             @param certStatus status of the certificate - null if okay
             @param singleExtensions optional extensions
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.BasicOcspRespGenerator.SetResponseExtensions(Org.BouncyCastle.Asn1.X509.X509Extensions)">
             Set the extensions for the response.
            
             @param responseExtensions the extension object to carry.
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.BasicOcspRespGenerator.Generate(Org.BouncyCastle.Crypto.ISignatureFactory{Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier},Org.BouncyCastle.Cert.X509Certificate[],System.DateTime)">
            <summary>
            Generate the signed response using the passed in signature calculator.
            </summary>
            <param name="signatureCalculatorFactory">Implementation of signing calculator factory.</param>
            <param name="chain">The certificate chain associated with the response signer.</param>
            <param name="producedAt">"produced at" date.</param>
            <returns></returns>
        </member>
        <member name="P:Org.BouncyCastle.Ocsp.BasicOcspRespGenerator.SignatureAlgNames">
             Return an IEnumerable of the signature names supported by the generator.
            
             @return an IEnumerable containing recognised names.
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.CertificateID.#ctor(Org.BouncyCastle.Crypto.IDigestFactory{Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier},Org.BouncyCastle.Cert.X509Certificate,Org.BouncyCastle.Math.BigInteger)">
            create from an issuer certificate and the serial number of the
            certificate it signed.
            @exception OcspException if any problems occur creating the id fields.
        </member>
        <member name="P:Org.BouncyCastle.Ocsp.CertificateID.SerialNumber">
            return the serial number for the certificate associated
            with this request.
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.CertificateID.DeriveCertificateID(Org.BouncyCastle.Ocsp.CertificateID,Org.BouncyCastle.Math.BigInteger)">
             Create a new CertificateID for a new serial number derived from a previous one
             calculated for the same CA certificate.
            
             @param original the previously calculated CertificateID for the CA.
             @param newSerialNumber the serial number for the new certificate of interest.
            
             @return a new CertificateID for newSerialNumber
        </member>
        <member name="T:Org.BouncyCastle.Ocsp.OcspReq">
             <pre>
             OcspRequest     ::=     SEQUENCE {
                   tbsRequest                  TBSRequest,
                   optionalSignature   [0]     EXPLICIT Signature OPTIONAL }
            
               TBSRequest      ::=     SEQUENCE {
                   version             [0]     EXPLICIT Version DEFAULT v1,
                   requestorName       [1]     EXPLICIT GeneralName OPTIONAL,
                   requestList                 SEQUENCE OF Request,
                   requestExtensions   [2]     EXPLICIT Extensions OPTIONAL }
            
               Signature       ::=     SEQUENCE {
                   signatureAlgorithm      AlgorithmIdentifier,
                   signature               BIT STRING,
                   certs               [0] EXPLICIT SEQUENCE OF Certificate OPTIONAL}
            
               Version         ::=             INTEGER  {  v1(0) }
            
               Request         ::=     SEQUENCE {
                   reqCert                     CertID,
                   singleRequestExtensions     [0] EXPLICIT Extensions OPTIONAL }
            
               CertID          ::=     SEQUENCE {
                   hashAlgorithm       AlgorithmIdentifier,
                   issuerNameHash      OCTET STRING, -- Hash of Issuer's DN
                   issuerKeyHash       OCTET STRING, -- Hash of Issuers public key
                   serialNumber        CertificateSerialNumber }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.OcspReq.GetTbsRequest">
            Return the DER encoding of the tbsRequest field.
            @return DER encoding of tbsRequest
            @throws OcspException in the event of an encoding error.
        </member>
        <member name="P:Org.BouncyCastle.Ocsp.OcspReq.SignatureAlgOid">
            return the object identifier representing the signature algorithm
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.OcspReq.GetCertificates">
             If the request is signed return a possibly empty CertStore containing the certificates in the
             request. If the request is not signed the method returns null.
            
             @return null if not signed, a CertStore otherwise
             @throws OcspException
        </member>
        <member name="P:Org.BouncyCastle.Ocsp.OcspReq.IsSigned">
             Return whether or not this request is signed.
            
             @return true if signed false otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.OcspReq.IsVerified(Org.BouncyCastle.Crypto.IVerifierFactoryProvider{Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier})">
            Verify the signature against the TBSRequest object we contain.
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.OcspReq.GetEncoded">
            return the ASN.1 encoded representation of this object.
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.OcspReqGenerator.AddRequest(Org.BouncyCastle.Ocsp.CertificateID)">
             Add a request for the given CertificateID.
            
             @param certId certificate ID of interest
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.OcspReqGenerator.AddRequest(Org.BouncyCastle.Ocsp.CertificateID,Org.BouncyCastle.Asn1.X509.X509Extensions)">
             Add a request with extensions
            
             @param certId certificate ID of interest
             @param singleRequestExtensions the extensions to attach to the request
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.OcspReqGenerator.SetRequestorName(Org.BouncyCastle.Asn1.X500.X500Name)">
             Set the requestor name to the passed in X509Principal
            
             @param requestorName a X509Principal representing the requestor name.
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.OcspReqGenerator.Generate">
             Generate an unsigned request
            
             @return the OcspReq
             @throws OcspException
        </member>
        <member name="P:Org.BouncyCastle.Ocsp.OcspReqGenerator.SignatureAlgNames">
             Return an IEnumerable of the signature names supported by the generator.
            
             @return an IEnumerable containing recognised names.
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.OcspResp.GetEncoded">
            return the ASN.1 encoded representation of this object.
        </member>
        <member name="T:Org.BouncyCastle.Ocsp.OcspRespGenerator">
            base generator for an OCSP response - at the moment this only supports the
            generation of responses containing BasicOCSP responses.
        </member>
        <member name="F:Org.BouncyCastle.Ocsp.OcspRespStatus.Successful">
            note 4 is not used.
        </member>
        <member name="T:Org.BouncyCastle.Ocsp.RespID">
            Carrier for a ResponderID.
        </member>
        <member name="T:Org.BouncyCastle.Ocsp.RevokedStatus">
            <summary>Wrapper for the RevokedInfo object</summary>
        </member>
        <member name="P:Org.BouncyCastle.Ocsp.RevokedStatus.RevocationReason">
            <summary>Return the revocation reason, if there is one.</summary>
            <remarks>This field is optional; test for it with <see cref="P:Org.BouncyCastle.Ocsp.RevokedStatus.HasRevocationReason"/> first.</remarks>
            <returns>The revocation reason, if available.</returns>
            <exception cref="T:System.InvalidOperationException">If no revocation reason is available.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Ocsp.SingleResp.GetCertStatus">
             Return the status object for the response - null indicates good.
            
             @return the status object for the response, null if it is good.
        </member>
        <member name="P:Org.BouncyCastle.Ocsp.SingleResp.NextUpdate">
             return the NextUpdate value - note: this is an optional field so may
             be returned as null.
            
             @return nextUpdate, or null if not present.
        </member>
        <member name="T:Org.BouncyCastle.Ocsp.UnknownStatus">
            wrapper for the UnknownInfo object
        </member>
        <member name="T:Org.BouncyCastle.OpenSsl.MiscPemGenerator">
            Pem generator for the original set of Pem objects used in Open SSL.
        </member>
        <member name="T:Org.BouncyCastle.OpenSsl.OpenSslPemReader">
            <summary>
            Class for parsing OpenSSL Pem encoded streams containing X509 certificates, PKCS8 encoded keys and PKCS7 objects.
            </summary>
            <remarks>
            In the case of PKCS7 objects the reader will return a CMS ContentInfo object. Public keys will be returned as
            well formed SubjectPublicKeyInfo objects, private keys will be returned as well formed PrivateKeyInfo objects.In the
            case of a private key a PemKeyPair will normally be returned if the encoding contains both the private and public
            key definition.CRLs, Certificates, PKCS#10 requests, and Attribute Certificates will generate the appropriate BC holder class.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.OpenSsl.OpenSslPemReader.#ctor(System.IO.TextReader)">
             Create a new PemReader
            
             @param reader the Reader
        </member>
        <member name="M:Org.BouncyCastle.OpenSsl.OpenSslPemReader.ReadObject">
            <summary>
            Return the next object in the reader, null if there are no more left.
            </summary>
            <returns>The next object in the reader, null at end of data.</returns>
        </member>
        <member name="M:Org.BouncyCastle.OpenSsl.OpenSslPemReader.KeyPairParser.ParseObject(Org.BouncyCastle.Utilities.IO.Pem.PemObject)">
            Read a Key Pair
        </member>
        <member name="M:Org.BouncyCastle.OpenSsl.OpenSslPemReader.X509CertificateParser.ParseObject(Org.BouncyCastle.Utilities.IO.Pem.PemObject)">
             Reads in a X509Certificate.
            
             @return the X509Certificate
        </member>
        <member name="M:Org.BouncyCastle.OpenSsl.OpenSslPemReader.X509TrustedCertificateParser.ParseObject(Org.BouncyCastle.Utilities.IO.Pem.PemObject)">
             Reads in a X509Certificate.
            
             @return the X509Certificate
        </member>
        <member name="M:Org.BouncyCastle.OpenSsl.OpenSslPemReader.X509CRLParser.ParseObject(Org.BouncyCastle.Utilities.IO.Pem.PemObject)">
             Reads in a X509CRL.
            
             @return the X509Certificate
        </member>
        <member name="M:Org.BouncyCastle.OpenSsl.OpenSslPemReader.PKCS10CertificationRequestParser.ParseObject(Org.BouncyCastle.Utilities.IO.Pem.PemObject)">
             Reads in a PKCS10 certification request.
            
             @return the certificate request.
        </member>
        <member name="M:Org.BouncyCastle.OpenSsl.OpenSslPemReader.PKCS7Parser.ParseObject(Org.BouncyCastle.Utilities.IO.Pem.PemObject)">
             Reads in a PKCS7 object. This returns a ContentInfo object suitable for use with the CMS
             API.
            
             @return the X509Certificate
        </member>
        <member name="M:Org.BouncyCastle.OpenSsl.OpenSslPemReader.EncryptedPrivateKeyParser.ParseObject(Org.BouncyCastle.Utilities.IO.Pem.PemObject)">
             Reads in an EncryptedPrivateKeyInfo
            
             @return the X509Certificate
        </member>
        <member name="T:Org.BouncyCastle.OpenSsl.OpenSslPemWriter">
            <summary>
            Writer for OpenSSL style PEM objects.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.OpenSsl.OpenSslPemWriter.#ctor(System.IO.TextWriter)">
            <summary>
            Base constructor.
            </summary>
            <param name="writer">The underlying TextWriter to output PEM data to.</param>
        </member>
        <member name="M:Org.BouncyCastle.OpenSsl.OpenSslPemWriter.WriteObject(System.Object)">
            <summary>
            Encode the passed in object and write it in PEM format.
            </summary>
            <param name="obj">The object to be encoded.</param>
        </member>
        <member name="M:Org.BouncyCastle.OpenSsl.OpenSslPemWriter.WriteObject(System.Object,Org.BouncyCastle.Crypto.ICipherBuilder{Org.BouncyCastle.Operators.Parameters.DekInfo})">
            <summary>
            Encode and encrypt the passed in object and write it in PEM format.
            </summary>
            <param name="obj">The object to be encoded and encrypted.</param>
            <param name="encryptor">The PEM encryptor to use.</param>
        </member>
        <member name="T:Org.BouncyCastle.OpenSsl.X509TrustedCertificateBlock">
            <summary>
            Holder for an OpenSSL trusted certificate block.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.OpenSsl.X509TrustedCertificateBlock.#ctor(Org.BouncyCastle.Cert.X509Certificate,Org.BouncyCastle.OpenSsl.CertificateTrustBlock)">
            <summary>
            Base constructor - from a certificate and a trust block.
            </summary>
            <param name="certificate">The certificate to contain.</param>
            <param name="trustBlock">The trust block to associate with the certififace.</param>
        </member>
        <member name="M:Org.BouncyCastle.OpenSsl.X509TrustedCertificateBlock.#ctor(System.Byte[])">
            <summary>
            Base constructor - from a byte encoding.
            </summary>
            <param name="encoding">A byte encoding of a trusted certificate block.</param>
        </member>
        <member name="M:Org.BouncyCastle.OpenSsl.X509TrustedCertificateBlock.GetEncoded">
            <summary>
            Return a binary encoding of the trusted certificate block.
            </summary>
            <returns>A byte array containing the encoded object.</returns>
        </member>
        <member name="P:Org.BouncyCastle.OpenSsl.X509TrustedCertificateBlock.Certificate">
            <summary>
            Return the certificate associated with this Trusted Certificate
            </summary>
            <returns>The certificate.</returns>
        </member>
        <member name="P:Org.BouncyCastle.OpenSsl.X509TrustedCertificateBlock.TrustBlock">
            <summary>
            Return the trust block associated with this Trusted Certificate
            </summary>
            <returns>The trust block.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Operators.CmsKeyTransEnvelopedRecipient.#ctor(Org.BouncyCastle.Crypto.IAsymmetricPrivateKey)">
            <summary>
            Base constructor - just the private key.
            </summary>
            <param name="privKey">The private key to use.</param>
        </member>
        <member name="M:Org.BouncyCastle.Operators.CmsKeyTransEnvelopedRecipient.#ctor(Org.BouncyCastle.Crypto.IAsymmetricPrivateKey,Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Constructor with a random source for blinding operations on the private key.
            </summary>
            <param name="privKey">The private key to use.</param>
            <param name="random">A source of randomness.</param>
        </member>
        <member name="T:Org.BouncyCastle.Operators.OpenSslPemDecryptorBuilderProvider">
            <summary>
            Provider class for OpenSSL PEM decryptors.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Operators.OpenSslPemDecryptorBuilderProvider.#ctor(System.Char[])">
            <summary>
            Base construcor.
            </summary>
            <param name="password">password to configure any produced decryptor for.</param>
        </member>
        <member name="M:Org.BouncyCastle.Operators.OpenSslPemDecryptorBuilderProvider.CreateDecryptorBuilder(Org.BouncyCastle.Operators.Parameters.DekInfo)">
            <summary>
            Create a cipher builder configured for our password and the passed in DEK-Info.
            </summary>
            <param name="algorithmDetails">The DEK-Info describing the cipher and the IV.</param>
            <returns>A cipher builder for decryptors.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Operators.OpenSslPemEncryptorBuilder">
            <summary>
            Builder for OpenSSL encryptors, used to encrypt PEM objects.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Operators.OpenSslPemEncryptorBuilder.#ctor(Org.BouncyCastle.Operators.Parameters.DekAlgorithm)">
            <summary>
            Base constructor.
            </summary>
            <param name="algorithm">The basic DEK-Info describing the cipher.</param>
        </member>
        <member name="M:Org.BouncyCastle.Operators.OpenSslPemEncryptorBuilder.WithSecureRandom(Org.BouncyCastle.Security.SecureRandom)">
            <summary>
            Configure a SecureRandom for this encryptor builder.
            </summary>
            <param name="random">The SecureRandom to use.</param>
            <returns>The current builder instance.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Operators.OpenSslPemEncryptorBuilder.Build(System.Char[])">
            <summary>
            Create a cipher builder configured for our DEK-Info and the passed in password.
            </summary>
            <param name="password">The password to key the cipher builder with.</param>
            <returns>A cipher builder for encryptors.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Operators.Parameters.DekAlgorithm">
            <summary>
            OpenSSL supported OpenSSL-PBE algorithms for PEM files.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Operators.Pkcs12MacFactoryBuilder">
            <summary>
            Builder for factories producing PBE based MAC calculators PKCS#12 style.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Operators.Pkcs12MacFactoryBuilder.#ctor">
            <summary>
            Base constructor - default SHA-1
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Operators.Pkcs12MacFactoryBuilder.#ctor(Org.BouncyCastle.Crypto.DigestAlgorithm)">
            <summary>
            Constructor specifying the particular digest to use.
            </summary>
            <param name="digest">Digest to use as the basis of the MAC algorithm</param>
        </member>
        <member name="M:Org.BouncyCastle.Operators.Pkcs12MacFactoryBuilder.WithIV(System.Byte[])">
            <summary>
            Set the initialisation vector for the underlying key deriviation used.
            </summary>
            <param name="iv">IV or salt for key derivation</param>
            <returns>The current builder.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Operators.Pkcs12MacFactoryBuilder.WithIterationCount(System.Int32)">
            <summary>
            Set the iteration count for the underlying key deriviation used.
            </summary>
            <param name="iterationCount"></param>
            <returns>The current builder.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Operators.Pkcs12MacFactoryBuilder.Build(System.Char[])">
            <summary>
            Build a MAC factory based on the current configuration, keyed using password.
            </summary>
            <param name="password">the password to derive the MAC key from.</param>
            <returns>a new MAC factory for PKCS#12</returns>
        </member>
        <member name="T:Org.BouncyCastle.Operators.PkixDatedVerifierFactory">
            <summary>
            Verifier class for signature verification in ASN.1 based profiles that use an AlgorithmIdentifier to preserve
            signature algorithm details which is also backed by a certificate.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Operators.PkixDatedVerifierFactory.#ctor(Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier,Org.BouncyCastle.Crypto.IVerifierFactory{Org.BouncyCastle.Crypto.IParameters{Org.BouncyCastle.Crypto.Algorithm}},Org.BouncyCastle.Cert.X509Certificate)">
            <summary>
            Base constructor.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Operators.PkixDatedVerifierFactory.AlgorithmDetails">
            <summary>
            Return the algorithm details for the wrapped verifier factory object as an AlgorithmIdentifier object.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Operators.PkixDatedVerifierFactory.CreateCalculator">
            <summary>
            Return a calculator generated from the wrapped verifier factory object.
            </summary>
            <returns>A calculator to use for verifying a signature</returns>
        </member>
        <member name="M:Org.BouncyCastle.Operators.PkixDatedVerifierFactory.IsValidAt(System.DateTime)">
            <summary>
            Check if the certificate this verifier is based on is valid at the passed in dateTime,
            returning true if it is.
            </summary>
            <param name="dateTime">Time to check at.</param>
            <returns>true if our underlying certificate is valid, false otherwise.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Operators.PkixPbeDecryptorProviderBuilder">
            <summary>
            Builder class for creating a provider of password based decryptors based on AlgorithmIdentifier objects found in 
            encrypted structures.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Operators.PkixPbeDecryptorProviderBuilder.#ctor">
            <summary>
            Base constructor.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Operators.PkixPbeDecryptorProviderBuilder.Build(System.Char[])">
            <summary>
            Build a provider of decryptors keyed by password.
            </summary>
            <param name="password">The password to configure the decryptor for.</param>
            <returns>A provider for decryptors that will be keyed by password.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Operators.PkixPbeEncryptorBuilder.#ctor(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>
            Basic constructor - UTF8 conversion with HMAC SHA-384 as the PRF, unless the algorithm specifies otherwise.
            </summary>
            <param name="keyEncAlgorithm"></param>
        </member>
        <member name="T:Org.BouncyCastle.Operators.PkixSignatureFactory">
            <summary>
            Calculator factory class for signature generation in ASN.1 based profiles that use an AlgorithmIdentifier to preserve
            signature algorithm details.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Operators.PkixSignatureFactory.#ctor(Org.BouncyCastle.Crypto.ISignatureFactory{Org.BouncyCastle.Crypto.IParameters{Org.BouncyCastle.Crypto.Algorithm}})">
            <summary>
            Base constructor.
            </summary>
            <param name="baseFactory">The base factory to be used in the signing operation.</param>
        </member>
        <member name="M:Org.BouncyCastle.Operators.PkixSignatureFactory.#ctor(System.String,Org.BouncyCastle.Crypto.ISignatureFactory{Org.BouncyCastle.Crypto.IParameters{Org.BouncyCastle.Crypto.Algorithm}})">
            <summary>
            Base constructor, using an string version of the algorithm name.
            </summary>
            <param name="algorithm">The name of the signature algorithm to use.</param>
            <param name="baseFactory">The underlying signature factory used in this signature factory.</param>
        </member>
        <member name="P:Org.BouncyCastle.Operators.PkixSignatureFactory.AlgorithmDetails">
            <summary>
            Return the algorithm identifier representation for the signature factory.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Operators.PkixSignatureFactory.SignatureAlgNames">
            <summary>
            Return a collection of the signature names supported by the signature factory.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Operators.PkixVerifierFactory">
            <summary>
            Verifier class for signature verification in ASN.1 based profiles that use an AlgorithmIdentifier to preserve
            signature algorithm details.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Operators.PkixVerifierFactory.#ctor(Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier,Org.BouncyCastle.Crypto.IVerifierFactory{Org.BouncyCastle.Crypto.IParameters{Org.BouncyCastle.Crypto.Algorithm}})">
            <summary>
            Base constructor.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Operators.PkixVerifierFactory.AlgorithmDetails">
            <summary>
            Return the algorithm details for the wrapped verifier factory object as an AlgorithmIdentifier object.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Operators.PkixVerifierFactory.CreateCalculator">
            <summary>
            Return a calculator generated from the wrapped verifier factory object.
            </summary>
            <returns>A calculator to use for verifying a signature</returns>
        </member>
        <member name="T:Org.BouncyCastle.Operators.PkixVerifierFactoryProvider">
            <summary>
            Provider class which supports dynamic creation of signature verifiers.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Operators.PkixVerifierFactoryProvider.#ctor(Org.BouncyCastle.Crypto.IAsymmetricPublicKey)">
            <summary>
            Base constructor - specify the public key to be used in verification.
            </summary>
            <param name="publicKey">The public key to be used in creating verifiers provided by this object.</param>
        </member>
        <member name="M:Org.BouncyCastle.Operators.PkixVerifierFactoryProvider.#ctor(Org.BouncyCastle.Cert.X509Certificate)">
            <summary>
            Base constructor - specify the certificate containing the public key to be used in verification.
            </summary>
            <param name="certificate">The certificate holding the public key to be used.</param>
        </member>
        <member name="M:Org.BouncyCastle.Operators.PkixVerifierFactoryProvider.CreateVerifierFactory(Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier)">
            <summary>
            Return a verifier factory that produces verifiers conforming to algorithmDetails.
            </summary>
            <param name="algorithmDetails">The configuration parameters for verifiers produced by the resulting factory.</param>
            <returns>A new verifier factory.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Operators.SignatureUtilities">
            <summary>
             Signer Utility class contains methods that can not be specifically grouped into other classes.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Operators.Utils.GetDigestAlgName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            Return the digest algorithm using one of the standard JCA string
            representations rather than the algorithm identifier (if possible).
        </member>
        <member name="M:Org.BouncyCastle.Operators.Utils.DigestOidForSigOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>
            Attempt to find the digest oid for a signature oid.
            For example: PkcsObjectIdentifiers.Sha256WithRsaEncryption => NistObjectIdentifiers.IdSha256
            </summary>
            <param name="sigOid">Oid of the signature algorithm.</param>
            <returns>The digest oid or null if it cannot be resolved.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Operators.Utilities.IDigestAlgorithmIdentifierFinder">
            <summary>
            Base interface for a finder of digests algorithm identifiers used with signatures.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Operators.Utilities.IDigestAlgorithmIdentifierFinder.Find(Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier)">
            <summary>
            Find the digest algorithm identifier that matches with the passed in signature algorithm identifier.
            </summary>
            <param name="sigAlgId">the signature algorithm of interest.</param>
            <returns>an algorithm identifier for the corresponding digest.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Operators.Utilities.IDigestAlgorithmIdentifierFinder.Find(System.String)">
            <summary>
            Find the algorithm identifier that matches with the passed in digest name.
            </summary>
            <param name="digAlgName">the name of the digest algorithm of interest.</param>
            <returns>an algorithm identifier for the digest signature.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Pkcs.Pkcs10CertificationRequest">
            <summary>
            Holding class for a PKCS#10 certification request.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs10CertificationRequest.#ctor(Org.BouncyCastle.Asn1.Pkcs.CertificationRequest)">
            <summary>
            Create a Pkcs10CertificationRequestHolder from an underlying ASN.1 structure.
            </summary>
            <param name="certificationRequest">The underlying ASN.1 structure representing a request.</param>
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs10CertificationRequest.#ctor(System.Byte[])">
            <summary>
            Create a Pkcs10CertificationRequestHolder from the passed in bytes.
            </summary>
            <param name="encoded">BER/DER encoding of the CertificationRequest structure.</param>
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs10CertificationRequest.ToAsn1Structure">
            <summary>
            Return the underlying ASN.1 structure for this request.
            </summary>
            <returns>A CertificateRequest object.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Pkcs.Pkcs10CertificationRequest.Subject">
            <summary>
            Return the subject on this request.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Pkcs.Pkcs10CertificationRequest.SignatureAlgorithm">
            <summary>
            Return the details of the signature algorithm used to create this request.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs10CertificationRequest.GetSignature">
            <summary>
            Return the bytes making up the signature associated with this request.
            </summary>
            <returns>The request signature bytes.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Pkcs.Pkcs10CertificationRequest.SubjectPublicKeyInfo">
            <summary>
            Return the SubjectPublicKeyInfo describing the public key this request is carrying.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs10CertificationRequest.GetAttributes">
            <summary>
            Return the attributes, if any associated with this request.
            </summary>
            <returns>An array of Attribute, zero length if none present.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs10CertificationRequest.GetAttributes(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>
            Return an  array of attributes matching the passed in type OID.
            </summary>
            <param name="type">The type of the attribute being looked for.</param>
            <returns>An array of Attribute of the requested type, zero length if none present.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs10CertificationRequest.IsSignatureValid(Org.BouncyCastle.Crypto.IVerifierFactoryProvider{Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier})">
            <summary>
            Validate the signature on the Pkcs10 certification request in this holder.
            </summary>
            <param name="verifierProvider">A ContentVerifierProvider that can generate a verifier for the signature.</param>
            <returns>true if the signature is valid, false otherwise.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Pkcs.Pkcs10CertificationRequestBuilder">
             <summary>
             A class for creating PKCS#10 Certification requests.
             </summary>
             <remarks>
             <code>
             CertificationRequest ::= SEQUENCE {
                 certificationRequestInfo  CertificationRequestInfo,
                 signatureAlgorithm        AlgorithmIdentifier{ { SignatureAlgorithms } },
                 signature                 BIT STRING
             }
            
             CertificationRequestInfo ::= SEQUENCE {
                 version             INTEGER { v1(0) }
                 subject             Name,
                 subjectPKInfo   SubjectPublicKeyInfo{ { PKInfoAlgorithms } },
                 attributes[0] Attributes{ { CRIAttributes } }
              }
            
             Attributes
                 { ATTRIBUTE:IOSet } ::= SET OF Attribute{{ IOSet }}
            
             Attribute
                 { ATTRIBUTE:IOSet } ::= SEQUENCE {
                  type    ATTRIBUTE.&amp;id({ IOSet}),
                  values  SET SIZE(1..MAX) OF ATTRIBUTE.&amp;Type({ IOSet}{\@type})
                 }
             </code>
             </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs10CertificationRequestBuilder.#ctor(Org.BouncyCastle.Asn1.X500.X500Name,System.Byte[])">
            <summary>
            Constructor using an encoded subject public key info.
            </summary>
            <param name="subject">The subject for the certification request.</param>
            <param name="encodedPublicKeyInfo">An encoding of the public key to go in the final certificate.</param>
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs10CertificationRequestBuilder.#ctor(Org.BouncyCastle.Asn1.X500.X500Name,Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo)">
            <summary>
            Constructor using a subject public key info.
            </summary>
            <param name="subject">The subject for the certification request.</param>
            <param name="publicKeyInfo">The public key to go in the final certificate and be associated with the subject.</param>
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs10CertificationRequestBuilder.AddAttribute(Org.BouncyCastle.Asn1.DerObjectIdentifier,Org.BouncyCastle.Asn1.Asn1Encodable)">
            <summary>
            Add an attribute to the certification request we are building.
            </summary>
            <param name="attrType">the OID giving the type of the attribute.</param>
            <param name="attrValue">the ASN.1 structure that forms the value of the attribute.</param>
            <returns>The current builder instance.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs10CertificationRequestBuilder.AddAttribute(Org.BouncyCastle.Asn1.DerObjectIdentifier,Org.BouncyCastle.Asn1.Asn1Encodable[])">
            <summary>
            Add an attribute with multiple values to the certification request we are building.
            </summary>
            <param name="attrType">the OID giving the type of the attribute.</param>
            <param name="attrValues">an array of ASN.1 structures that form the value of the attribute.</param>
            <returns>The current builder instance.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs10CertificationRequestBuilder.SetLeaveOffEmptyAttributes(System.Boolean)">
            <summary>
            The attributes field in Pkcs10 should encoded to an empty tagged set if there are
            no attributes. Some CAs will reject requests with the attribute field present.
            </summary>
            <param name="leaveOffEmpty">true if empty attributes should be left out of the encoding false otherwise.</param>
            <returns>The current builder instance.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs10CertificationRequestBuilder.Build(Org.BouncyCastle.Crypto.ISignatureFactory{Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier})">
            <summary>
            Generate an PKCS#10 request based on the past in signer.
            </summary>
            <param name="signerFactory">the content signer to be used to generate the signature validating the certificate.</param>
            <returns>a holder containing the resulting PKCS#10 certification request.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Pkcs.Pkcs12PfxPdu">
            A holding class for the Pkcs12 Pfx structure.
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs12PfxPdu.GetContentInfos">
             Return the content infos in the AuthenticatedSafe contained in this Pfx.
            
             @return an array of ContentInfo.
        </member>
        <member name="P:Org.BouncyCastle.Pkcs.Pkcs12PfxPdu.HasMac">
             Return whether or not there is MAC attached to this file.
            
             @return true if there is, false otherwise.
        </member>
        <member name="P:Org.BouncyCastle.Pkcs.Pkcs12PfxPdu.MacAlgorithmID">
             Return the algorithm identifier describing the MAC algorithm
            
             @return the AlgorithmIdentifier representing the MAC algorithm, null if none present.
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs12PfxPdu.IsMacValid(Org.BouncyCastle.Crypto.IMacFactoryProvider{Org.BouncyCastle.Operators.Parameters.Pkcs12MacAlgDescriptor})">
             Verify the MacData attached to the PFX is consistent with what is expected.
            
             @param macCalcProviderBuilder provider builder for the calculator for the MAC
             @return true if mac data is valid, false otherwise.
             @throws PkcsException if there is a problem evaluating the MAC.
             @throws IllegalStateException if no MAC is actually present
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs12PfxPdu.ToAsn1Structure">
             Return the underlying ASN.1 object.
            
             @return a Pfx object.
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs12PfxPdu.GetEncoded(System.String)">
            Return a Pfx with the outer wrapper encoded as asked for. For example, Pfx is a usually
            a BER encoded object, to get one with DefiniteLength encoding use:
            <pre>
            getEncoded(Asn1Encoding.DL)
            </pre>
            @param encoding encoding style (Asn1Encoding.DER, Asn1Encoding.DL, Asn1Encoding.BER)
            @return a byte array containing the encoded object.
            @throws IOException
        </member>
        <member name="T:Org.BouncyCastle.Pkcs.Pkcs12PfxPduBuilder">
            <summary>
            A builder for the Pkcs#12 Pfx key and certificate store.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs12PfxPduBuilder.AddData(Org.BouncyCastle.Pkcs.Pkcs12SafeBag)">
            <summary>
            Add a SafeBag that is to be included as is.
            </summary>
            <param name="data">the SafeBag to add.</param>
            <returns>this builder.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs12PfxPduBuilder.AddEncryptedData(Org.BouncyCastle.Crypto.ICipherBuilder{Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier},Org.BouncyCastle.Pkcs.Pkcs12SafeBag)">
            <summary>
            Add a SafeBag that is to be wrapped in a EncryptedData object.
            </summary>
            <param name="dataEncryptor">the encryptor to use for encoding the data.</param>
            <param name="data">the SafeBag to include.</param>
            <returns>this builder.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs12PfxPduBuilder.AddEncryptedData(Org.BouncyCastle.Crypto.ICipherBuilder{Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier},Org.BouncyCastle.Pkcs.Pkcs12SafeBag[])">
            <summary>
            Add a set of SafeBags that are to be wrapped in a EncryptedData object.
            </summary>
            <param name="dataEncryptor">The encryptor to use for encoding the data.</param>
            <param name="data">the SafeBags to include.</param>
            <returns>this builder.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs12PfxPduBuilder.Build(Org.BouncyCastle.Crypto.IMacFactory{Org.BouncyCastle.Operators.Parameters.Pkcs12MacAlgDescriptor})">
            <summary>
            Build the Pfx structure, protecting it with a MAC calculated against the passed in password.
            </summary>
            <param name="macCalcFactory">a builder for a Pkcs12 mac calculator.</param>
            <returns>A Pfx object.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs12SafeBag.ToAsn1Structure">
             Return the underlying ASN.1 structure for this safe bag.
            
             @return a SafeBag
        </member>
        <member name="P:Org.BouncyCastle.Pkcs.Pkcs12SafeBag.Type">
             Return the BagId giving the type of content in the bag.
            
             @return the bagId
        </member>
        <member name="T:Org.BouncyCastle.Pkcs.Pkcs8EncryptedPrivateKeyInfo">
            <summary>
            A holding class for a PKCS#8 encrypted private key info object that allows for its decryption.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs8EncryptedPrivateKeyInfo.#ctor(Org.BouncyCastle.Asn1.Pkcs.EncryptedPrivateKeyInfo)">
            <summary>
            Base constructor from a PKCS#8 EncryptedPrivateKeyInfo object.
            </summary>
            <param name="encryptedPrivateKeyInfo">A PKCS#8 EncryptedPrivateKeyInfo object.</param>
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs8EncryptedPrivateKeyInfo.#ctor(System.Byte[])">
            <summary>
            Base constructor from a BER encoding of a PKCS#8 EncryptedPrivateKeyInfo object.
            </summary>
            <param name="encryptedPrivateKeyInfo">A BER encoding of a PKCS#8 EncryptedPrivateKeyInfo objects.</param>
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs8EncryptedPrivateKeyInfo.GetEncryptedData">
            <summary>
            Returns a copy of the encrypted data in this structure.
            </summary>
            <returns>Return a copy of the encrypted data in this object.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs8EncryptedPrivateKeyInfo.ToAsn1Structure">
            <summary>
            Returns the underlying ASN.1 structure inside this object.
            </summary>
            <returns>Return the EncryptedPrivateKeyInfo structure in this object.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs8EncryptedPrivateKeyInfo.GetEncoded">
            <summary>
            Return a binary ASN.1 encoding of the EncryptedPrivateKeyInfo structure in this object.
            </summary>
            <returns>A byte array containing the encoded object.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs8EncryptedPrivateKeyInfo.DecryptPrivateKeyInfo(Org.BouncyCastle.Crypto.IDecryptorBuilderProvider{Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier})">
            <summary>
            Get a decryptor from the passed in provider and decrypt the encrypted private key info, returning the result.
            </summary>
            <param name="inputDecryptorProvider">A provider to query for decryptors for the object.</param>
            <returns>The decrypted private key info structure.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Pkcs.Pkcs8EncryptedPrivateKeyInfoBuilder">
             <summary>
             A class for creating EncryptedPrivateKeyInfo structures.
             <code>
             EncryptedPrivateKeyInfo ::= SEQUENCE {
                    encryptionAlgorithm AlgorithmIdentifier { { KeyEncryptionAlgorithms } },
                    encryptedData EncryptedData
             }
            
             EncryptedData ::= OCTET STRING
            
             KeyEncryptionAlgorithms ALGORITHM-IDENTIFIER::= {
                      ... -- For local profiles
             }
             </code>
             </summary>
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs8EncryptedPrivateKeyInfoBuilder.#ctor(System.Byte[])">
            <summary>
            Constructor using an encoded PrivateKeyInfo object.
            </summary>
            <param name="encodedPrivateKeyInfo">a ASN.1 BER encoded PrivateKeyInfo object.</param>
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs8EncryptedPrivateKeyInfoBuilder.#ctor(Org.BouncyCastle.Asn1.Pkcs.PrivateKeyInfo)">
            <summary>
            Constructor using a PrivateKeyInfo object.
            </summary>
            <param name="privateKeyInfo">the PrivateKeyInfo to be processed.</param>
        </member>
        <member name="M:Org.BouncyCastle.Pkcs.Pkcs8EncryptedPrivateKeyInfoBuilder.Build(Org.BouncyCastle.Crypto.ICipherBuilder{Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier})">
            <summary>
            Create the encrypted private key info using the passed in encryptor.
            </summary>
            <param name="encryptor">The encryptor to use.</param>
            <returns>An encrypted private key info containing the original private key info.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Pkcs.PkcsException">
            <summary>
            Base exception for PKCS related issues.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Pkcs.PkcsIOException">
            <summary>
            Base exception for parsing related issues in the PKCS namespace.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Pkix.CertStatus.RevocationDate">
            <summary>
            Returns the revocationDate.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Pkix.CertStatus.Status">
            <summary>
            Returns the certStatus.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.IExtension.GetCriticalExtensionOids">
            <summary>
            Get all critical extension values, by oid
            </summary>
            <returns>IDictionary with string (OID) keys and Asn1OctetString values</returns>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.IExtension.GetNonCriticalExtensionOids">
            <summary>
            Get all non-critical extension values, by oid
            </summary>
            <returns>IDictionary with string (OID) keys and Asn1OctetString values</returns>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixAttrCertChecker.GetSupportedExtensions">
            Returns an immutable <code>Set</code> of X.509 attribute certificate
            extensions that this <code>PkixAttrCertChecker</code> supports or
            <code>null</code> if no extensions are supported.
            <p>
            Each element of the set is a <code>String</code> representing the
            Object Identifier (OID) of the X.509 extension that is supported.
            </p>
            <p>
            All X.509 attribute certificate extensions that a
            <code>PkixAttrCertChecker</code> might possibly be able to process
            should be included in the set.
            </p>
            
            @return an immutable <code>Set</code> of X.509 extension OIDs (in
                    <code>String</code> format) supported by this
                    <code>PkixAttrCertChecker</code>, or <code>null</code> if no
                    extensions are supported
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixAttrCertChecker.Check(Org.BouncyCastle.Cert.X509V2AttributeCertificate,Org.BouncyCastle.Pkix.PkixCertPath,Org.BouncyCastle.Pkix.PkixCertPath,System.Collections.Generic.ICollection{System.String})">
            Performs checks on the specified attribute certificate. Every handled
            extension is rmeoved from the <code>unresolvedCritExts</code>
            collection.
            
            @param attrCert The attribute certificate to be checked.
            @param certPath The certificate path which belongs to the attribute
                       certificate issuer public key certificate.
            @param holderCertPath The certificate path which belongs to the holder
                       certificate.
            @param unresolvedCritExts a <code>Collection</code> of OID strings
                       representing the current set of unresolved critical extensions
            @throws CertPathValidatorException if the specified attribute certificate
                        does not pass the check.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixAttrCertChecker.Clone">
            Returns a clone of this object.
            
            @return a copy of this <code>PkixAttrCertChecker</code>
        </member>
        <member name="T:Org.BouncyCastle.Pkix.PkixBuilderParameters">
            <summary>
            Summary description for PkixBuilderParameters.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixBuilderParameters.GetInstance(Org.BouncyCastle.Pkix.PkixParameters)">
             Returns an instance of <code>PkixBuilderParameters</code>.
             <p>
             This method can be used to get a copy from other
             <code>PKIXBuilderParameters</code>, <code>PKIXParameters</code>,
             and <code>ExtendedPKIXParameters</code> instances.
             </p>
            
             @param pkixParams The PKIX parameters to create a copy of.
             @return An <code>PkixBuilderParameters</code> instance.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixBuilderParameters.GetExcludedCerts">
            <summary>
            Excluded certificates are not used for building a certification path.
            </summary>
            <returns>the excluded certificates.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixBuilderParameters.SetExcludedCerts(System.Collections.Generic.ISet{Org.BouncyCastle.Cert.X509Certificate})">
            <summary>
            Sets the excluded certificates which are not used for building a
            certification path. If the <code>ISet</code> is <code>null</code> an
            empty set is assumed.
            </summary>
            <remarks>
            The given set is cloned to protect it against subsequent modifications.
            </remarks>
            <param name="excludedCerts">The excluded certificates to set.</param>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixBuilderParameters.SetParams(Org.BouncyCastle.Pkix.PkixParameters)">
            Can alse handle <code>ExtendedPKIXBuilderParameters</code> and
            <code>PKIXBuilderParameters</code>.
            
            @param params Parameters to set.
            @see org.bouncycastle.x509.ExtendedPKIXParameters#setParams(java.security.cert.PKIXParameters)
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixBuilderParameters.Clone">
             Makes a copy of this <code>PKIXParameters</code> object. Changes to the
             copy will not affect the original and vice versa.
            
             @return a copy of this <code>PKIXParameters</code> object
        </member>
        <member name="T:Org.BouncyCastle.Pkix.PkixCertFunctions">
            <summary>
            Local copies of functions that are either in the module but internal or do not exist in the module and are required by PKIX.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Pkix.PkixCertPath">
             An immutable sequence of certificates (a certification path).<br />
             <br />
             This is an abstract class that defines the methods common to all CertPaths.
             Subclasses can handle different kinds of certificates (X.509, PGP, etc.).<br />
             <br />
             All CertPath objects have a type, a list of Certificates, and one or more
             supported encodings. Because the CertPath class is immutable, a CertPath
             cannot change in any externally visible way after being constructed. This
             stipulation applies to all public fields and methods of this class and any
             added or overridden by subclasses.<br />
             <br />
             The type is a string that identifies the type of Certificates in the
             certification path. For each certificate cert in a certification path
             certPath, cert.getType().equals(certPath.getType()) must be true.<br />
             <br />
             The list of Certificates is an ordered List of zero or more Certificates.
             This List and all of the Certificates contained in it must be immutable.<br />
             <br />
             Each CertPath object must support one or more encodings so that the object
             can be translated into a byte array for storage or transmission to other
             parties. Preferably, these encodings should be well-documented standards
             (such as PKCS#7). One of the encodings supported by a CertPath is considered
             the default encoding. This encoding is used if no encoding is explicitly
             requested (for the {@link #getEncoded()} method, for instance).<br />
             <br />
             All CertPath objects are also Serializable. CertPath objects are resolved
             into an alternate {@link CertPathRep} object during serialization. This
             allows a CertPath object to be serialized into an equivalent representation
             regardless of its underlying implementation.<br />
             <br />
             CertPath objects can be created with a CertificateFactory or they can be
             returned by other classes, such as a CertPathBuilder.<br />
             <br />
             By convention, X.509 CertPaths (consisting of X509Certificates), are ordered
             starting with the target certificate and ending with a certificate issued by
             the trust anchor. That is, the issuer of one certificate is the subject of
             the following one. The certificate representing the
             {@link TrustAnchor TrustAnchor} should not be included in the certification
             path. Unvalidated X.509 CertPaths may not follow these conventions. PKIX
             CertPathValidators will detect any departure from these conventions that
             cause the certification path to be invalid and throw a
             CertPathValidatorException.<br />
             <br />
             <strong>Concurrent Access</strong><br />
             <br />
             All CertPath objects must be thread-safe. That is, multiple threads may
             concurrently invoke the methods defined in this class on a single CertPath
             object (or more than one) with no ill effects. This is also true for the List
             returned by CertPath.getCertificates.<br />
             <br />
             Requiring CertPath objects to be immutable and thread-safe allows them to be
             passed around to various pieces of code without worrying about coordinating
             access. Providing this thread-safety is generally not difficult, since the
             CertPath and List objects in question are immutable.
            
             @see CertificateFactory
             @see CertPathBuilder
            <summary>
            CertPath implementation for X.509 certificates.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPath.SortCerts(System.Collections.Generic.IList{Org.BouncyCastle.Cert.X509Certificate})">
            @param certs
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPath.#ctor(System.Collections.Generic.ICollection{Org.BouncyCastle.Cert.X509Certificate})">
             Creates a CertPath of the specified type.
             This constructor is protected because most users should use
             a CertificateFactory to create CertPaths.
             @param type the standard name of the type of Certificatesin this path
            
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPath.#ctor(System.IO.Stream,System.String)">
             Creates a CertPath of the specified type.
             This constructor is protected because most users should use
             a CertificateFactory to create CertPaths.
            
             @param type the standard name of the type of Certificatesin this path
            
        </member>
        <member name="P:Org.BouncyCastle.Pkix.PkixCertPath.Encodings">
             Returns an iteration of the encodings supported by this
             certification path, with the default encoding
             first. Attempts to modify the returned Iterator via its
             remove method result in an UnsupportedOperationException.
            
             @return an Iterator over the names of the supported encodings (as Strings)
            
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPath.Equals(System.Object)">
             Compares this certification path for equality with the specified object.
             Two CertPaths are equal if and only if their types are equal and their
             certificate Lists (and by implication the Certificates in those Lists)
             are equal. A CertPath is never equal to an object that is not a CertPath.<br />
             <br />
             This algorithm is implemented by this method. If it is overridden, the
             behavior specified here must be maintained.
            
             @param other
                        the object to test for equality with this certification path
            
             @return true if the specified object is equal to this certification path,
                     false otherwise
            
             @see Object#hashCode() Object.hashCode()
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPath.GetEncoded">
             Returns the encoded form of this certification path, using
             the default encoding.
            
             @return the encoded bytes
             @exception CertificateEncodingException if an encoding error occurs
            
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPath.GetEncoded(System.String)">
             Returns the encoded form of this certification path, using
             the specified encoding.
            
             @param encoding the name of the encoding to use
             @return the encoded bytes
             @exception CertificateEncodingException if an encoding error
             occurs or the encoding requested is not supported
            
        </member>
        <member name="P:Org.BouncyCastle.Pkix.PkixCertPath.Certificates">
            <summary>
            Returns the list of certificates in this certification
            path.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPath.ToAsn1Object(Org.BouncyCastle.Cert.X509Certificate)">
             Return a DERObject containing the encoded certificate.
            
             @param cert the X509Certificate object to be encoded
            
             @return the DERObject
            
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathBuilder.Build(Org.BouncyCastle.Pkix.PkixBuilderParameters)">
             Build and validate a CertPath using the given parameter.
            
             @param params PKIXBuilderParameters object containing all information to
                        build the CertPath
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathChecker.Init(System.Boolean)">
                     * Initializes the internal state of this <code>PKIXCertPathChecker</code>.
                     * <p>
                     * The <code>forward</code> flag specifies the order that certificates
                     * will be passed to the {@link #check check} method (forward or reverse). A
                     * <code>PKIXCertPathChecker</code> <b>must</b> support reverse checking
                     * and <b>may</b> support forward checking.
            		 * </p>
                     * 
                     * @param forward
                     *            the order that certificates are presented to the
                     *            <code>check</code> method. If <code>true</code>,
                     *            certificates are presented from target to most-trusted CA
                     *            (forward); if <code>false</code>, from most-trusted CA to
                     *            target (reverse).
                     * @exception CertPathValidatorException
                     *                if this <code>PKIXCertPathChecker</code> is unable to
                     *                check certificates in the specified order; it should never
                     *                be thrown if the forward flag is false since reverse
                     *                checking must be supported
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathChecker.IsForwardCheckingSupported">
            Indicates if forward checking is supported. Forward checking refers to
            the ability of the <code>PKIXCertPathChecker</code> to perform its
            checks when certificates are presented to the <code>check</code> method
            in the forward direction (from target to most-trusted CA).
            
            @return <code>true</code> if forward checking is supported,
                    <code>false</code> otherwise
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathChecker.GetSupportedExtensions">
                     * Returns an immutable <code>Set</code> of X.509 certificate extensions
                     * that this <code>PKIXCertPathChecker</code> supports (i.e. recognizes,
                     * is able to process), or <code>null</code> if no extensions are
                     * supported.
                     * <p>
                     * Each element of the set is a <code>String</code> representing the
                     * Object Identifier (OID) of the X.509 extension that is supported. The OID
                     * is represented by a set of nonnegative integers separated by periods.
                     * </p><p>
                     * All X.509 certificate extensions that a <code>PKIXCertPathChecker</code>
                     * might possibly be able to process should be included in the set.
            		 * </p>
                     * 
                     * @return an immutable <code>Set</code> of X.509 extension OIDs (in
                     *         <code>String</code> format) supported by this
                     *         <code>PKIXCertPathChecker</code>, or <code>null</code> if no
                     *         extensions are supported
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathChecker.Check(Org.BouncyCastle.Cert.X509Certificate,System.Collections.Generic.ISet{Org.BouncyCastle.Asn1.DerObjectIdentifier})">
            Performs the check(s) on the specified certificate using its internal
            state and removes any critical extensions that it processes from the
            specified collection of OID strings that represent the unresolved
            critical extensions. The certificates are presented in the order
            specified by the <code>init</code> method.
            
            @param cert
                       the <code>Certificate</code> to be checked
            @param unresolvedCritExts
                       a <code>Collection</code> of OID strings representing the
                       current set of unresolved critical extensions
            @exception CertPathValidatorException
                           if the specified certificate does not pass the check
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathChecker.Clone">
            Returns a clone of this object. Calls the <code>Object.clone()</code>
            method. All subclasses which maintain state must support and override
            this method, if necessary.
            
            @return a copy of this <code>PKIXCertPathChecker</code>
        </member>
        <member name="T:Org.BouncyCastle.Pkix.PkixCertPathValidator">
            The <i>Service Provider Interface</i> (<b>SPI</b>)
            for the {@link CertPathValidator CertPathValidator} class. All
            <code>CertPathValidator</code> implementations must include a class (the
            SPI class) that extends this class (<code>CertPathValidatorSpi</code>)
            and implements all of its methods. In general, instances of this class
            should only be accessed through the <code>CertPathValidator</code> class.
            For details, see the Java Cryptography Architecture.<br />
            <br />
            <b>Concurrent Access</b><br />
            <br />
            Instances of this class need not be protected against concurrent
            access from multiple threads. Threads that need to access a single
            <code>CertPathValidatorSpi</code> instance concurrently should synchronize
            amongst themselves and provide the necessary locking before calling the
            wrapping <code>CertPathValidator</code> object.<br />
            <br />
            However, implementations of <code>CertPathValidatorSpi</code> may still
            encounter concurrency issues, since multiple threads each
            manipulating a different <code>CertPathValidatorSpi</code> instance need not
            synchronize.
            <summary>
            CertPathValidatorSpi implementation for X.509 Certificate validation a la RFC
            3280.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Pkix.PkixCertPathValidatorException">
             An exception indicating one of a variety of problems encountered when 
             validating a certification path. <br />
             <br />
             A <code>CertPathValidatorException</code> provides support for wrapping
             exceptions. The {@link #getCause getCause} method returns the throwable, 
             if any, that caused this exception to be thrown. <br />
             <br />
             A <code>CertPathValidatorException</code> may also include the 
             certification path that was being validated when the exception was thrown 
             and the index of the certificate in the certification path that caused the 
             exception to be thrown. Use the {@link #getCertPath getCertPath} and
             {@link #getIndex getIndex} methods to retrieve this information.<br />
             <br />
             <b>Concurrent Access</b><br />
             <br />
             Unless otherwise specified, the methods defined in this class are not
             thread-safe. Multiple threads that need to access a single
             object concurrently should synchronize amongst themselves and
             provide the necessary locking. Multiple threads each manipulating
             separate objects need not synchronize.
            
             @see CertPathValidator
            
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathValidatorException.#ctor(System.String)">
            <summary>
            Creates a <code>PkixCertPathValidatorException</code> with the given detail
            message. A detail message is a <code>String</code> that describes this
            particular exception. 
            </summary>
            <param name="message">the detail message</param>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathValidatorException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a <code>PkixCertPathValidatorException</code> with the specified
            detail message and cause.
            </summary>
            <param name="message">the detail message</param>
            <param name="cause">the cause (which is saved for later retrieval by the
            {@link #getCause getCause()} method). (A <code>null</code>
            value is permitted, and indicates that the cause is
            nonexistent or unknown.)</param>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathValidatorException.#ctor(System.String,System.Exception,Org.BouncyCastle.Pkix.PkixCertPath,System.Int32)">
            <summary>
            Creates a <code>PkixCertPathValidatorException</code> with the specified
            detail message, cause, certification path, and index.
            </summary>
            <param name="message">the detail message (or <code>null</code> if none)</param>
            <param name="cause">the cause (or <code>null</code> if none)</param>
            <param name="certPath">the certification path that was in the process of being
            validated when the error was encountered</param>
            <param name="index">the index of the certificate in the certification path that</param>																																																																																   * 
        </member>
        <member name="P:Org.BouncyCastle.Pkix.PkixCertPathValidatorException.Message">
            <summary>
            Returns the detail message for this <code>CertPathValidatorException</code>.
            </summary>
            <returns>the detail message, or <code>null</code> if neither the message nor cause were specified</returns>
        </member>
        <member name="P:Org.BouncyCastle.Pkix.PkixCertPathValidatorException.CertPath">
            Returns the certification path that was being validated when the
            exception was thrown.
            
            @return the <code>CertPath</code> that was being validated when the
                    exception was thrown (or <code>null</code> if not specified)
        </member>
        <member name="P:Org.BouncyCastle.Pkix.PkixCertPathValidatorException.Index">
            Returns the index of the certificate in the certification path that
            caused the exception to be thrown. Note that the list of certificates in
            a <code>CertPath</code> is zero based. If no index has been set, -1 is
            returned.
            
            @return the index that has been set, or -1 if none has been set
        </member>
        <member name="T:Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities">
            <summary>
            Summary description for PkixCertPathValidatorUtilities.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities.KEY_CERT_SIGN">
            <summary>
            key usage bits
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities.FindTrustAnchor(Org.BouncyCastle.Cert.X509Certificate,System.Collections.Generic.ISet{Org.BouncyCastle.Pkix.TrustAnchor})">
            <summary>
            Search the given Set of TrustAnchor's for one that is the
            issuer of the given X509 certificate.
            </summary>
            <param name="cert">the X509 certificate</param>
            <param name="trustAnchors">a Set of TrustAnchor's</param>
            <returns>the <code>TrustAnchor</code> object if found or
            <code>null</code> if not.
            </returns>
            @exception
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities.GetIssuerPrincipal(System.Object)">
            <summary>
            Returns the issuer of an attribute certificate or certificate.
            </summary>
            <param name="cert">The attribute certificate or certificate.</param>
            <returns>The issuer as <code>X500Principal</code>.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities.GetNextWorkingKey(System.Collections.Generic.IList{Org.BouncyCastle.Cert.X509Certificate},System.Int32)">
             Return the next working key inheriting DSA parameters if necessary.
             <p>
             This methods inherits DSA parameters from the indexed certificate or
             previous certificates in the certificate chain to the returned
             <code>PublicKey</code>. The list is searched upwards, meaning the end
             certificate is at position 0 and previous certificates are following.
             </p>
             <p>
             If the indexed certificate does not contain a DSA key this method simply
             returns the public key. If the DSA key already contains DSA parameters
             the key is also only returned.
             </p>
            
             @param certs The certification path.
             @param index The index of the certificate which contains the public key
                        which should be extended with DSA parameters.
             @return The public key of the certificate in list position
                     <code>index</code> extended with DSA parameters if applicable.
             @throws Exception if DSA parameters cannot be inherited.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities.FindCertificates(Org.BouncyCastle.Pkix.X509CertStoreSelector,System.Collections.Generic.ICollection{Org.BouncyCastle.Utilities.IStore{Org.BouncyCastle.Cert.X509Certificate}})">
            <summary>
            Return a Collection of all certificates or attribute certificates found
            in the X509Store's that are matching the certSelect criteriums.
            </summary>
            <param name="certSelect">a {@link Selector} object that will be used to select
            the certificates</param>
            <param name="certStores">a List containing only X509Store objects. These
            are used to search for certificates.</param>
            <returns>a Collection of all found <see cref="T:Org.BouncyCastle.Cert.X509Certificate"/> objects.
            May be empty but never <code>null</code>.</returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities.GetCrlIssuersFromDistributionPoint(Org.BouncyCastle.Asn1.X509.DistributionPoint,System.Collections.ICollection,Org.BouncyCastle.Pkix.X509CrlStoreSelector,Org.BouncyCastle.Pkix.PkixParameters)">
             Add the CRL issuers from the cRLIssuer field of the distribution point or
             from the certificate if not given to the issuer criterion of the
             <code>selector</code>.
             <p>
             The <code>issuerPrincipals</code> are a collection with a single
             <code>X500Principal</code> for <code>X509Certificate</code>s. For
             {@link X509AttributeCertificate}s the issuer may contain more than one
             <code>X500Principal</code>.
             </p>
            
             @param dp The distribution point.
             @param issuerPrincipals The issuers of the certificate or attribute
                        certificate which contains the distribution point.
             @param selector The CRL selector.
             @param pkixParams The PKIX parameters containing the cert stores.
             @throws Exception if an exception occurs while processing.
             @throws ClassCastException if <code>issuerPrincipals</code> does not
             contain only <code>X500Principal</code>s.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities.GetCompleteCrls(Org.BouncyCastle.Asn1.X509.DistributionPoint,System.Object,System.DateTime,Org.BouncyCastle.Pkix.PkixParameters)">
             Fetches complete CRLs according to RFC 3280.
            
             @param dp The distribution point for which the complete CRL
             @param cert The <code>X509Certificate</code> or
                        {@link org.bouncycastle.x509.X509AttributeCertificate} for
                        which the CRL should be searched.
             @param currentDate The date for which the delta CRLs must be valid.
             @param paramsPKIX The extended PKIX parameters.
             @return A <code>Set</code> of <code>X509CRL</code>s with complete
                     CRLs.
             @throws Exception if an exception occurs while picking the CRLs
                         or no CRLs are found.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities.GetDeltaCrls(System.DateTime,Org.BouncyCastle.Pkix.PkixParameters,Org.BouncyCastle.Cert.X509Crl)">
             Fetches delta CRLs according to RFC 3280 section 5.2.4.
            
             @param currentDate The date for which the delta CRLs must be valid.
             @param paramsPKIX The extended PKIX parameters.
             @param completeCRL The complete CRL the delta CRL is for.
             @return A <code>Set</code> of <code>X509CRL</code>s with delta CRLs.
             @throws Exception if an exception occurs while picking the delta
                         CRLs.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities.FindIssuerCerts(Org.BouncyCastle.Cert.X509Certificate,Org.BouncyCastle.Pkix.PkixBuilderParameters)">
             Find the issuer certificates of a given certificate.
            
             @param cert
                        The certificate for which an issuer should be found.
             @param pkixParams
             @return A <code>Collection</code> object containing the issuer
                     <code>X509Certificate</code>s. Never <code>null</code>.
            
             @exception Exception
                            if an error occurs.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCertPathValidatorUtilities.GetExtensionValue(Org.BouncyCastle.Asn1.X509.X509Extensions,Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            <summary>
            Extract the value of the given extension, if it exists.
            </summary>
            <param name="ext">The extension object.</param>
            <param name="oid">The object identifier to obtain.</param>
            <returns>Asn1Object</returns>
            <exception cref="T:System.Exception">if the extension cannot be read.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixCrlUtilities.FindCrls(Org.BouncyCastle.Utilities.ISelector{Org.BouncyCastle.Cert.X509Crl},System.Collections.Generic.ICollection{Org.BouncyCastle.Utilities.IStore{Org.BouncyCastle.Cert.X509Crl}})">
            <summary>
            crl checking
            Return a Collection of all CRLs found in the X509Store's that are
            matching the crlSelect criteriums.
            </summary>
            <param name="crlSelect">a {@link X509CRLStoreSelector} object that will be used
            to select the CRLs</param>
            <param name="crlStores">a List containing only {@link org.bouncycastle.x509.X509Store
            X509Store} objects. These are used to search for CRLs</param>
            <returns>a Collection of all found {@link X509CRL X509CRL} objects. May be
            empty but never <code>null</code>.
            </returns>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.IntersectIP(System.Collections.Generic.ISet{System.Byte[]},Org.BouncyCastle.Utilities.Collections.ISet)">
             Returns the intersection of the permitted IP ranges in
             <code>permitted</code> with <code>ip</code>.
            
             @param permitted A <code>Set</code> of permitted IP addresses with
                              their subnet mask as byte arrays.
             @param ips       The IP address with its subnet mask.
             @return The <code>Set</code> of permitted IP ranges intersected with
                     <code>ip</code>.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.UnionIP(System.Collections.Generic.ISet{System.Byte[]},System.Byte[])">
             Returns the union of the excluded IP ranges in <code>excluded</code>
             with <code>ip</code>.
            
             @param excluded A <code>Set</code> of excluded IP addresses with their
                             subnet mask as byte arrays.
             @param ip       The IP address with its subnet mask.
             @return The <code>Set</code> of excluded IP ranges unified with
                     <code>ip</code> as byte arrays.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.UnionIPRange(System.Byte[],System.Byte[])">
             Calculates the union if two IP ranges.
            
             @param ipWithSubmask1 The first IP address with its subnet mask.
             @param ipWithSubmask2 The second IP address with its subnet mask.
             @return A <code>Set</code> with the union of both addresses.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.IntersectIPRange(System.Byte[],System.Byte[])">
             Calculates the interesction if two IP ranges.
            
             @param ipWithSubmask1 The first IP address with its subnet mask.
             @param ipWithSubmask2 The second IP address with its subnet mask.
             @return A <code>Set</code> with the single IP address with its subnet
                     mask as a byte array or an empty <code>Set</code>.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.IpWithSubnetMask(System.Byte[],System.Byte[])">
             Concatenates the IP address with its subnet mask.
            
             @param ip         The IP address.
             @param subnetMask Its subnet mask.
             @return The concatenated IP address with its subnet mask.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.ExtractIPsAndSubnetMasks(System.Byte[],System.Byte[])">
             Splits the IP addresses and their subnet mask.
            
             @param ipWithSubmask1 The first IP address with the subnet mask.
             @param ipWithSubmask2 The second IP address with the subnet mask.
             @return An array with two elements. Each element contains the IP address
                     and the subnet mask in this order.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.MinMaxIPs(System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
             Based on the two IP addresses and their subnet masks the IP range is
             computed for each IP address - subnet mask pair and returned as the
             minimum IP address and the maximum address of the range.
            
             @param ip1         The first IP address.
             @param subnetmask1 The subnet mask of the first IP address.
             @param ip2         The second IP address.
             @param subnetmask2 The subnet mask of the second IP address.
             @return A array with two elements. The first/second element contains the
                     min and max IP address of the first/second IP address and its
                     subnet mask.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.CheckPermittedIP(System.Collections.Generic.ISet{System.Byte[]},System.Byte[])">
             Checks if the IP <code>ip</code> is included in the permitted ISet
             <code>permitted</code>.
            
             @param permitted A <code>Set</code> of permitted IP addresses with
                              their subnet mask as byte arrays.
             @param ip        The IP address.
             @throws PkixNameConstraintValidatorException
                      if the IP is not permitted.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.checkExcludedIP(System.Collections.Generic.ISet{System.Byte[]},System.Byte[])">
             Checks if the IP <code>ip</code> is included in the excluded ISet
             <code>excluded</code>.
            
             @param excluded A <code>Set</code> of excluded IP addresses with their
                             subnet mask as byte arrays.
             @param ip       The IP address.
             @throws PkixNameConstraintValidatorException
                      if the IP is excluded.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.IsIPConstrained(System.Byte[],System.Byte[])">
             Checks if the IP address <code>ip</code> is constrained by
             <code>constraint</code>.
            
             @param ip         The IP address.
             @param constraint The constraint. This is an IP address concatenated with
                               its subnetmask.
             @return <code>true</code> if constrained, <code>false</code>
                     otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.unionEmail(System.String,System.String,System.Collections.Generic.ISet{System.String})">
             The common part of <code>email1</code> and <code>email2</code> is
             added to the union <code>union</code>. If <code>email1</code> and
             <code>email2</code> have nothing in common they are added both.
            
             @param email1 Email address constraint 1.
             @param email2 Email address constraint 2.
             @param union  The union.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.intersectEmail(System.String,System.String,System.Collections.Generic.ISet{System.String})">
             The most restricting part from <code>email1</code> and
             <code>email2</code> is added to the intersection <code>intersect</code>.
            
             @param email1    Email address constraint 1.
             @param email2    Email address constraint 2.
             @param intersect The intersection.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.checkPermitted(Org.BouncyCastle.Asn1.X509.GeneralName)">
             Checks if the given GeneralName is in the permitted ISet.
            
             @param name The GeneralName
             @throws PkixNameConstraintValidatorException
                      If the <code>name</code>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.checkExcluded(Org.BouncyCastle.Asn1.X509.GeneralName)">
             Check if the given GeneralName is contained in the excluded ISet.
            
             @param name The GeneralName.
             @throws PkixNameConstraintValidatorException
                      If the <code>name</code> is
                      excluded.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.IntersectPermittedSubtree(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Updates the permitted ISet of these name constraints with the intersection
             with the given subtree.
            
             @param permitted The permitted subtrees
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.AddExcludedSubtree(Org.BouncyCastle.Asn1.X509.GeneralSubtree)">
             Adds a subtree to the excluded ISet of these name constraints.
            
             @param subtree A subtree with an excluded GeneralName.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.Max(System.Byte[],System.Byte[])">
             Returns the maximum IP address.
            
             @param ip1 The first IP address.
             @param ip2 The second IP address.
             @return The maximum IP address.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.Min(System.Byte[],System.Byte[])">
             Returns the minimum IP address.
            
             @param ip1 The first IP address.
             @param ip2 The second IP address.
             @return The minimum IP address.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.CompareTo(System.Byte[],System.Byte[])">
             Compares IP address <code>ip1</code> with <code>ip2</code>. If ip1
             is equal to ip2 0 is returned. If ip1 is bigger 1 is returned, -1
             otherwise.
            
             @param ip1 The first IP address.
             @param ip2 The second IP address.
             @return 0 if ip1 is equal to ip2, 1 if ip1 is bigger, -1 otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.Or(System.Byte[],System.Byte[])">
             Returns the logical OR of the IP addresses <code>ip1</code> and
             <code>ip2</code>.
            
             @param ip1 The first IP address.
             @param ip2 The second IP address.
             @return The OR of <code>ip1</code> and <code>ip2</code>.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixNameConstraintValidator.StringifyIP(System.Byte[])">
             Stringifies an IPv4 or v6 address with subnet mask.
            
             @param ip The IP with subnet mask.
             @return The stringified IP address.
        </member>
        <member name="F:Org.BouncyCastle.Pkix.PkixParameters.PkixValidityModel">
            This is the default PKIX validity model. Actually there are two variants
            of this: The PKIX model and the modified PKIX model. The PKIX model
            verifies that all involved certificates must have been valid at the
            current time. The modified PKIX model verifies that all involved
            certificates were valid at the signing time. Both are indirectly choosen
            with the {@link PKIXParameters#setDate(java.util.Date)} method, so this
            methods sets the Date when <em>all</em> certificates must have been
            valid.
        </member>
        <member name="F:Org.BouncyCastle.Pkix.PkixParameters.ChainValidityModel">
            This model uses the following validity model. Each certificate must have
            been valid at the moment where is was used. That means the end
            certificate must have been valid at the time the signature was done. The
            CA certificate which signed the end certificate must have been valid,
            when the end certificate was signed. The CA (or Root CA) certificate must
            have been valid, when the CA certificate was signed and so on. So the
            {@link PKIXParameters#setDate(java.util.Date)} method sets the time, when
            the <em>end certificate</em> must have been valid. <p/> It is used e.g.
            in the German signature law.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.#ctor(System.Collections.Generic.ISet{Org.BouncyCastle.Pkix.TrustAnchor})">
             Creates an instance of PKIXParameters with the specified Set of
             most-trusted CAs. Each element of the set is a TrustAnchor.<br />
             <br />
             Note that the Set is copied to protect against subsequent modifications.
            
             @param trustAnchors
                        a Set of TrustAnchors
            
             @exception InvalidAlgorithmParameterException
                            if the specified Set is empty
                            <code>(trustAnchors.isEmpty() == true)</code>
             @exception NullPointerException
                            if the specified Set is <code>null</code>
             @exception ClassCastException
                            if any of the elements in the Set are not of type
                            <code>java.security.cert.TrustAnchor</code>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.GetTargetCertConstraints">
             Returns the required constraints on the target certificate. The
             constraints are returned as an instance of CertSelector. If
             <code>null</code>, no constraints are defined.<br />
             <br />
             Note that the CertSelector returned is cloned to protect against
             subsequent modifications.
            
             @return a CertSelector specifying the constraints on the target
                     certificate (or <code>null</code>)
            
             @see #setTargetCertConstraints(CertSelector)
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.SetTargetCertConstraints(Org.BouncyCastle.Utilities.ISelector{Org.BouncyCastle.Cert.X509Certificate})">
             Sets the required constraints on the target certificate. The constraints
             are specified as an instance of CertSelector. If null, no constraints are
             defined.<br />
             <br />
             Note that the CertSelector specified is cloned to protect against
             subsequent modifications.
            
             @param selector
                        a CertSelector specifying the constraints on the target
                        certificate (or <code>null</code>)
            
             @see #getTargetCertConstraints()
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.GetInitialPolicies">
             Returns an immutable Set of initial policy identifiers (OID strings),
             indicating that any one of these policies would be acceptable to the
             certificate user for the purposes of certification path processing. The
             default return value is an empty <code>Set</code>, which is
             interpreted as meaning that any policy would be acceptable.
            
             @return an immutable <code>Set</code> of initial policy OIDs in String
                     format, or an empty <code>Set</code> (implying any policy is
                     acceptable). Never returns <code>null</code>.
            
             @see #setInitialPolicies(java.util.Set)
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.SetInitialPolicies(System.Collections.Generic.ISet{System.String})">
             Sets the <code>Set</code> of initial policy identifiers (OID strings),
             indicating that any one of these policies would be acceptable to the
             certificate user for the purposes of certification path processing. By
             default, any policy is acceptable (i.e. all policies), so a user that
             wants to allow any policy as acceptable does not need to call this
             method, or can call it with an empty <code>Set</code> (or
             <code>null</code>).<br />
             <br />
             Note that the Set is copied to protect against subsequent modifications.<br />
             <br />
            
             @param initialPolicies
                        a Set of initial policy OIDs in String format (or
                        <code>null</code>)
            
             @exception ClassCastException
                            if any of the elements in the set are not of type String
            
             @see #getInitialPolicies()
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.SetCertPathCheckers(System.Collections.Generic.ICollection{Org.BouncyCastle.Pkix.PkixCertPathChecker})">
             Sets a <code>List</code> of additional certification path checkers. If
             the specified List contains an object that is not a PKIXCertPathChecker,
             it is ignored.<br />
             <br />
             Each <code>PKIXCertPathChecker</code> specified implements additional
             checks on a certificate. Typically, these are checks to process and
             verify private extensions contained in certificates. Each
             <code>PKIXCertPathChecker</code> should be instantiated with any
             initialization parameters needed to execute the check.<br />
             <br />
             This method allows sophisticated applications to extend a PKIX
             <code>CertPathValidator</code> or <code>CertPathBuilder</code>. Each
             of the specified PKIXCertPathCheckers will be called, in turn, by a PKIX
             <code>CertPathValidator</code> or <code>CertPathBuilder</code> for
             each certificate processed or validated.<br />
             <br />
             Regardless of whether these additional PKIXCertPathCheckers are set, a
             PKIX <code>CertPathValidator</code> or <code>CertPathBuilder</code>
             must perform all of the required PKIX checks on each certificate. The one
             exception to this rule is if the RevocationEnabled flag is set to false
             (see the {@link #setRevocationEnabled(boolean) setRevocationEnabled}
             method).<br />
             <br />
             Note that the List supplied here is copied and each PKIXCertPathChecker
             in the list is cloned to protect against subsequent modifications.
            
             @param checkers
                        a List of PKIXCertPathCheckers. May be null, in which case no
                        additional checkers will be used.
             @exception ClassCastException
                            if any of the elements in the list are not of type
                            <code>java.security.cert.PKIXCertPathChecker</code>
             @see #getCertPathCheckers()
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.GetCertPathCheckers">
             Returns the List of certification path checkers. Each PKIXCertPathChecker
             in the returned IList is cloned to protect against subsequent modifications.
            
             @return an immutable List of PKIXCertPathCheckers (may be empty, but not
                     <code>null</code>)
            
             @see #setCertPathCheckers(java.util.List)
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.AddCertPathChecker(Org.BouncyCastle.Pkix.PkixCertPathChecker)">
             Adds a <code>PKIXCertPathChecker</code> to the list of certification
             path checkers. See the {@link #setCertPathCheckers setCertPathCheckers}
             method for more details.
             <p>
             Note that the <code>PKIXCertPathChecker</code> is cloned to protect
             against subsequent modifications.</p>
            
             @param checker a <code>PKIXCertPathChecker</code> to add to the list of
             checks. If <code>null</code>, the checker is ignored (not added to list).
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.SetParams(Org.BouncyCastle.Pkix.PkixParameters)">
             Method to support <code>Clone()</code> under J2ME.
             <code>super.Clone()</code> does not exist and fields are not copied.
            
             @param params Parameters to set. If this are
                        <code>ExtendedPkixParameters</code> they are copied to.
        </member>
        <member name="P:Org.BouncyCastle.Pkix.PkixParameters.IsUseDeltasEnabled">
            Whether delta CRLs should be used for checking the revocation status.
            Defaults to <code>false</code>.
        </member>
        <member name="P:Org.BouncyCastle.Pkix.PkixParameters.ValidityModel">
            The validity model.
            @see #CHAIN_VALIDITY_MODEL
            @see #PKIX_VALIDITY_MODEL
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.SetCertStores(System.Collections.Generic.ICollection{Org.BouncyCastle.Utilities.IStore{Org.BouncyCastle.Cert.X509Certificate}})">
             Sets the Bouncy Castle Stores for finding CRLs, certificates, attribute
             certificates or cross certificates.
             <p>
             The <code>IList</code> is cloned.
             </p>
            
             @param stores A list of stores to use.
             @see #getStores
             @throws ClassCastException if an element of <code>stores</code> is not
                         a {@link Store}.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.AddCertStore(Org.BouncyCastle.Utilities.IStore{Org.BouncyCastle.Cert.X509Certificate})">
             Adds a Bouncy Castle {@link Store} to find CRLs, certificates, attribute
             certificates or cross certificates.
             <p>
             This method should be used to add local stores, like collection based
             X.509 stores, if available. Local stores should be considered first,
             before trying to use additional (remote) locations, because they do not
             need possible additional network traffic.
             </p><p>
             If <code>store</code> is <code>null</code> it is ignored.
             </p>
            
             @param store The store to add.
             @see #getStores
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.AddCrlStore(Org.BouncyCastle.Utilities.IStore{Org.BouncyCastle.Cert.X509Crl})">
            <summary>
            Add a CRL store.
            </summary>
            <param name="crl">The crl store to add.</param>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.GetCrlStores">
            <summary>
            Return an unmodifiable collection of the CRL stores.
            </summary>
            <returns>A copy of the crl stores.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.GetCertStores">
             Returns an <code>IList</code> of Bouncy Castle
             <code>Store</code>s used for finding CRLs, certificates, attribute
             certificates or cross certificates.
            
             @return an immutable <code>IList</code> of Bouncy Castle
                     <code>Store</code>s. Never <code>null</code>.
            
             @see #setStores(IList)
        </member>
        <member name="P:Org.BouncyCastle.Pkix.PkixParameters.IsAdditionalLocationsEnabled">
             Returns if additional {@link X509Store}s for locations like LDAP found
             in certificates or CRLs should be used.
            
             @return Returns <code>true</code> if additional stores are used.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.SetAdditionalLocationsEnabled(System.Boolean)">
             Sets if additional {@link X509Store}s for locations like LDAP found in
             certificates or CRLs should be used.
            
             @param enabled <code>true</code> if additional stores are used.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.GetTargetConstraints">
             Returns the required constraints on the target certificate or attribute
             certificate. The constraints are returned as an instance of
             <code>IX509Selector</code>. If <code>null</code>, no constraints are
             defined.
            
             <p>
             The target certificate in a PKIX path may be a certificate or an
             attribute certificate.
             </p><p>
             Note that the <code>IX509Selector</code> returned is cloned to protect
             against subsequent modifications.
             </p>
             @return a <code>IX509Selector</code> specifying the constraints on the
                     target certificate or attribute certificate (or <code>null</code>)
             @see #setTargetConstraints
             @see X509CertStoreSelector
             @see X509AttributeCertStoreSelector
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.SetTargetConstraints(Org.BouncyCastle.Utilities.ISelector{Org.BouncyCastle.Cert.X509Certificate})">
             Sets the required constraints on the target certificate or attribute
             certificate. The constraints are specified as an instance of
             <code>IX509Selector</code>. If <code>null</code>, no constraints are
             defined.
             <p>
             The target certificate in a PKIX path may be a certificate or an
             attribute certificate.
             </p><p>
             Note that the <code>IX509Selector</code> specified is cloned to protect
             against subsequent modifications.
             </p>
            
             @param selector a <code>IX509Selector</code> specifying the constraints on
                        the target certificate or attribute certificate (or
                        <code>null</code>)
             @see #getTargetConstraints
             @see X509CertStoreSelector
             @see X509AttributeCertStoreSelector
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.GetTrustedACIssuers">
             Returns the trusted attribute certificate issuers. If attribute
             certificates is verified the trusted AC issuers must be set.
             <p>
             The returned <code>ISet</code> consists of <code>TrustAnchor</code>s.
             </p><p>
             The returned <code>ISet</code> is immutable. Never <code>null</code>
             </p>
            
             @return Returns an immutable set of the trusted AC issuers.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.SetTrustedACIssuers(System.Collections.Generic.ISet{Org.BouncyCastle.Pkix.TrustAnchor})">
             Sets the trusted attribute certificate issuers. If attribute certificates
             is verified the trusted AC issuers must be set.
             <p>
             The <code>trustedACIssuers</code> must be a <code>ISet</code> of
             <code>TrustAnchor</code>
             </p><p>
             The given set is cloned.
             </p>
            
             @param trustedACIssuers The trusted AC issuers to set. Is never
                        <code>null</code>.
             @throws ClassCastException if an element of <code>stores</code> is not
                         a <code>TrustAnchor</code>.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.GetNecessaryACAttributes">
             Returns the necessary attributes which must be contained in an attribute
             certificate.
             <p>
             The returned <code>ISet</code> is immutable and contains
             <code>String</code>s with the OIDs.
             </p>
            
             @return Returns the necessary AC attributes.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.SetNecessaryACAttributes(Org.BouncyCastle.Utilities.Collections.ISet)">
             Sets the necessary which must be contained in an attribute certificate.
             <p>
             The <code>ISet</code> must contain <code>String</code>s with the
             OIDs.
             </p><p>
             The set is cloned.
             </p>
            
             @param necessaryACAttributes The necessary AC attributes to set.
             @throws ClassCastException if an element of
                         <code>necessaryACAttributes</code> is not a
                         <code>String</code>.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.GetProhibitedACAttributes">
             Returns the attribute certificates which are not allowed.
             <p>
             The returned <code>ISet</code> is immutable and contains
             <code>String</code>s with the OIDs.
             </p>
            
             @return Returns the prohibited AC attributes. Is never <code>null</code>.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.SetProhibitedACAttributes(Org.BouncyCastle.Utilities.Collections.ISet)">
             Sets the attribute certificates which are not allowed.
             <p>
             The <code>ISet</code> must contain <code>String</code>s with the
             OIDs.
             </p><p>
             The set is cloned.
             </p>
            
             @param prohibitedACAttributes The prohibited AC attributes to set.
             @throws ClassCastException if an element of
                         <code>prohibitedACAttributes</code> is not a
                         <code>String</code>.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.GetAttrCertCheckers">
             Returns the attribute certificate checker. The returned set contains
             {@link PKIXAttrCertChecker}s and is immutable.
            
             @return Returns the attribute certificate checker. Is never
                     <code>null</code>.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixParameters.SetAttrCertCheckers(Org.BouncyCastle.Utilities.Collections.ISet)">
             Sets the attribute certificate checkers.
             <p>
             All elements in the <code>ISet</code> must a {@link PKIXAttrCertChecker}.
             </p>
             <p>
             The given set is cloned.
             </p>
            
             @param attrCertCheckers The attribute certificate checkers to set. Is
                        never <code>null</code>.
             @throws ClassCastException if an element of <code>attrCertCheckers</code>
                         is not a <code>PKIXAttrCertChecker</code>.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.PkixPolicyNode.#ctor(System.Collections.Generic.IList{Org.BouncyCastle.Pkix.PkixPolicyNode},System.Int32,Org.BouncyCastle.Utilities.Collections.ISet,Org.BouncyCastle.Pkix.PkixPolicyNode,Org.BouncyCastle.Utilities.Collections.ISet,System.String,System.Boolean)">
            Constructors
        </member>
        <member name="T:Org.BouncyCastle.Pkix.ReasonsMask">
            <summary>
            This class helps to handle CRL revocation reasons mask. Each CRL handles a
            certain set of revocation reasons.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.ReasonsMask.#ctor(System.Int32)">
            <summary>
            Constructs are reason mask with the reasons.
            </summary>
            <param name="reasons">The reasons.</param>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.ReasonsMask.#ctor">
            <summary>
            A reason mask with no reason.
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Pkix.ReasonsMask.AllReasons">
            <summary>
            A mask with all revocation reasons.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.ReasonsMask.AddReasons(Org.BouncyCastle.Pkix.ReasonsMask)">
             Adds all reasons from the reasons mask to this mask.
            
             @param mask The reasons mask to add.
        </member>
        <member name="P:Org.BouncyCastle.Pkix.ReasonsMask.IsAllReasons">
            <summary>
            Returns <code>true</code> if this reasons mask contains all possible
            reasons.
            </summary>
            <returns>true if this reasons mask contains all possible reasons.
            </returns>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.ReasonsMask.Intersect(Org.BouncyCastle.Pkix.ReasonsMask)">
            <summary>
            Intersects this mask with the given reasons mask.
            </summary>
            <param name="mask">mask The mask to intersect with.</param>
            <returns>The intersection of this and teh given mask.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.ReasonsMask.HasNewReasons(Org.BouncyCastle.Pkix.ReasonsMask)">
            <summary>
            Returns <c>true</c> if the passed reasons mask has new reasons.
            </summary>
            <param name="mask">The reasons mask which should be tested for new reasons.</param>
            <returns><c>true</c> if the passed reasons mask has new reasons.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Pkix.ReasonsMask.Reasons">
            <summary>
            Returns the reasons in this mask.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities.ProcessCrlB2(Org.BouncyCastle.Asn1.X509.DistributionPoint,System.Object,Org.BouncyCastle.Cert.X509Crl)">
             If the complete CRL includes an issuing distribution point (IDP) CRL
             extension check the following:
             <p>
             (i) If the distribution point name is present in the IDP CRL extension
             and the distribution field is present in the DP, then verify that one of
             the names in the IDP matches one of the names in the DP. If the
             distribution point name is present in the IDP CRL extension and the
             distribution field is omitted from the DP, then verify that one of the
             names in the IDP matches one of the names in the cRLIssuer field of the
             DP.
             </p>
             <p>
             (ii) If the onlyContainsUserCerts boolean is asserted in the IDP CRL
             extension, verify that the certificate does not include the basic
             constraints extension with the cA boolean asserted.
             </p>
             <p>
             (iii) If the onlyContainsCACerts boolean is asserted in the IDP CRL
             extension, verify that the certificate includes the basic constraints
             extension with the cA boolean asserted.
             </p>
             <p>
             (iv) Verify that the onlyContainsAttributeCerts boolean is not asserted.
             </p>
            
             @param dp   The distribution point.
             @param cert The certificate.
             @param crl  The CRL.
             @throws AnnotatedException if one of the conditions is not met or an error occurs.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities.ProcessCrlB1(Org.BouncyCastle.Asn1.X509.DistributionPoint,System.Object,Org.BouncyCastle.Cert.X509Crl)">
             If the DP includes cRLIssuer, then verify that the issuer field in the
             complete CRL matches cRLIssuer in the DP and that the complete CRL
             contains an
                  g distribution point extension with the indirectCRL
             boolean asserted. Otherwise, verify that the CRL issuer matches the
             certificate issuer.
            
             @param dp   The distribution point.
             @param cert The certificate ot attribute certificate.
             @param crl  The CRL for <code>cert</code>.
             @throws AnnotatedException if one of the above conditions does not apply or an error
                                        occurs.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities.ProcessCrlF(Org.BouncyCastle.Cert.X509Crl,System.Object,Org.BouncyCastle.Cert.X509Certificate,Org.BouncyCastle.Crypto.IAsymmetricKey,Org.BouncyCastle.Pkix.PkixParameters,System.Collections.Generic.IList{Org.BouncyCastle.Cert.X509Certificate})">
             Obtain and validate the certification path for the complete CRL issuer.
             If a key usage extension is present in the CRL issuer's certificate,
             verify that the cRLSign bit is set.
            
             @param crl                CRL which contains revocation information for the certificate
                                       <code>cert</code>.
             @param cert               The attribute certificate or certificate to check if it is
                                       revoked.
             @param defaultCRLSignCert The issuer certificate of the certificate <code>cert</code>.
             @param defaultCRLSignKey  The public key of the issuer certificate
                                       <code>defaultCRLSignCert</code>.
             @param paramsPKIX         paramsPKIX PKIX parameters.
             @param certPathCerts      The certificates on the certification path.
             @return A <code>Set</code> with all keys of possible CRL issuer
                     certificates.
             @throws AnnotatedException if the CRL is not valid or the status cannot be checked or
                                        some error occurs.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities.CheckCrl(Org.BouncyCastle.Asn1.X509.DistributionPoint,Org.BouncyCastle.Pkix.PkixParameters,Org.BouncyCastle.Cert.X509Certificate,System.DateTime,Org.BouncyCastle.Cert.X509Certificate,Org.BouncyCastle.Crypto.IAsymmetricKey,Org.BouncyCastle.Pkix.CertStatus,Org.BouncyCastle.Pkix.ReasonsMask,System.Collections.Generic.IList{Org.BouncyCastle.Cert.X509Certificate})">
             Checks a distribution point for revocation information for the
             certificate <code>cert</code>.
            
             @param dp                 The distribution point to consider.
             @param paramsPKIX         PKIX parameters.
             @param cert               Certificate to check if it is revoked.
             @param validDate          The date when the certificate revocation status should be
                                       checked.
             @param defaultCRLSignCert The issuer certificate of the certificate <code>cert</code>.
             @param defaultCRLSignKey  The public key of the issuer certificate
                                       <code>defaultCRLSignCert</code>.
             @param certStatus         The current certificate revocation status.
             @param reasonMask         The reasons mask which is already checked.
             @param certPathCerts      The certificates of the certification path.
             @throws AnnotatedException if the certificate is revoked or the status cannot be checked
                                        or some error occurs.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities.CheckCrls(Org.BouncyCastle.Pkix.PkixParameters,Org.BouncyCastle.Cert.X509Certificate,System.DateTime,Org.BouncyCastle.Cert.X509Certificate,Org.BouncyCastle.Crypto.IAsymmetricKey,System.Collections.Generic.IList{Org.BouncyCastle.Cert.X509Certificate})">
             Checks a certificate if it is revoked.
            
             @param paramsPKIX       PKIX parameters.
             @param cert             Certificate to check if it is revoked.
             @param validDate        The date when the certificate revocation status should be
                                     checked.
             @param sign             The issuer certificate of the certificate <code>cert</code>.
             @param workingPublicKey The public key of the issuer certificate <code>sign</code>.
             @param certPathCerts    The certificates of the certification path.
             @throws AnnotatedException if the certificate is revoked or the status cannot be checked
                                        or some error occurs.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.Rfc3280CertPathUtilities.ProcessCrlC(Org.BouncyCastle.Cert.X509Crl,Org.BouncyCastle.Cert.X509Crl,Org.BouncyCastle.Pkix.PkixParameters)">
             If use-deltas is set, verify the issuer and scope of the delta CRL.
            
             @param deltaCRL    The delta CRL.
             @param completeCRL The complete CRL.
             @param pkixParams  The PKIX paramaters.
             @throws AnnotatedException if an exception occurs.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.Rfc3281CertPathUtilities.CheckCrls(Org.BouncyCastle.Cert.X509V2AttributeCertificate,Org.BouncyCastle.Pkix.PkixParameters,Org.BouncyCastle.Cert.X509Certificate,System.DateTime,System.Collections.Generic.IList{Org.BouncyCastle.Cert.X509Certificate})">
            Checks if an attribute certificate is revoked.
            
            @param attrCert Attribute certificate to check if it is revoked.
            @param paramsPKIX PKIX parameters.
            @param issuerCert The issuer certificate of the attribute certificate
                       <code>attrCert</code>.
            @param validDate The date when the certificate revocation status should
                       be checked.
            @param certPathCerts The certificates of the certification path to be
                       checked.
            
            @throws CertPathValidatorException if the certificate is revoked or the
                        status cannot be checked or some error occurs.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.Rfc3281CertPathUtilities.ProcessAttrCert1(Org.BouncyCastle.Cert.X509V2AttributeCertificate,Org.BouncyCastle.Pkix.PkixParameters)">
            Searches for a holder public key certificate and verifies its
            certification path.
            
            @param attrCert the attribute certificate.
            @param pkixParams The PKIX parameters.
            @return The certificate path of the holder certificate.
            @throws Exception if
                        <ul>
                        <li>no public key certificate can be found although holder
                        information is given by an entity name or a base certificate
                        ID</li>
                        <li>support classes cannot be created</li>
                        <li>no certification path for the public key certificate can
                        be built</li>
                        </ul>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.Rfc3281CertPathUtilities.CheckCrl(Org.BouncyCastle.Asn1.X509.DistributionPoint,Org.BouncyCastle.Cert.X509V2AttributeCertificate,Org.BouncyCastle.Pkix.PkixParameters,System.DateTime,Org.BouncyCastle.Cert.X509Certificate,Org.BouncyCastle.Pkix.CertStatus,Org.BouncyCastle.Pkix.ReasonsMask,System.Collections.Generic.IList{Org.BouncyCastle.Cert.X509Certificate})">
            
            Checks a distribution point for revocation information for the
            certificate <code>attrCert</code>.
            
            @param dp The distribution point to consider.
            @param attrCert The attribute certificate which should be checked.
            @param paramsPKIX PKIX parameters.
            @param validDate The date when the certificate revocation status should
                       be checked.
            @param issuerCert Certificate to check if it is revoked.
            @param reasonMask The reasons mask which is already checked.
            @param certPathCerts The certificates of the certification path to be
                       checked.
            @throws Exception if the certificate is revoked or the status
                        cannot be checked or some error occurs.
        </member>
        <member name="T:Org.BouncyCastle.Pkix.TrustAnchor">
            <summary>
            A trust anchor or most-trusted Certification Authority (CA).
            
            This class represents a "most-trusted CA", which is used as a trust anchor
            for validating X.509 certification paths. A most-trusted CA includes the
            public key of the CA, the CA's name, and any constraints upon the set of
            paths which may be validated using this key. These parameters can be
            specified in the form of a trusted X509Certificate or as individual
            parameters.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.TrustAnchor.#ctor(Org.BouncyCastle.Cert.X509Certificate,System.Byte[])">
             <summary>
             Creates an instance of TrustAnchor with the specified X509Certificate and
             optional name constraints, which are intended to be used as additional
             constraints when validating an X.509 certification path.
            	The name constraints are specified as a byte array. This byte array
            	should contain the DER encoded form of the name constraints, as they
            	would appear in the NameConstraints structure defined in RFC 2459 and
            	X.509. The ASN.1 definition of this structure appears below.
            	
            	<pre>
            	NameConstraints ::= SEQUENCE {
            		permittedSubtrees       [0]     GeneralSubtrees OPTIONAL,
            		excludedSubtrees        [1]     GeneralSubtrees OPTIONAL }
            	   
             GeneralSubtrees ::= SEQUENCE SIZE (1..MAX) OF GeneralSubtree
             
            		GeneralSubtree ::= SEQUENCE {
            		base                    GeneralName,
            		minimum         [0]     BaseDistance DEFAULT 0,
            		maximum         [1]     BaseDistance OPTIONAL }
            		
            		BaseDistance ::= INTEGER (0..MAX)
            
            		GeneralName ::= CHOICE {
            		otherName                       [0]     OtherName,
            		rfc822Name                      [1]     IA5String,
            		dNSName                         [2]     IA5String,
            		x400Address                     [3]     ORAddress,
            		directoryName                   [4]     Name,
            		ediPartyName                    [5]     EDIPartyName,
            		uniformResourceIdentifier       [6]     IA5String,
            		iPAddress                       [7]     OCTET STRING,
            		registeredID                    [8]     OBJECT IDENTIFIER}
            	</pre>
            	
            	Note that the name constraints byte array supplied is cloned to protect
            	against subsequent modifications.
             </summary>
             <param name="trustedCert">a trusted X509Certificate</param>
             <param name="nameConstraints">a byte array containing the ASN.1 DER encoding of a
             NameConstraints extension to be used for checking name
             constraints. Only the value of the extension is included, not
             the OID or criticality flag. Specify null to omit the
             parameter.</param>
             <exception cref="T:System.ArgumentNullException">if the specified X509Certificate is null</exception>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.TrustAnchor.#ctor(Org.BouncyCastle.Asn1.X500.X500Name,Org.BouncyCastle.Crypto.IAsymmetricKey,System.Byte[])">
            <summary>
            Creates an instance of <c>TrustAnchor</c> where the
            most-trusted CA is specified as an X500Principal and public key.
            </summary>
            <remarks>
            <p>
            Name constraints are an optional parameter, and are intended to be used
            as additional constraints when validating an X.509 certification path.
            </p><p>
            The name constraints are specified as a byte array. This byte array
            contains the DER encoded form of the name constraints, as they
            would appear in the NameConstraints structure defined in RFC 2459
            and X.509. The ASN.1 notation for this structure is supplied in the
            documentation for the other constructors.
            </p><p>
            Note that the name constraints byte array supplied here is cloned to
            protect against subsequent modifications.
            </p>
            </remarks>
            <param name="caPrincipal">the name of the most-trusted CA as X509Name</param>
            <param name="pubKey">the public key of the most-trusted CA</param>
            <param name="nameConstraints">
            a byte array containing the ASN.1 DER encoding of a NameConstraints extension to
            be used for checking name constraints. Only the value of the extension is included,
            not the OID or criticality flag. Specify <c>null</c> to omit the parameter.
            </param>
            <exception cref="T:System.ArgumentNullException">
            if <c>caPrincipal</c> or <c>pubKey</c> is null
            </exception>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.TrustAnchor.#ctor(System.String,Org.BouncyCastle.Crypto.IAsymmetricKey,System.Byte[])">
            <summary>
            Creates an instance of <code>TrustAnchor</code> where the most-trusted
            CA is specified as a distinguished name and public key. Name constraints
            are an optional parameter, and are intended to be used as additional
            constraints when validating an X.509 certification path.
            <br/>
            The name constraints are specified as a byte array. This byte array
            contains the DER encoded form of the name constraints, as they would
            appear in the NameConstraints structure defined in RFC 2459 and X.509.
            </summary>
            <param name="caName">the X.500 distinguished name of the most-trusted CA in RFC
            2253 string format</param>
            <param name="pubKey">the public key of the most-trusted CA</param>
            <param name="nameConstraints">a byte array containing the ASN.1 DER encoding of a
            NameConstraints extension to be used for checking name
            constraints. Only the value of the extension is included, not 
            the OID or criticality flag. Specify null to omit the 
            parameter.</param>
            throws NullPointerException, IllegalArgumentException
        </member>
        <member name="P:Org.BouncyCastle.Pkix.TrustAnchor.TrustedCert">
            <summary>
            Returns the most-trusted CA certificate.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Pkix.TrustAnchor.CA">
            <summary>
            Returns the name of the most-trusted CA as an X509Name.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Pkix.TrustAnchor.CAName">
            <summary>
            Returns the name of the most-trusted CA in RFC 2253 string format.
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Pkix.TrustAnchor.CAPublicKey">
            <summary>
            Returns the public key of the most-trusted CA.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.TrustAnchor.setNameConstraints(System.Byte[])">
            <summary>
            Decode the name constraints and clone them if not null.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.TrustAnchor.ToString">
            <summary>
            Returns a formatted string describing the <code>TrustAnchor</code>.
            </summary>
            <returns>a formatted string describing the <code>TrustAnchor</code></returns>
        </member>
        <member name="F:Org.BouncyCastle.Pkix.X500NameSymbols.C">
            country code - StringType(SIZE(2))
        </member>
        <member name="F:Org.BouncyCastle.Pkix.X500NameSymbols.O">
            organization - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Pkix.X500NameSymbols.OU">
            organizational unit name - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Pkix.X500NameSymbols.T">
            Title
        </member>
        <member name="F:Org.BouncyCastle.Pkix.X500NameSymbols.CN">
            common name - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Pkix.X500NameSymbols.Street">
            street - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Pkix.X500NameSymbols.SerialNumber">
            device serial number name - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Pkix.X500NameSymbols.L">
            locality name - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Pkix.X500NameSymbols.ST">
            state, or province name - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Pkix.X500NameSymbols.Surname">
            Naming attributes of type X520name
        </member>
        <member name="F:Org.BouncyCastle.Pkix.X500NameSymbols.BusinessCategory">
            businessCategory - DirectoryString(SIZE(1..128)
        </member>
        <member name="F:Org.BouncyCastle.Pkix.X500NameSymbols.PostalCode">
            postalCode - DirectoryString(SIZE(1..40)
        </member>
        <member name="F:Org.BouncyCastle.Pkix.X500NameSymbols.DnQualifier">
            dnQualifier - DirectoryString(SIZE(1..64)
        </member>
        <member name="F:Org.BouncyCastle.Pkix.X500NameSymbols.Pseudonym">
            RFC 3039 Pseudonym - DirectoryString(SIZE(1..64)
        </member>
        <member name="F:Org.BouncyCastle.Pkix.X500NameSymbols.DateOfBirth">
            RFC 3039 DateOfBirth - GeneralizedTime - YYYYMMDD000000Z
        </member>
        <member name="F:Org.BouncyCastle.Pkix.X500NameSymbols.PlaceOfBirth">
            RFC 3039 PlaceOfBirth - DirectoryString(SIZE(1..128)
        </member>
        <member name="F:Org.BouncyCastle.Pkix.X500NameSymbols.Gender">
            RFC 3039 DateOfBirth - PrintableString (SIZE(1)) -- "M", "F", "m" or "f"
        </member>
        <member name="F:Org.BouncyCastle.Pkix.X500NameSymbols.CountryOfCitizenship">
            RFC 3039 CountryOfCitizenship - PrintableString (SIZE (2)) -- ISO 3166
            codes only
        </member>
        <member name="F:Org.BouncyCastle.Pkix.X500NameSymbols.CountryOfResidence">
            RFC 3039 CountryOfCitizenship - PrintableString (SIZE (2)) -- ISO 3166
            codes only
        </member>
        <member name="F:Org.BouncyCastle.Pkix.X500NameSymbols.NameAtBirth">
            s
            ISIS-MTT NameAtBirth - DirectoryString(SIZE(1..64)
        </member>
        <member name="F:Org.BouncyCastle.Pkix.X500NameSymbols.PostalAddress">
            RFC 3039 PostalAddress - SEQUENCE SIZE (1..6) OF
            DirectoryString(SIZE(1..30))
        </member>
        <member name="F:Org.BouncyCastle.Pkix.X500NameSymbols.DmdName">
            RFC 2256 dmdName
        </member>
        <member name="F:Org.BouncyCastle.Pkix.X500NameSymbols.TelephoneNumber">
            id-at-telephoneNumber
        </member>
        <member name="F:Org.BouncyCastle.Pkix.X500NameSymbols.OrganizationIdentifier">
            id-at-organizationIdentifier
        </member>
        <member name="F:Org.BouncyCastle.Pkix.X500NameSymbols.Name">
            id-at-name
        </member>
        <member name="F:Org.BouncyCastle.Pkix.X500NameSymbols.EmailAddress">
            Email address (RSA PKCS#9 extension) - IA5String.
            <p>Note: if you're trying to be ultra orthodox, don't use this! It shouldn't be in here.</p>
        </member>
        <member name="F:Org.BouncyCastle.Pkix.X500NameSymbols.UnstructuredName">
            more from PKCS#9
        </member>
        <member name="F:Org.BouncyCastle.Pkix.X500NameSymbols.E">
            email address in Verisign certificates
        </member>
        <member name="F:Org.BouncyCastle.Pkix.X500NameSymbols.UID">
            LDAP User id.
        </member>
        <member name="F:Org.BouncyCastle.Pkix.X500NameSymbols.DefaultSymbols">
            default look up table translating OID values into their common symbols following
            the convention in RFC 2253 with a few extras
        </member>
        <member name="F:Org.BouncyCastle.Pkix.X500NameSymbols.RFC2253Symbols">
            look up table translating OID values into their common symbols following the convention in RFC 2253
        </member>
        <member name="F:Org.BouncyCastle.Pkix.X500NameSymbols.RFC1779Symbols">
             look up table translating OID values into their common symbols following the convention in RFC 1779
            
        </member>
        <member name="F:Org.BouncyCastle.Pkix.X500NameSymbols.DefaultLookup">
            look up table translating common symbols into their OIDS.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.X509AttrCertStoreSelector.Match(Org.BouncyCastle.Cert.X509V2AttributeCertificate)">
            <summary>
            Decides if the given attribute certificate should be selected.
            </summary>
            <param name="obj">The attribute certificate to be checked.</param>
            <returns><code>true</code> if the object matches this selector.</returns>
        </member>
        <member name="P:Org.BouncyCastle.Pkix.X509AttrCertStoreSelector.AttributeCert">
            <summary>The attribute certificate which must be matched.</summary>
            <remarks>If <c>null</c> is given, any will do.</remarks>
        </member>
        <member name="P:Org.BouncyCastle.Pkix.X509AttrCertStoreSelector.AttributeCertificateValid">
            <summary>The criteria for validity</summary>
            <remarks>If <c>null</c> is given any will do.</remarks>
        </member>
        <member name="P:Org.BouncyCastle.Pkix.X509AttrCertStoreSelector.Holder">
            <summary>The holder.</summary>
            <remarks>If <c>null</c> is given any will do.</remarks>
        </member>
        <member name="P:Org.BouncyCastle.Pkix.X509AttrCertStoreSelector.Issuer">
            <summary>The issuer.</summary>
            <remarks>If <c>null</c> is given any will do.</remarks>
        </member>
        <member name="P:Org.BouncyCastle.Pkix.X509AttrCertStoreSelector.SerialNumber">
            <summary>The serial number.</summary>
            <remarks>If <c>null</c> is given any will do.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.X509AttrCertStoreSelector.AddTargetName(Org.BouncyCastle.Asn1.X509.GeneralName)">
             Adds a target name criterion for the attribute certificate to the target
             information extension criteria. The <code>X509AttributeCertificate</code>
             must contain at least one of the specified target names.
             <p>
             Each attribute certificate may contain a target information extension
             limiting the servers where this attribute certificate can be used. If
             this extension is not present, the attribute certificate is not targeted
             and may be accepted by any server.
             </p>
            
             @param name The name as a GeneralName (not <code>null</code>)
        </member>
        <member name="M:Org.BouncyCastle.Pkix.X509AttrCertStoreSelector.AddTargetName(System.Byte[])">
             Adds a target name criterion for the attribute certificate to the target
             information extension criteria. The <code>X509AttributeCertificate</code>
             must contain at least one of the specified target names.
             <p>
             Each attribute certificate may contain a target information extension
             limiting the servers where this attribute certificate can be used. If
             this extension is not present, the attribute certificate is not targeted
             and may be accepted by any server.
             </p>
            
             @param name a byte array containing the name in ASN.1 DER encoded form of a GeneralName
             @throws IOException if a parsing error occurs.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.X509AttrCertStoreSelector.SetTargetNames(System.Collections.Generic.IEnumerable{System.Object})">
            Adds a collection with target names criteria. If <code>null</code> is
            given any will do.
            <p>
            The collection consists of either GeneralName objects or byte[] arrays representing
            DER encoded GeneralName structures.
            </p>
            
            @param names A collection of target names.
            @throws IOException if a parsing error occurs.
            @see #AddTargetName(byte[])
            @see #AddTargetName(GeneralName)
        </member>
        <member name="M:Org.BouncyCastle.Pkix.X509AttrCertStoreSelector.GetTargetNames">
            Gets the target names. The collection consists of <code>List</code>s
            made up of an <code>Integer</code> in the first entry and a DER encoded
            byte array or a <code>String</code> in the second entry.
            <p>The returned collection is immutable.</p>
            
            @return The collection of target names
            @see #setTargetNames(Collection)
        </member>
        <member name="M:Org.BouncyCastle.Pkix.X509AttrCertStoreSelector.AddTargetGroup(Org.BouncyCastle.Asn1.X509.GeneralName)">
             Adds a target group criterion for the attribute certificate to the target
             information extension criteria. The <code>X509AttributeCertificate</code>
             must contain at least one of the specified target groups.
             <p>
             Each attribute certificate may contain a target information extension
             limiting the servers where this attribute certificate can be used. If
             this extension is not present, the attribute certificate is not targeted
             and may be accepted by any server.
             </p>
            
             @param group The group as GeneralName form (not <code>null</code>)
        </member>
        <member name="M:Org.BouncyCastle.Pkix.X509AttrCertStoreSelector.AddTargetGroup(System.Byte[])">
             Adds a target group criterion for the attribute certificate to the target
             information extension criteria. The <code>X509AttributeCertificate</code>
             must contain at least one of the specified target groups.
             <p>
             Each attribute certificate may contain a target information extension
             limiting the servers where this attribute certificate can be used. If
             this extension is not present, the attribute certificate is not targeted
             and may be accepted by any server.
             </p>
            
             @param name a byte array containing the group in ASN.1 DER encoded form of a GeneralName
             @throws IOException if a parsing error occurs.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.X509AttrCertStoreSelector.SetTargetGroups(System.Collections.IEnumerable)">
             Adds a collection with target groups criteria. If <code>null</code> is
             given any will do.
             <p>
             The collection consists of <code>GeneralName</code> objects or <code>byte[]</code>
             representing DER encoded GeneralNames.
             </p>
            
             @param names A collection of target groups.
             @throws IOException if a parsing error occurs.
             @see #AddTargetGroup(byte[])
             @see #AddTargetGroup(GeneralName)
        </member>
        <member name="M:Org.BouncyCastle.Pkix.X509AttrCertStoreSelector.GetTargetGroups">
             Gets the target groups. The collection consists of <code>List</code>s
             made up of an <code>Integer</code> in the first entry and a DER encoded
             byte array or a <code>String</code> in the second entry.
             <p>The returned collection is immutable.</p>
            
             @return The collection of target groups.
             @see #setTargetGroups(Collection)
        </member>
        <member name="P:Org.BouncyCastle.Pkix.X509CertStoreSelector.Policy">
            <summary>
            An <code>ISet</code> of <code>DerObjectIdentifier</code> objects.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.X509CollectionStore.#ctor(System.Collections.Generic.ICollection{Org.BouncyCastle.Cert.X509Certificate})">
             Basic constructor.
            
             @param collection - initial contents for the store, this is copied.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.X509CollectionStore.Org#BouncyCastle#Utilities#IStore{Org#BouncyCastle#Cert#X509Certificate}#GetMatches(Org.BouncyCastle.Utilities.ISelector{Org.BouncyCastle.Cert.X509Certificate})">
             Return the matches in the collection for the passed in selector.
            
             @param selector the selector to match against.
             @return a possibly empty collection of matching objects.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.X509CrlCollectionStore.#ctor(System.Collections.Generic.ICollection{Org.BouncyCastle.Cert.X509Crl})">
             Basic constructor.
            
             @param collection - initial contents for the store, this is copied.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.X509CrlCollectionStore.Org#BouncyCastle#Utilities#IStore{Org#BouncyCastle#Cert#X509Crl}#GetMatches(Org.BouncyCastle.Utilities.ISelector{Org.BouncyCastle.Cert.X509Crl})">
             Return the matches in the collection for the passed in selector.
            
             @param selector the selector to match against.
             @return a possibly empty collection of matching objects.
        </member>
        <member name="P:Org.BouncyCastle.Pkix.X509CrlStoreSelector.Issuers">
            <summary>
            An <code>ICollection</code> of <code>X509Name</code> objects
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Pkix.X509CrlStoreSelector.AttrCertChecking">
             The attribute certificate being checked. This is not a criterion.
             Rather, it is optional information that may help a {@link X509Store} find
             CRLs that would be relevant when checking revocation for the specified
             attribute certificate. If <code>null</code> is specified, then no such
             optional information is provided.
            
             @param attrCert the <code>IX509AttributeCertificate</code> being checked (or
                         <code>null</code>)
             @see #getAttrCertificateChecking()
        </member>
        <member name="P:Org.BouncyCastle.Pkix.X509CrlStoreSelector.CompleteCrlEnabled">
             If <code>true</code> only complete CRLs are returned. Defaults to
             <code>false</code>.
            
             @return <code>true</code> if only complete CRLs are returned.
        </member>
        <member name="P:Org.BouncyCastle.Pkix.X509CrlStoreSelector.DeltaCrlIndicatorEnabled">
             Returns if this selector must match CRLs with the delta CRL indicator
             extension set. Defaults to <code>false</code>.
            
             @return Returns <code>true</code> if only CRLs with the delta CRL
                     indicator extension are selected.
        </member>
        <member name="P:Org.BouncyCastle.Pkix.X509CrlStoreSelector.IssuingDistributionPoint">
             The issuing distribution point.
             <p>
             The issuing distribution point extension is a CRL extension which
             identifies the scope and the distribution point of a CRL. The scope
             contains among others information about revocation reasons contained in
             the CRL. Delta CRLs and complete CRLs must have matching issuing
             distribution points.</p>
             <p>
             The byte array is cloned to protect against subsequent modifications.</p>
             <p>
             You must also enable or disable this criteria with
             {@link #setIssuingDistributionPointEnabled(bool)}.</p>
            
             @param issuingDistributionPoint The issuing distribution point to set.
                                             This is the DER encoded OCTET STRING extension value.
             @see #getIssuingDistributionPoint()
        </member>
        <member name="P:Org.BouncyCastle.Pkix.X509CrlStoreSelector.IssuingDistributionPointEnabled">
             Whether the issuing distribution point criteria should be applied.
             Defaults to <code>false</code>.
             <p>
             You may also set the issuing distribution point criteria if not a missing
             issuing distribution point should be assumed.</p>
            
             @return Returns if the issuing distribution point check is enabled.
        </member>
        <member name="P:Org.BouncyCastle.Pkix.X509CrlStoreSelector.MaxBaseCrlNumber">
             The maximum base CRL number. Defaults to <code>null</code>.
            
             @return Returns the maximum base CRL number.
             @see #setMaxBaseCRLNumber(BigInteger)
        </member>
        <member name="M:Org.BouncyCastle.Pkix.X509IOUtilities.ParseCRL(System.Object)">
            <summary>
            Parse a single CRL from the source.
            </summary>
            <param name="src">Source must be either byte[] or stream.</param>
            <returns>A CRL.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.X509IOUtilities.ParseCRLs(System.Object)">
            <summary>
            Parse a list of CRLs.
            </summary>
            <param name="src">source must be either byte[] or stream.</param>
            <returns>A collection o X509Crls.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.X509CrlParser.ReadCrl(System.Byte[])">
            <summary>
            Create loading data from byte array.
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.X509CrlParser.ReadCrls(System.Byte[])">
            <summary>
            Create loading data from byte array.
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:Org.BouncyCastle.Pkix.X509CrlParser.ReadCrl(System.IO.Stream)">
            Generates a certificate revocation list (CRL) object and initializes
            it with the data read from the input stream inStream.
        </member>
        <member name="M:Org.BouncyCastle.Pkix.X509CrlParser.ReadCrls(System.IO.Stream)">
             Returns a (possibly empty) collection view of the CRLs read from
             the given input stream inStream.
            
             The inStream may contain a sequence of DER-encoded CRLs, or
             a PKCS#7 CRL set.  This is a PKCS#7 SignedData object, with the
             only significant field being crls.  In particular the signature
             and the contents are ignored.
        </member>
    </members>
</doc>
